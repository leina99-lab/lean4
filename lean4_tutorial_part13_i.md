# Part 13-I: 최단경로 문제 — 다익스트라 알고리즘과 플로이드 알고리즘

> **Rosen 이산수학 8판 · Section 10.6 기반**
> 『Mathematics in Lean』 + Lean 4 공식화

---

## 0. 들어가며

Part 13-G(오일러), Part 13-H(해밀턴)에서는 "모든 모서리/꼭지점을 한 번씩 방문하는 경로"를 다루었다. 이번 파트에서는 **가중치 그래프**(weighted graph)에서 두 꼭지점 사이의 **최단경로**(shortest path)를 찾는 문제를 다룬다.

이 파트에서 다루는 내용:

1. **가중치 그래프**(weighted graph)의 정의
2. **다익스트라 알고리즘**(Dijkstra's algorithm) — 한 꼭지점에서 모든 꼭지점까지의 최단경로
3. **플로이드 알고리즘**(Floyd's algorithm) — 모든 쌍의 최단경로
4. **순회 외판원 문제**(TSP)와 **근사 알고리즘**
5. Lean 4에서 가중치 그래프와 최단경로 형식화

> **비유**: 네비게이션 앱이 "서울에서 부산까지 가장 빠른 길"을 찾는 것이 바로 최단경로 문제이다.

---

## 1. 가중치 그래프

### 1.1 정의

**가중치 그래프**(weighted graph)는 각 **모서리**(edge)에 **숫자**(가중치, weight)를 할당한 그래프이다. 가중치는 **거리**, **시간**, **비용** 등을 나타낼 수 있다.

> **비유**: 지도에서 도시 = 꼭지점, 도로 = 모서리, 도로 위의 거리(km) = 가중치

### 1.2 가중치 그래프에서 경로의 **길이**(length)

가중치 그래프에서 경로의 **길이**는 경로에 포함된 모서리들의 **가중치의 합**이다.

- 가중치가 없는 그래프에서: 경로의 길이 = 모서리의 **수**
- 가중치 그래프에서: 경로의 길이 = 모서리 가중치의 **합**

### 1.3 Lean 4에서 가중치 그래프

```lean
-- 가중치 그래프: 꼭지점 집합 + 가중치 함수
structure WeightedGraph (n : Nat) where
  weight : Fin n → Fin n → Nat  -- w(i,j) = 모서리 {i,j}의 가중치
  -- 모서리가 없으면 ∞ (여기서는 큰 수로 대체)
  -- 자기 자신까지 거리 = 0
  self_zero : ∀ i, weight i i = 0

-- 예제: Rosen 그림 3의 가중치 그래프
-- 꼭지점: a=0, b=1, c=2, d=3, e=4, z=5
-- 모서리와 가중치:
-- {a,b}=4, {a,c}=3, {a,d}=2, {b,c}=3, {b,z}=2,
-- {c,z}=1, {d,e}=3, {e,z}=... 

def exampleGraph : WeightedGraph 6 where
  weight i j := 
    match i.val, j.val with
    | 0, 1 => 4  | 1, 0 => 4   -- a-b: 4
    | 0, 2 => 3  | 2, 0 => 3   -- a-c: 3 (직접 또는 경유)
    | 0, 3 => 2  | 3, 0 => 2   -- a-d: 2
    | 1, 2 => 3  | 2, 1 => 3   -- b-c: 3 (직접)
    | 1, 5 => 2  | 5, 1 => 2   -- b-z: 2
    | 2, 5 => 1  | 5, 2 => 1   -- c-z: 1
    | 3, 4 => 3  | 4, 3 => 3   -- d-e: 3
    | 4, 5 => 3  | 5, 4 => 3   -- e-z: (예시)
    | i, j => if i = j then 0 else 999  -- 999 = "무한대" (연결 안 됨)
  self_zero := by intro i; simp
```

---

## 2. 다익스트라 알고리즘 (Dijkstra's Algorithm)

### 2.1 핵심 아이디어

네덜란드의 수학자 **에드스헤르 다익스트라**(Edsger Dijkstra, 1930~2002)가 1959년에 발견한 알고리즘이다.

> **핵심**: 시작점 $a$에서 가장 가까운 꼭지점부터 차례대로 확정해 나간다 — **욕심쟁이**(greedy) 전략!

**비유**: 물을 시작점에 부으면 가장 가까운 곳부터 물이 차 올라간다. 물이 도달하는 순서가 바로 최단경로의 순서이다.

### 2.2 알고리즘의 단계별 설명

**입력**: 가중치 그래프 $G$, 시작점 $a$, 도착점 $z$

**초기화**:
- $L(a) = 0$ (시작점까지 거리 = 0)
- $L(v) = \infty$ (다른 모든 꼭지점까지 거리 = 무한대)
- $S = \emptyset$ (확정된 꼭지점 집합 = 빈 집합)

**반복** ($z$가 $S$에 포함될 때까지):
1. $S$에 속하지 않는 꼭지점 중 $L(u)$가 **가장 작은** 꼭지점 $u$를 선택
2. $u$를 $S$에 추가: $S := S \cup \{u\}$
3. $S$에 속하지 않는 모든 꼭지점 $v$에 대해 라벨을 **갱신**:
   
   $$L_k(v) = \min\{L_{k-1}(v), \quad L_{k-1}(u) + w(u, v)\}$$
   
   즉, "기존 경로"와 "$u$를 경유하는 새 경로" 중 짧은 것을 선택

**종료**: $z$가 $S$에 추가되면, $L(z)$가 $a$에서 $z$까지의 최단경로 길이

### 2.3 예제: 다익스트라 알고리즘 실행

Rosen 그림 3의 그래프에서 $a$부터 $z$까지의 최단경로:

```
         b
        / \
    4  /   \ 2
      /  8  \
   a ──────── z
    │╲  3  ╱│
   2│  ╲ ╱  │1
    │   c   │
    d       │
     ╲   3  │
    3 ╲   ╱
       e
```

**단계별 실행**:

| 단계 | $S$에 추가 | $L(a)$ | $L(b)$ | $L(c)$ | $L(d)$ | $L(e)$ | $L(z)$ |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| 초기 | — | **0** | ∞ | ∞ | ∞ | ∞ | ∞ |
| 1 | $a$ | 0 | **4** | **3** | **2** | ∞ | ∞ |
| 2 | $d$ | 0 | 4 | 3 | 2 | **5** | ∞ |
| 3 | $c$ | 0 | 4 | 3 | 2 | 5 | **4** |
| 4 | $b$ | 0 | 4 | 3 | 2 | 5 | 4 |
| 5 | $z$ | 0 | 4 | 3 | 2 | 5 | **4** |

> (※ 이 예제의 가중치는 설명을 위한 것이다. 교과서의 정확한 수치와 다를 수 있다.)

**최단경로**: $a \to c \to z$, 길이 = 3 + 1 = **4**

### 2.4 왜 다익스트라 알고리즘이 올바른가? (정리 1)

> **정리 1** (Rosen Theorem 1)
>
> 다익스트라 알고리즘은 연결 단순 비방향성 가중치 그래프에서 두 꼭지점 간의 **최단경로의 길이**를 구한다.

**증명의 핵심** (귀납법):

$k$번째 반복에서 $S$에 추가되는 꼭지점 $u$에 대해:
- **(i)** $S$의 모든 꼭지점 $v$의 라벨 $L(v)$는 $a$에서 $v$까지의 **최단경로 길이**이다.
- **(ii)** $S$에 속하지 않는 모든 꼭지점 $v$의 라벨은 $S$의 꼭지점들만을 경유하는 최단경로 길이이다.

이 두 성질이 각 단계에서 유지됨을 귀납법으로 보인다.

### 2.5 시간 복잡도

> **정리 2** (Rosen Theorem 2)
>
> 다익스트라 알고리즘은 $O(n^2)$ 연산(덧셈과 비교)을 사용한다. ($n$ = 꼭지점 수)

각 반복에서:
- 최소 라벨 찾기: $O(n)$ 비교
- 라벨 갱신: $O(n)$ 덧셈 + 비교
- 총 반복 횟수: $O(n)$

따라서 전체: $O(n) \times O(n) = O(n^2)$

### 2.6 Lean 4에서 다익스트라 알고리즘

```lean
-- 다익스트라 알고리즘의 핵심 구조

-- 라벨 갱신 함수
-- L_k(v) = min(L_{k-1}(v), L_{k-1}(u) + w(u, v))
def updateLabel (oldLabel : Nat) (distToU : Nat) (weightUV : Nat) : Nat :=
  min oldLabel (distToU + weightUV)

-- 예제: updateLabel 10 3 4 = min(10, 3+4) = min(10, 7) = 7
#eval updateLabel 10 3 4  -- 7

-- 다익스트라 알고리즘 (간단화된 버전)
-- 입력: 가중치 행렬, 시작점, 꼭지점 수
-- 출력: 각 꼭지점까지의 최단거리 배열

def dijkstra (n : Nat) (w : Fin n → Fin n → Nat) (start : Fin n) : 
    Fin n → Nat := by
  sorry  -- 완전한 구현은 아래 연습문제에서

-- 핵심 아이디어만 표현:
-- 1. dist[start] = 0, dist[v] = ∞ (v ≠ start)
-- 2. 반복: 가장 작은 dist를 가진 미방문 꼭지점 u를 선택
-- 3. u의 이웃 v에 대해: dist[v] = min(dist[v], dist[u] + w(u,v))
```

---

## 3. 플로이드 알고리즘 (Floyd's Algorithm)

### 3.1 다익스트라 vs 플로이드

| | 다익스트라 | 플로이드 |
|:---|:---|:---|
| **구하는 것** | 한 꼭지점 → 모든 꼭지점 | **모든 쌍**의 최단경로 |
| **시간 복잡도** | $O(n^2)$ | $O(n^3)$ |
| **음수 가중치** | ❌ 불가 | ⚠️ (음수 순환이 없으면 가능) |
| **구현 난이도** | 보통 | 매우 간단! |

### 3.2 알고리즘

```
procedure Floyd(G: 가중치 단순 그래프)
  {G의 꼭지점: v₁, v₂, ..., vₙ, 가중치: w(vᵢ, vⱼ)}
  
  -- 초기화: d(vᵢ, vⱼ) = w(vᵢ, vⱼ)  (직접 연결 가중치)
  for i := 1 to n
    for j := 1 to n
      d(vᵢ, vⱼ) := w(vᵢ, vⱼ)
  
  -- 핵심: k를 경유지로 사용하여 거리 갱신
  for i := 1 to n       -- 경유지 후보
    for j := 1 to n     -- 출발지
      for k := 1 to n   -- 도착지
        if d(vⱼ, vᵢ) + d(vᵢ, vₖ) < d(vⱼ, vₖ) then
          d(vⱼ, vₖ) := d(vⱼ, vᵢ) + d(vᵢ, vₖ)
  
  return d  -- d(vᵢ, vⱼ) = vᵢ에서 vⱼ까지의 최단경로 길이
```

### 3.3 핵심 아이디어

플로이드 알고리즘의 아이디어는 놀랍도록 단순하다:

> "꼭지점 $k$를 경유하면 더 짧아지는가?"를 모든 쌍에 대해, 모든 경유지 $k$에 대해 확인한다.

$d(i, j) = \min(d(i, j), \quad d(i, k) + d(k, j))$

"$i$에서 $j$로 직접 가는 것" vs "$i$에서 $k$를 거쳐 $j$로 가는 것" 중 짧은 것을 선택!

### 3.4 Lean 4에서 플로이드 알고리즘

```lean
-- 플로이드 알고리즘의 핵심 갱신 규칙
-- d(j,k) = min(d(j,k), d(j,i) + d(i,k))

-- 행렬 기반 구현 (개념적)
def floydUpdate (d : Fin n → Fin n → Nat) (i j k : Fin n) : Nat :=
  min (d j k) (d j i + d i k)

-- 3중 루프 (개념적)
-- for i in range(n):
--   for j in range(n):
--     for k in range(n):
--       d[j][k] = min(d[j][k], d[j][i] + d[i][k])
```

---

## 4. 연습문제

### 연습 4.1: 다익스트라 알고리즘 실행 (괄호 채우기)

다음 가중치 그래프에서 $a$부터 $z$까지 다익스트라 알고리즘을 실행하라.

```
      b ─── d
     / 5    │╲ 6
   4/       │  ╲
  a ── 2 ── c    z
   ╲        │  ╱
    ╲ 2   10│ ╱ 3
     d      │╱
      ╲── e
        3
```

(간단한 예: a=0, b=1, c=2, d=3, z=4)
가중치: w(a,b)=4, w(a,c)=2, w(b,d)=5, w(c,d)=10, w(c,z)=3, w(d,z)=6

| 단계 | $S$에 추가 | $L(a)$ | $L(b)$ | $L(c)$ | $L(d)$ | $L(z)$ |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| 초기 | — | 0 | ∞ | ∞ | ∞ | ∞ |
| 1 | $a$ | 0 | 【  】 | 【  】 | ∞ | ∞ |
| 2 | 【  】 | 0 | 4 | 2 | 【  】 | 【  】 |
| 3 | 【  】 | 0 | 4 | 2 | 【  】 | 5 |
| 4 | 【  】 | 0 | 4 | 2 | 9 | **5** |

최단경로: $a \to$ 【  】$\to z$, 길이 = 【  】

<details>
<summary>📝 답 보기</summary>

```
| 단계 | S에 추가 | L(a) | L(b) | L(c) | L(d) | L(z) |
|  초기  |   —   |  0   |  ∞   |  ∞   |  ∞   |  ∞   |
|   1   |   a   |  0   |  4   |  2   |  ∞   |  ∞   |
|   2   |   c   |  0   |  4   |  2   |  12  |  5   |
|   3   |   b   |  0   |  4   |  2   |  9   |  5   |
|   4   |   z   |  0   |  4   |  2   |  9   |  5   |

최단경로: a → c → z, 길이 = 2 + 3 = 5
```

</details>

---

### 연습 4.2: 라벨 갱신 규칙 (괄호 채우기)

```lean
-- 다익스트라의 핵심: 라벨 갱신 규칙
-- L_k(v) = min(L_{k-1}(v),  L_{k-1}(u) + w(u, v))
-- 여기서 u는 k번째 단계에서 S에 추가되는 꼭지점

-- 예제: L(v) = 10, L(u) = 3, w(u,v) = 4
-- 갱신 후 L(v) = min(【  】, 【  】 + 【  】) = min(10, 7) = 【  】
-- (답: 10, 3, 4, 7)

-- 예제: L(v) = 5, L(u) = 3, w(u,v) = 4
-- 갱신 후 L(v) = min(【  】, 【  】 + 【  】) = min(5, 7) = 【  】
-- (답: 5, 3, 4, 5)  ← 기존 값이 더 작으므로 변경 없음!

-- Lean 4:
example : min 10 (3 + 4) = 【  】 := by decide  -- (답: 7)
example : min 5 (3 + 4) = 【  】 := by decide   -- (답: 5)
```

<details>
<summary>📝 답 보기</summary>

```
예제 1: min(10, 3+4) = min(10, 7) = 7 (갱신!)
예제 2: min(5, 3+4) = min(5, 7) = 5 (유지!)

Lean 4:
example : min 10 (3 + 4) = 7 := by decide
example : min 5 (3 + 4) = 5 := by decide
```

</details>

---

### 연습 4.3: 플로이드 알고리즘 실행 (괄호 채우기)

3개 꼭지점 그래프에서 플로이드 알고리즘을 실행하라.

```
    0 ──2── 1
     ╲     ╱
    6  ╲ ╱ 3
        2
```

초기 거리 행렬:
```
     0    1    2
0  [ 0    2    6  ]
1  [ 2    0    3  ]
2  [ 6    3    0  ]
```

**경유지 0을 고려한 후** (i=0):
```
d(1,2) = min(d(1,2), d(1,0)+d(0,2)) = min(3, 2+6) = min(3, 8) = 【  】  (답: 3)
d(2,1) = min(d(2,1), d(2,0)+d(0,1)) = min(3, 6+2) = min(3, 8) = 【  】  (답: 3)
```
→ 변화 없음 (직접 경로가 더 짧음)

**경유지 1을 고려한 후** (i=1):
```
d(0,2) = min(d(0,2), d(0,1)+d(1,2)) = min(6, 2+3) = min(6, 5) = 【  】  (답: 5)
d(2,0) = min(d(2,0), d(2,1)+d(1,0)) = min(6, 3+2) = min(6, 5) = 【  】  (답: 5)
```
→ **갱신!** 0에서 2로 1을 경유하면 더 짧다 (6 → 5)

최종 거리 행렬:
```
     0    1    2
0  [ 0    2    【  】 ]  (답: 5)
1  [ 2    0    3     ]
2  [ 【  】 3    0   ]  (답: 5)
```

<details>
<summary>📝 답 보기</summary>

```
최종 거리 행렬:
     0    1    2
0  [ 0    2    5  ]
1  [ 2    0    3  ]
2  [ 5    3    0  ]

0→2의 최단경로: 0→1→2 (거리 5), 직접 경로(6)보다 짧다!
```

</details>

---

### 연습 4.4: Lean 4로 라벨 갱신 함수 (skeleton)

```lean
-- 다익스트라의 라벨 갱신 함수
def updateLabel (oldLabel : Nat) (distToU : Nat) (weightUV : Nat) : Nat :=
  【                                          】  -- (답: min oldLabel (distToU + weightUV))

-- 테스트
#eval updateLabel 10 3 4  -- 기대값: 【  】 (답: 7)
#eval updateLabel 5 3 4   -- 기대값: 【  】 (답: 5)
#eval updateLabel 100 0 50 -- 기대값: 【  】 (답: 50)
```

<details>
<summary>📝 답 보기</summary>

```lean
def updateLabel (oldLabel : Nat) (distToU : Nat) (weightUV : Nat) : Nat :=
  min oldLabel (distToU + weightUV)

#eval updateLabel 10 3 4   -- 7
#eval updateLabel 5 3 4    -- 5
#eval updateLabel 100 0 50 -- 50
```

</details>

---

### 연습 4.5: Lean 4로 플로이드 갱신 (skeleton)

```lean
-- 플로이드 알고리즘의 핵심 갱신
-- d[j][k] = min(d[j][k], d[j][i] + d[i][k])

def floydUpdate (d : Fin n → Fin n → Nat) (i j k : Fin n) : Nat :=
  min (d 【  】 【  】) (d 【  】 【  】 + d 【  】 【  】)
  -- (답: j, k, j, i, i, k)

-- 3×3 예제에서 테스트
def dist3 : Fin 3 → Fin 3 → Nat
  | 0, 1 => 2  | 1, 0 => 2
  | 0, 2 => 6  | 2, 0 => 6
  | 1, 2 => 3  | 2, 1 => 3
  | i, j => if i = j then 0 else 999

-- 경유지 1을 통한 (0,2) 갱신:
-- min(d(0,2), d(0,1) + d(1,2)) = min(6, 2+3) = 5
#eval floydUpdate dist3 1 0 2  -- 기대값: 【  】 (답: 5)
```

<details>
<summary>📝 답 보기</summary>

```lean
def floydUpdate (d : Fin n → Fin n → Nat) (i j k : Fin n) : Nat :=
  min (d j k) (d j i + d i k)

#eval floydUpdate dist3 1 0 2  -- 5 ✅
```

</details>

---

### 연습 4.6: 다익스트라의 정확성 (sorry)

```lean
-- "다익스트라 알고리즘은 올바른 최단경로를 구한다"
-- 이것은 탐욕 알고리즘의 정확성 증명이다.

-- 핵심 불변식(invariant):
-- S에 속한 모든 꼭지점 v에 대해 L(v) = a에서 v까지의 최단경로 길이

-- Lean 4 표현 (개념적):
theorem dijkstra_correct 
    (G : WeightedGraph n) (a z : Fin n) :
    dijkstra n G.weight a z = shortestPathLength G a z := by
  sorry
  -- 증명: 수학적 귀납법으로 각 단계에서 불변식이 유지됨을 보인다.
```

<details>
<summary>📝 답 보기</summary>

```lean
-- 완전한 증명은 교과서의 귀납적 증명을 형식화해야 한다.
-- 핵심 단계:
-- 기본: k=0일 때 S=∅, L(a)=0은 정확
-- 귀납: k번째 단계에서 추가된 u에 대해
--   L(u)가 a에서 u까지의 최단경로임을 보임
--   (만약 더 짧은 경로가 있다면, S 밖의 꼭지점을 지나야 하는데,
--    그런 꼭지점의 라벨은 L(u) 이상이므로 모순)
```

</details>

---

### 연습 4.7: 시간 복잡도 비교 (괄호 채우기)

```
-- n = 100인 그래프에서:

-- 다익스트라 (한 쌍):
-- 시간 복잡도: O(【    】) = O(【      】)  (답: n², 10000)

-- 다익스트라를 모든 꼭지점에서 실행 (모든 쌍):
-- 시간 복잡도: O(【    】 × 【    】) = O(【    】)  (답: n, n², n³)
-- = O(【        】)  (답: 1000000)

-- 플로이드 (모든 쌍):
-- 시간 복잡도: O(【    】) = O(【        】)  (답: n³, 1000000)

-- 다익스트라 n번 vs 플로이드: 
-- 같은 O(n³)이지만, 플로이드는 구현이 【        】 (답: 더 간단하다)

-- 음수 가중치가 있으면:
-- 다익스트라: 【        】 (답: 사용 불가)
-- 플로이드: 【        】 (답: 음수 순환이 없으면 사용 가능)
```

<details>
<summary>📝 답 보기</summary>

```
다익스트라 (한 쌍): O(n²) = O(10000)
다익스트라 (모든 쌍): O(n × n²) = O(n³) = O(1000000)
플로이드 (모든 쌍): O(n³) = O(1000000)

같은 O(n³)이지만 플로이드가 구현이 더 간단하다.
음수 가중치: 다익스트라 불가, 플로이드 가능 (음수 순환 없으면).
```

</details>

---

### 연습 4.8: 근사 알고리즘 개념 (괄호 채우기)

```
-- TSP에 대한 근사 알고리즘(approximation algorithm)이란:
-- 정확한 해답을 구하는 것이 아니라
-- 【                              】을 구하도록 보장하는 알고리즘
-- (답: 정확한 해답에 근접한 해답)

-- 근사 비율 c: W ≤ W' ≤ cW
-- 여기서 W = 【            】 (답: 정확한 최적해의 비용)
-- W' = 【            】 (답: 근사 알고리즘이 구한 해의 비용)
-- c = 【            】 (답: 근사 보장 상수, 예: c = 3/2)

-- n = 1000인 TSP:
-- 정확한 해: (n-1)!/2 = 【       】개의 순환 확인 → 사실상 불가능
-- (답: 999!/2 ≈ 엄청나게 큰 수)
-- 근사 알고리즘: 다항 시간에 최적해의 c배 이내의 해를 구함 → 실용적!
```

<details>
<summary>📝 답 보기</summary>

```
근사 알고리즘: 정확한 해답에 근접한 해답을 구하도록 보장
W = 정확한 최적해의 비용
W' = 근사 알고리즘이 구한 해의 비용
c = 근사 보장 상수 (예: c = 3/2이면 최적해의 1.5배 이내)

n=1000 TSP: 999!/2 개의 순환 → 불가능
→ 근사 알고리즘으로 수분 이내에 2% 오차 이내의 답 가능!
```

</details>

---

## 5. 핵심 요약

1. **가중치 그래프**(weighted graph)는 모서리에 숫자(거리, 비용 등)가 할당된 그래프이다.

2. **다익스트라 알고리즘**: 한 꼭지점에서 모든 꼭지점까지의 최단경로를 $O(n^2)$에 구한다. **탐욕적**(greedy) 전략 사용.

3. **핵심 갱신**: $L_k(v) = \min(L_{k-1}(v), L_{k-1}(u) + w(u,v))$

4. **플로이드 알고리즘**: 모든 쌍의 최단경로를 $O(n^3)$에 구한다. 3중 루프로 매우 간단한 구현.

5. **핵심 갱신**: $d(j,k) = \min(d(j,k), d(j,i) + d(i,k))$

6. **다익스트라 vs 플로이드**: 한 쌍이면 다익스트라, 모든 쌍이면 플로이드. 음수 가중치는 플로이드만 가능.

7. **정리 1**: 다익스트라 알고리즘은 올바른 최단경로를 구한다 (귀납법으로 증명).

8. **정리 2**: 다익스트라 알고리즘의 시간 복잡도는 $O(n^2)$이다.

9. **TSP**: 최소 비용 해밀턴 순환을 찾는 NP-완전 문제. 근사 알고리즘으로 실용적 해결.

10. Lean 4에서 가중치 그래프는 `Fin n → Fin n → Nat` 함수로, 갱신 규칙은 `min`으로 표현한다.

---

## 6. 사용된 Lean 4 전술 정리

| 전술/키워드 | 용도 | 예시 |
|:---|:---|:---|
| `min` | 최솟값 | `min a b` — 두 수 중 작은 것 |
| `structure` | 가중치 그래프 정의 | `WeightedGraph`, `TSPInstance` |
| `match` | 패턴 매칭 | 가중치 함수 정의 |
| `Fin n → Fin n → Nat` | 행렬 | 거리 행렬, 가중치 행렬 |
| `decide` | 결정 가능 | `min 10 7 = 7` 자동 증명 |
| `omega` | 자연수 산술 | 인덱스 범위 |
| `sorry` | 미완성 증명 | 복잡한 정확성 증명 |
| `#eval` | 계산 실행 | `#eval updateLabel 10 3 4` |

---

> **다음 파트 예고**: Part 13-J에서는 **평면 그래프**(Planar Graph, Section 10.7)를 다룬다. "그래프를 모서리가 교차하지 않도록 평면에 그릴 수 있는가?"라는 문제를 배우고, **오일러 공식** $v - e + f = 2$, **쿠라토프스키 정리**, 그리고 **그래프 색칠**(graph coloring)과 **4색 정리**를 Lean 4로 형식화한다!
