# Part 15-D: 튜링 기계 — 계산의 궁극적 모델

> **Rosen 이산수학 8판 · Chapter 13 (Section 13.5) 기반**
> **Lean 4 형식화 + 3단계 연습문제**

---

## 0. 들어가며

DFA와 NFA는 정규 언어만 인식할 수 있었다. {0ⁿ1ⁿ | n ≥ 0} 같은 간단한 언어도 인식하지 못했다. 이번 Part에서는 **모든** 계산을 수행할 수 있는 기계, **튜링 기계**(Turing machine)를 배운다.

> 💡 앨런 튜링(Alan Turing)이 1936년 발명한 이 단순한 기계는 현대 컴퓨터의 이론적 기초이다. 튜링 기계가 할 수 있는 것 = 컴퓨터가 할 수 있는 것!

### 다루는 내용

1. **튜링 기계**의 정의와 동작 원리
2. 튜링 기계를 사용한 **집합 인식** — {0ⁿ1ⁿ} 인식하기
3. 튜링 기계를 이용한 **함수 계산**
4. **처치-튜링 논제**(Church-Turing thesis)
5. **결정 가능성** — 풀 수 있는 문제와 풀 수 없는 문제
6. **P와 NP** — 다루기 쉬운 문제와 어려운 문제

---

## 1. 튜링 기계란?

### 1.1 직관: 무한한 메모장을 가진 기계

튜링 기계를 이해하기 위해 다음을 상상하라:

- **무한히 긴 테이프**: 양쪽으로 끝없이 이어지는 종이. 각 칸에 기호 하나를 쓸 수 있다.
- **읽기/쓰기 헤드**: 테이프의 한 칸을 읽고, 지우고, 새 기호를 쓸 수 있다.
- **제어 장치**: 유한개의 상태를 가진 "두뇌". 현재 상태와 읽은 기호에 따라 행동을 결정한다.

DFA와의 핵심 차이점:
| | DFA | 튜링 기계 |
|---|---|---|
| 메모리 | 상태만 (유한) | **테이프** (무한) |
| 입력 읽기 | 왼→오 한 방향 | **양방향** (좌/우) |
| 쓰기 | 불가 | **가능** (테이프에 쓸 수 있음) |
| 계산 능력 | 정규 언어만 | **모든 계산** |

> 💡 핵심: 튜링 기계는 **무한한 메모리**(테이프)가 있고, **앞뒤로 왔다갔다** 할 수 있기 때문에 DFA보다 훨씬 강력하다. 0의 개수를 세면서 1의 개수와 비교하는 것도 가능!

### 1.2 형식적 정의

> **정의 1** (Rosen 정의 1)
> **튜링 기계**(Turing machine) T = (S, I, f, s₀):
> - **S**: 상태의 유한집합
> - **I**: 알파벳 (공백 기호 **B** 포함)
> - **f**: **부분함수**(partial function) f : S × I → S × I × {R, L}
> - **s₀**: 시작 상태

**부분함수**란?: 모든 (상태, 기호) 쌍에 대해 정의될 필요가 없다. 정의되지 않은 쌍을 만나면 기계가 **정지**(halt)한다.

f(s, x) = (s', x', d)의 의미:
1. 상태를 s에서 **s'로** 변경
2. 현재 칸의 기호 x를 **x'로** 덮어쓰기
3. d = R이면 **오른쪽**, d = L이면 **왼쪽**으로 한 칸 이동

이것을 **5개 한 벌**(quintuple) **(s, x, s', x', d)** 로 쓴다.

### 1.3 Lean 4에서의 모델링

```lean
-- 이동 방향
inductive Dir where | L | R
  deriving DecidableEq, Repr

-- 튜링 기계
structure TuringMachine (S I : Type) where
  transition : S → I → Option (S × I × Dir)  -- 부분함수 (None = 정지)
  initial    : S
  blank      : I                               -- 공백 기호 B

-- 테이프 (현재 위치 중심의 양방향 리스트)
structure Tape (I : Type) where
  left    : List I    -- 왼쪽 (가장 가까운 것이 head)
  current : I         -- 현재 위치의 기호
  right   : List I    -- 오른쪽 (가장 가까운 것이 head)

-- 튜링 기계의 설정 (configuration)
structure TMConfig (S I : Type) where
  state : S
  tape  : Tape I
```

### 1.4 튜링 기계의 동작

```lean
-- 헤드를 오른쪽으로 이동
def Tape.moveRight (t : Tape I) (blank : I) : Tape I :=
  { left := t.current :: t.left
    current := t.right.headD blank
    right := t.right.tailD [] }

-- 헤드를 왼쪽으로 이동
def Tape.moveLeft (t : Tape I) (blank : I) : Tape I :=
  { left := t.left.tailD []
    current := t.left.headD blank
    right := t.current :: t.right }

-- 한 단계 실행
def TuringMachine.step (tm : TuringMachine S I)
    (config : TMConfig S I) : Option (TMConfig S I) :=
  match tm.transition config.state config.tape.current with
  | none => none   -- 정지!
  | some (s', x', dir) =>
    let newTape := { config.tape with current := x' }
    let movedTape := match dir with
      | Dir.R => newTape.moveRight tm.blank
      | Dir.L => newTape.moveLeft tm.blank
    some { state := s', tape := movedTape }

-- 최대 n 단계 실행
def TuringMachine.run (tm : TuringMachine S I)
    (config : TMConfig S I) (fuel : Nat) : TMConfig S I :=
  match fuel with
  | 0 => config
  | n + 1 => match tm.step config with
    | none => config         -- 정지
    | some config' => tm.run config' n
```

---

## 2. 튜링 기계 예제

### 2.1 예제 1 (Rosen 예제 1): 첫 번째 연속 1 쌍을 0으로 바꾸기

5개 한 벌:
```
(s₀, 0, s₀, 0, R)   -- 0을 만나면 오른쪽으로 (그냥 지나감)
(s₀, 1, s₁, 1, R)   -- 첫 번째 1 발견! 다음 칸으로
(s₀, B, s₃, B, R)   -- 공백 → 정지 (1이 없음)
(s₁, 0, s₀, 0, R)   -- 1 다음에 0 → 연속이 아님, 리셋
(s₁, 1, s₂, 0, L)   -- 1 다음에 1! → 두 번째 1을 0으로! 왼쪽으로
(s₁, B, s₃, B, R)   -- 1 다음에 공백 → 정지
(s₂, 1, s₃, 0, R)   -- 왼쪽의 첫 번째 1도 0으로! → 정지
```

테이프: `B B 0 1 0 1 1 0 B B` (↑ = 헤드 위치)

```
단계 0: [s₀] B B 0̲ 1 0 1 1 0 B B   ← 시작
단계 1: [s₀] B B 0 1̲ 0 1 1 0 B B   ← (s₀,0)→(s₀,0,R)
단계 2: [s₁] B B 0 1 0̲ 1 1 0 B B   ← (s₀,1)→(s₁,1,R)
단계 3: [s₀] B B 0 1 0 1̲ 1 0 B B   ← (s₁,0)→(s₀,0,R)
단계 4: [s₁] B B 0 1 0 1 1̲ 0 B B   ← (s₀,1)→(s₁,1,R)
단계 5: [s₂] B B 0 1 0 1 0̲ 0 B B   ← (s₁,1)→(s₂,0,L) 1→0!
단계 6: [s₃] B B 0 1 0 0̲ 0 0 B B   ← (s₂,1)→(s₃,0,R) 1→0!
정지! (s₃에서 시작하는 규칙 없음)
```

결과: 첫 번째 연속 1 쌍 "11"이 "00"으로 바뀌었다!

### 2.2 예제 2: {0ⁿ1ⁿ | n ≥ 1} 인식 (Rosen 예제 3)

이것이 튜링 기계의 진정한 위력을 보여주는 예이다. DFA로는 불가능했지만 튜링 기계는 할 수 있다!

**알고리즘**:
1. 가장 왼쪽의 0을 **M**(마커)로 바꾼다
2. 오른쪽으로 이동하여 가장 오른쪽의 1을 찾아 **M**으로 바꾼다
3. 다시 왼쪽으로 돌아가서 1번으로
4. 모든 0과 1이 M으로 바뀌면 → **수용!**
5. 0과 1의 개수가 맞지 않으면 → **거부**

```
예: 000111

단계: 000111 → M00111 → M0011M → MM011M → MM01MM → MMM1MM → MMMMMM → 수용!
```

5개 한 벌 (Rosen):
```
(s₀, 0, s₁, M, R)   -- 0을 M으로 바꾸고 오른쪽으로
(s₁, 0, s₁, 0, R)   -- 0 지나감
(s₁, 1, s₁, 1, R)   -- 1 지나감
(s₁, M, s₂, M, L)   -- 오른쪽 끝의 M 발견 → 왼쪽으로
(s₁, B, s₂, B, L)   -- 오른쪽 끝의 B 발견 → 왼쪽으로
(s₂, 1, s₃, M, L)   -- 가장 오른쪽 1을 M으로!
(s₃, 1, s₃, 1, L)   -- 1 지나감 (왼쪽으로)
(s₃, 0, s₃, 0, L)   -- 0 지나감 (왼쪽으로)
(s₃, M, s₀, M, R)   -- M 만남 → 처음으로 돌아감
(s₄, 0, s₄, 0, L)   -- (검증용)
(s₄, M, s₀, M, R)   -- (검증용)
(s₅, M, s₆, M, R)   -- 모든 기호가 M → 수용 상태 s₆!
```

> 💡 핵심: 튜링 기계는 **양방향 이동**과 **쓰기 능력** 덕분에 "0의 개수를 세면서" 1의 개수와 매칭할 수 있다. 마커 M을 사용하여 이미 처리한 기호를 표시하는 것이 핵심 기법이다.

```lean
-- 간략화된 {0ⁿ1ⁿ} 인식 튜링 기계
inductive TState where | s0 | s1 | s2 | s3 | s4 | s5 | s6
  deriving DecidableEq, Repr

inductive TSym where | zero | one | marker | blank
  deriving DecidableEq, Repr

open TState TSym Dir

def tm0n1n : TuringMachine TState TSym := {
  initial := s0
  blank := blank
  transition := fun s x => match s, x with
    | s0, zero    => some (s1, marker, R)   -- 0 → M, 오른쪽
    | s0, marker  => some (s5, marker, R)   -- M만 남음 → 검증
    | s1, zero    => some (s1, zero, R)     -- 0 스킵
    | s1, one     => some (s1, one, R)      -- 1 스킵
    | s1, marker  => some (s2, marker, L)   -- 오른쪽 끝 → 되돌아감
    | s1, blank   => some (s2, blank, L)    -- 오른쪽 끝
    | s2, one     => some (s3, marker, L)   -- 1 → M
    | s3, one     => some (s3, one, L)      -- 1 스킵 (왼쪽)
    | s3, zero    => some (s3, zero, L)     -- 0 스킵 (왼쪽)
    | s3, marker  => some (s0, marker, R)   -- 처음으로!
    | s5, marker  => some (s6, marker, R)   -- 수용! s₆ = 최종 상태
    | _, _        => none                    -- 정지 (거부)
}
```

---

## 3. 튜링 기계를 이용한 함수 계산

### 3.1 함수 계산이란?

튜링 기계는 집합 인식뿐 아니라 **함수 값 계산**에도 사용된다. 입력 x가 테이프에 쓰여 있을 때, 기계가 정지한 후 테이프에 남은 내용이 f(x)이다.

예: "단항 표기법(unary representation)으로 1을 더하는" 함수

입력: 1ⁿ (1이 n개) → 출력: 1ⁿ⁺¹ (1이 n+1개)

5개 한 벌:
```
(s₀, 1, s₀, 1, R)   -- 1을 지나감
(s₀, B, s₁, 1, R)   -- 공백을 만나면 1을 쓰고 정지
```

```
입력:  B 1 1 1 B     (= 3)
실행:  s₀에서 시작, 오른쪽으로 1 지나감, B에서 1 추가
결과:  B 1 1 1 1 B   (= 4) ✅
```

### 3.2 Lean 4로 함수 계산 모델링

```lean
-- 단항 표기법으로 n+1을 계산하는 튜링 기계
def tmSucc : TuringMachine Bool TSym := {
  initial := false  -- s₀ = false
  blank := blank
  transition := fun s x => match s, x with
    | false, one   => some (false, one, R)    -- 1 지나감
    | false, blank  => some (true, one, R)     -- B → 1 쓰고 정지
    | _, _          => none
}
```

---

## 4. 처치-튜링 논제

### 4.1 "계산 가능"이란 무엇인가?

> **처치-튜링 논제**(Church-Turing Thesis):
> **효과적으로 계산 가능한** 함수는 정확히 **튜링 기계로 계산 가능한** 함수와 같다.

이것은 수학적 정리가 **아니라** 경험적 **논제**(thesis)이다. 증명할 수 없지만, 지금까지 반례가 발견된 적도 없다.

의미: 어떤 알고리즘이든, 어떤 프로그래밍 언어로 작성했든, 어떤 컴퓨터에서 실행하든 — **튜링 기계로 시뮬레이션**할 수 있다. Python, C++, Haskell, JavaScript, **Lean 4** — 모든 프로그래밍 언어가 튜링 기계와 동등한 계산 능력을 가진다.

### 4.2 계산 가능 = 튜링 기계로 가능

| 모델 | 튜링 기계와 동등? |
|------|:---:|
| 람다 대수 (Alonzo Church) | ✅ |
| 재귀 함수 (Gödel, Kleene) | ✅ |
| 포스트 기계 (Emil Post) | ✅ |
| 모든 현대 프로그래밍 언어 | ✅ |

---

## 5. 결정 가능성과 정지 문제

### 5.1 결정 문제와 풀 수 있는/없는 문제

**결정 문제**(decision problem): "예" 또는 "아니오"로 답할 수 있는 문제.

- **풀 수 있는**(solvable) 문제: 답을 구하는 알고리즘(튜링 기계)이 존재
- **풀 수 없는**(unsolvable) 문제: 어떤 알고리즘으로도 답을 구할 수 없음!

### 5.2 정지 문제 — 풀 수 없는 문제의 대표

> **정지 문제**(Halting Problem):
> "주어진 프로그램이 주어진 입력에 대해 **정지하는가, 아니면 영원히 실행되는가?**"

앨런 튜링은 1936년에 이 문제가 **풀 수 없음**을 증명했다. 어떤 프로그램이 무한 루프에 빠지는지 아닌지를 판별하는 **일반적인** 알고리즘은 존재하지 않는다!

**증명 아이디어** (대각선 논법):

정지 판별 프로그램 H(P, x)가 존재한다고 가정하자:
- H(P, x) = "정지"  ← 프로그램 P가 입력 x에 대해 정지하면
- H(P, x) = "무한루프" ← 프로그램 P가 입력 x에 대해 정지하지 않으면

이제 새 프로그램 D를 만든다:
```
D(P):
  if H(P, P) = "정지" then 무한루프
  else 정지
```

**D(D)를 실행하면?**
- H(D, D) = "정지"라면 → D(D)는 무한루프 → 모순!
- H(D, D) = "무한루프"라면 → D(D)는 정지 → 모순!

어떤 경우든 모순이 발생하므로, H는 존재할 수 없다. ∎

```lean
-- 정지 문제의 비결정 가능성 (개념적 표현)
-- "모든 프로그램과 입력에 대해 정지 여부를 판별하는 함수는 없다"
theorem halting_problem_undecidable :
    ¬∃ (halt : (Nat → Option Nat) → Nat → Bool),
      ∀ f n, halt f n = true ↔ (f n).isSome := by
  sorry  -- 대각선 논법으로 증명
```

---

## 6. P와 NP — 다루기 쉬운 문제와 어려운 문제

### 6.1 시간 복잡도

문제가 풀 수 있다고 해도, **얼마나 빨리** 풀 수 있는지가 중요하다.

- **P**(Polynomial): 다항식 시간에 풀 수 있는 문제 (효율적!)
- **NP**(Nondeterministic Polynomial): 답이 맞는지 **검증**하는 것은 다항식 시간에 가능한 문제

### 6.2 P ⊆ NP

P에 속하는 문제는 NP에도 속한다. 풀 수 있으면 당연히 검증도 가능하니까!

### 6.3 P = NP?

> **P ≠ NP 추측**: "검증하기 쉬운 문제"와 "풀기 쉬운 문제"는 다를 것이다.

이것은 컴퓨터 과학에서 가장 유명한 미해결 문제이다! 클레이 수학 연구소의 **밀레니엄 문제** 중 하나이며, 해결하면 100만 달러의 상금이 주어진다.

| | P | NP | NP-완전 |
|---|---|---|---|
| 정렬 | ✅ | ✅ | ✗ |
| 최단 경로 | ✅ | ✅ | ✗ |
| 해밀턴 순환 | ? | ✅ | ✅ |
| 만족 가능성(SAT) | ? | ✅ | ✅ |
| 외판원 문제 | ? | ✅ | ✅ |

NP-완전 문제: NP 중에서 **가장 어려운** 문제들. 이 중 하나라도 P에 속하면 **모든** NP 문제가 P에 속하게 된다.

### 6.4 계산 모델의 전체 그림

```
풀 수 없는 문제 (정지 문제 등)
─────────────────────────
풀 수 있는 문제 (재귀적 가산)  ← 튜링 기계
  ├── NP-완전 (SAT, 외판원 등)
  ├── NP (검증은 빠름)
  │    └── P (풀기도 빠름)      ← 다항식 시간
  │         └── 정규 언어       ← DFA/NFA
  └── ...
```

---

## 7. 연습문제

### 연습 7.1: 튜링 기계 실행 추적 [괄호 채우기]

5개 한 벌: (s₀, 0, s₀, 0, R), (s₀, 1, s₁, 1, R), (s₁, 0, s₂, 0, R), (s₁, 1, s₀, 1, R), (s₁, B, s₂, B, R)

입력 테이프: `B 1 0 1 B`

```
단계 0: [s₀] B 1̲ 0 1 B     → 규칙 (s₀,1,s₁,1,R) 적용
단계 1: [s₁] B 1 0̲ 1 B     → 규칙 ⬜ 적용
단계 2: [⬜] B 1 0 1̲ B     → ⬜
단계 3: [⬜] B 1 0 1 ⬜     → ⬜
최종 상태: ⬜   정지 이유: ⬜
```

<details>
<summary>📝 답 보기</summary>

```
단계 0: [s₀] B 1̲ 0 1 B     → (s₀,1,s₁,1,R)
단계 1: [s₁] B 1 0̲ 1 B     → (s₁,0,s₂,0,R)
단계 2: [s₂] B 1 0 1̲ B     → 정지! (s₂,1)에 대한 규칙 없음
최종 상태: s₂   정지 이유: (s₂, 1)에 대한 전이가 정의되지 않음
```

</details>

---

### 연습 7.2: "두 번째 비트가 1" 인식 TM [skeleton]

정규 집합 (0∪1)1(0∪1)*을 인식하는 튜링 기계의 5개 한 벌을 완성하라.

```
(s₀, 0, s₁, 0, R)    -- 첫 비트 0 → 다음으로
(s₀, 1, ⬜, ⬜, ⬜)    -- 첫 비트 1 → 다음으로
(s₁, 0, ⬜, ⬜, ⬜)    -- 두 번째 비트 0 → ⬜ (거부)
(s₁, 1, ⬜, ⬜, ⬜)    -- 두 번째 비트 1 → ⬜ (수용!)
(s₀, B, s₂, 0, R)    -- 빈 입력 → 거부
(s₁, B, s₂, 0, R)    -- 1비트만 → 거부
```

<details>
<summary>📝 답 보기</summary>

```
(s₀, 0, s₁, 0, R)    -- 첫 비트 읽고 이동
(s₀, 1, s₁, 1, R)    -- 첫 비트 읽고 이동
(s₁, 0, s₂, 0, R)    -- 두 번째=0 → s₂(비최종) 정지
(s₁, 1, s₃, 1, R)    -- 두 번째=1 → s₃(최종!) 정지
(s₀, B, s₂, 0, R)    -- 빈 입력 → 거부
(s₁, B, s₂, 0, R)    -- 1비트만 → 거부

최종 상태: s₃ (수용)
비최종 상태: s₀, s₁, s₂ (거부)
```

</details>

---

### 연습 7.3: {0ⁿ1ⁿ} 인식 과정 추적 [괄호 채우기]

입력 "0011"에 대해 {0ⁿ1ⁿ} 인식 TM의 동작을 추적하라.

```
테이프:  0 0 1 1
1회차: 왼쪽 0 → M, 오른쪽 1 → M → 테이프: ⬜
2회차: 왼쪽 0 → M, 오른쪽 1 → M → 테이프: ⬜
검증: 모든 기호가 M? → ⬜ → 결과: ⬜
```

<details>
<summary>📝 답 보기</summary>

```
테이프:  0 0 1 1
1회차: 왼쪽 0 → M, 오른쪽 1 → M → 테이프: M 0 1 M
2회차: 왼쪽 0 → M, 오른쪽 1 → M → 테이프: M M M M
검증: 모든 기호가 M? → 예! → 결과: 수용 ✅ (n=2이므로 0²1² ∈ L)
```

</details>

---

### 연습 7.4: 튜링 기계 설계 — "모든 0을 1로 바꾸기" [sorry]

입력 비트열의 모든 0을 1로 바꾸고 정지하는 튜링 기계를 설계하라.

```lean
-- 5개 한 벌을 완성하라:
-- (s₀, 0, ⬜, ⬜, ⬜)   -- 0을 만나면?
-- (s₀, 1, ⬜, ⬜, ⬜)   -- 1을 만나면?
-- (s₀, B, ⬜, ⬜, ⬜)   -- 공백을 만나면?

def tmFlipZeros : TuringMachine Bool TSym := {
  initial := sorry
  blank := sorry
  transition := sorry
}
```

<details>
<summary>📝 답 보기</summary>

```
(s₀, 0, s₀, 1, R)   -- 0 → 1로 바꾸고 오른쪽
(s₀, 1, s₀, 1, R)   -- 1 → 그대로 오른쪽
(s₀, B, s₁, B, R)   -- 공백 → 정지 (s₁ = 최종 상태)
```

```lean
def tmFlipZeros : TuringMachine Bool TSym := {
  initial := false  -- s₀
  blank := blank
  transition := fun s x => match s, x with
    | false, zero  => some (false, one, R)
    | false, one   => some (false, one, R)
    | false, blank  => some (true, blank, R)  -- 정지
    | _, _ => none
}
```

</details>

---

### 연습 7.5: 정지 문제 이해 [괄호 채우기]

정지 문제의 증명에서, 프로그램 D가 존재할 수 없는 이유를 완성하라.

```
가정: H(P, x)는 P가 입력 x에 대해 정지하면 "정지", 아니면 "무한루프"를 반환

D(P) = if H(P,P) = "정지" then 무한루프 else 정지

D(D)를 실행하면:
경우 1: H(D,D) = "정지" → D(D)는 ⬜ → 모순: ⬜
경우 2: H(D,D) = "무한루프" → D(D)는 ⬜ → 모순: ⬜
결론: ⬜
```

<details>
<summary>📝 답 보기</summary>

```
경우 1: H(D,D) = "정지" → D(D)는 무한루프 → 모순: H가 정지한다고 했는데 실제로 안 멈춤
경우 2: H(D,D) = "무한루프" → D(D)는 정지 → 모순: H가 안 멈춘다고 했는데 실제로 멈춤
결론: 정지 판별 프로그램 H는 존재할 수 없다!
```

</details>

---

## 8. 핵심 요약

| 개념 | 정의 | 특징 |
|------|------|------|
| **튜링 기계** | (S, I, f, s₀) | 무한 테이프, 양방향, 읽기/쓰기 |
| **5개 한 벌** | (s, x, s', x', d) | 전이 규칙 |
| **정지** | f가 정의되지 않은 쌍 | 기계가 멈춤 |
| **최종 상태** | 어떤 규칙에도 안 나타나는 상태 | 수용 |
| **집합 인식** | 최종 상태에서 정지 | {0ⁿ1ⁿ} 인식 가능! |
| **함수 계산** | 입력 → 정지 후 테이프 = 출력 | 범용 계산기 |
| **처치-튜링 논제** | 계산 가능 = TM으로 가능 | 경험적 논제 |
| **정지 문제** | 정지 여부 판별 불가능 | 풀 수 없는 문제 |
| **P** | 다항식 시간에 풀 수 있음 | 정렬, 최단경로 |
| **NP** | 다항식 시간에 검증 가능 | SAT, 외판원 |
| **P = NP?** | 미해결 문제 | 밀레니엄 문제 |

---

## 9. Chapter 13 전체 요약

| 파트 | 주제 | 핵심 |
|------|------|------|
| **15-A** | 형식 언어와 문법 | 어휘, 생성, 유도, 촘스키 위계, BNF |
| **15-B** | 유한상태 기계 + DFA | 밀리 기계, DFA 설계, 상태 = 과거 요약 |
| **15-C** | NFA, 정규 표현식 | NFA↔DFA 동치, 클레이니 정리, 펌핑 보조정리 |
| **15-D** | 튜링 기계 | TM 정의, {0ⁿ1ⁿ} 인식, 정지 문제, P vs NP |

**촘스키 위계와 계산 모델의 대응:**

```
유형 3 (정규)      ↔  DFA/NFA          ↔  정규 표현식
유형 2 (문맥자유)   ↔  푸시다운 오토마톤  ↔  BNF 문법
유형 1 (문맥의존)   ↔  선형 유계 오토마톤
유형 0 (비제한)     ↔  튜링 기계          ↔  모든 계산
```

> 이것으로 Rosen 13장 "계산 모델"의 Lean 4 튜토리얼이 완성되었다. 형식 언어에서 시작하여, 유한상태 기계를 거쳐, 튜링 기계까지 — 계산의 세계를 여행한 것이다! 🎉
