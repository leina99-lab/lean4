# 이산수학 및 Lean 4 형식 검증 통합 교과과정


> 커리-하워드 대응으로 이해하는 수학과 프로그래밍의 융합

---

## 1. 서론: 수학적 엄밀성과 소프트웨어 공학의 융합

현대 컴퓨터 과학 교육과 소프트웨어 엔지니어링의 패러다임은 정적이고 비형식적인 증명 방식에서 **기계가 검증 가능한 동적이고 형식적인 검증 체계**로 급격히 이동하고 있다.

전통적인 이산수학 교육 과정은 컴퓨터 과학의 이론적 토대를 제공하는 논리, 집합론, 조합론, 그래프 이론 및 알고리즘 분석을 다룬다. 그러나 이러한 추상적인 수학적 개념과 실제 프로그래밍 실습 간의 괴리는 오랫동안 교육적 난제로 남아 있었다.

**Lean 4는 이러한 간극을 메우는 혁신적인 도구**로 등장했다. Lean 4는 단순한 정리 증명기(Theorem Prover)를 넘어, 범용 함수형 프로그래밍 언어로서의 기능을 갖추고 있다.

이는 **'명제는 타입이며, 증명은 프로그램이다(Propositions as Types, Proofs as Programs)'**라는 커리-하워드 동형성(Curry-Howard Correspondence)을 실현함으로써 수학적 증명과 프로그래밍을 하나의 통합된 활동으로 융합한다.

---

## 제1부: 논리와 증명의 기초 (Logic and Types)

### 제1장: 수학적 언어와 Lean 4의 문법

이산수학의 첫걸음은 변수, 집합, 함수와 같은 기본적인 수학적 언어를 정의하는 것이다. 전통적인 수학에서는 이러한 개념들이 자연어로 정의되지만, Lean 4에서는 **엄격한 타입 시스템**을 통해 정의된다.

#### 1.1 변수와 타입 시스템

수학적 담화에서 "실수 x에 대하여"라는 표현은 변수의 선언과 그 변수가 속한 도메인을 의미한다.

**수학적 개념:** 변수의 범위와 보편적 진술

**Lean 4 구현:**

```lean
-- 변수 선언: 모든 변수는 반드시 타입을 가져야 한다
variable (n : Nat)
variable (x : Int)
variable (s : String)

-- 타입 검사
#check n + 0    -- 결과: Nat
```

이는 n이 자연수 집합 ℕ의 원소임을 **기계적으로 보장**한다.

**프로그래머를 위한 통찰:**

수학에서의 변수 선언은 정적 타입 언어(Statically Typed Language)에서의 함수 매개변수 선언과 유사하다. Lean의 타입 시스템은 단순한 데이터 타입을 넘어, **Prop(명제)과 Type(데이터)을 명확히 구분**한다.

#### 1.2 집합의 언어 대 타입의 계층

전통적인 교재는 집합을 수학적 대상의 모임으로 정의하지만, Lean은 타입 이론(Type Theory)을 기반으로 하므로 '집합'보다 '타입'이 더 원시적인 개념이다.

**Lean 4 구현:**

Lean에서 집합 `Set α`는 실제로는 `α → Prop` 타입의 함수, 즉 **서술어(Predicate)**로 정의된다.

```lean
-- 짝수 집합 정의
def Evens : Set Nat := {n | n % 2 == 0}

-- 이는 다음과 동일
def Evens' (n : Nat) : Prop := n % 2 == 0
```

**심화 분석:**

이러한 접근은 집합을 **'특성 함수(Characteristic Function)'**로 바라보는 함수형 프로그래밍의 관점과 일치한다. 이는 프로그래머에게 수학적 집합이 정적인 컨테이너가 아니라 **동적인 논리적 조건**임을 이해시킨다.

#### 1.3 함수와 관계의 프로그래밍적 해석

함수는 입력과 출력의 매핑 관계이다. Lean 4에서 함수는 **일급 시민(First-class Citizen)**으로서, 다른 함수의 인자가 되거나 반환값이 될 수 있다.

```lean
-- def 키워드를 사용한 함수 정의
def square (x : Nat) : Nat := x * x

-- fun 키워드를 사용한 익명 함수 (Lambda Expression)
def add_one := fun x => x + 1

-- 평가
#eval square 5    -- 결과: 25
#eval add_one 10  -- 결과: 11
```

**교육적 가치:**

수학적 함수 정의 f(x) = x²가 실제 실행 가능한 코드로 변환되는 과정을 통해, 학생들은 추상적인 수학적 정의가 **구체적인 계산 절차와 동일**함을 깨닫게 된다.

---

### 제2장: 복합 명제의 논리

이 챕터는 논리 연산자와 진리표를 다루며, 이는 Lean 4에서 **'명제로서의 타입(Propositions as Types)'** 패러다임을 이해하는 핵심 관문이다.

#### 2.1 논리 연산자와 귀납적 타입

전통적인 논리학에서 ∧(그리고), ∨(또는), ¬(부정), →(함의)는 진리값을 조작하는 연산자이다. Lean 4에서 이들은 **데이터 구조체(Data Structure)**로 정의된다.

| 논리 연산자 | 수학적 의미 | Lean 4 구현 | 프로그래머 비유 |
|------------|-----------|------------|---------------|
| P ∧ Q | P 그리고 Q | `structure And P Q` | Pair/Tuple |
| P ∨ Q | P 또는 Q | `inductive Or P Q` | Enum/Union Type |
| P → Q | P이면 Q | `P -> Q` | 함수 |
| ¬P | P가 아니다 | `P -> False` | 모순 도출 함수 |
| P ↔ Q | P와 Q는 동치 | `structure Iff P Q` | 양방향 함수 쌍 |

**상세 분석:**

- **And:** `And`는 `left`와 `right`라는 두 개의 증명을 담고 있는 구조체이다. P ∧ Q를 증명하는 것은 P의 증명과 Q의 증명을 쌍으로 묶는 `And.intro` 생성자를 호출하는 것과 같다.

- **Or:** `Or`는 `inl`(왼쪽) 또는 `inr`(오른쪽) 중 하나의 생성자를 사용하여 값을 만드는 귀납적 타입이다. 이는 C++의 `std::variant`나 Rust의 `enum`과 유사하다.

#### 2.2 증명은 프로그램이다: 커리-하워드 대응

타당한 논증은 전제로부터 결론을 이끌어내는 과정이다. Lean 4에서 이는 **함수 작성과 동일**하다.

**전건 긍정식(Modus Ponens)은 함수 적용(Application)이다:**

함수 `f : P -> Q`와 값 `p : P`가 있을 때, `f p`는 `Q` 타입의 값을 반환한다.

```lean
-- 삼단논법을 함수 합성으로 구현
def syllogism (f : P -> Q) (g : Q -> R) : P -> R :=
  fun x => g (f x)

-- 전건 긍정식
example (h1 : P) (h2 : P → Q) : Q := h2 h1
```

논리적 추론이 **데이터의 흐름과 같음**을 보여준다.

#### 2.3 택틱 모드: 자동화된 추론

프로그래머에게 직접적인 증명항(Proof Term) 작성은 복잡할 수 있다. Lean 4는 이를 보조하기 위해 명령형 언어 스타일의 **'택틱(Tactic)'**을 제공한다.

**주요 택틱 및 기전:**

| 택틱 | 대응 규칙 | 설명 |
|-----|---------|------|
| `intro` | →-introduction | 전제를 컨텍스트로 이동 |
| `apply` | →-elimination | 후방 연쇄 추론 |
| `exact` | - | 목표와 일치하는 항 제공 |
| `rw` | 등식 치환 | 참조 투명성 원리 |

**교육적 전략:**

초기에는 `sorry` 택틱을 사용하여 증명의 일부를 생략할 수 있게 하여, 전체적인 논리 구조(타입 시그니처)에 집중하게 한 뒤 점진적으로 세부 증명을 채워 넣도록 지도한다.

#### 2.4 응용: 디지털 논리 회로 검증

Lean 4에서는 디지털 논리 회로를 실제 검증 가능한 코드로 구현할 수 있다.

```lean
def half_adder (a b : Bool) : Bool × Bool := (a != b, a && b)

theorem half_adder_correct (a b : Bool) :
    half_adder a b = (xor a b, and a b) := by
  cases a <;> cases b <;> rfl
```

이 과정은 하드웨어 설계 언어(HDL)의 형식 검증과 유사한 경험을 제공한다.

---

## 제2부: 수량사와 술어 논리

### 제3장: 수량사가 포함된 논리

이 챕터는 **의존 타입 이론(Dependent Type Theory)**의 진수가 드러나는 부분이다.

#### 3.1 보편 수량사 (∀)와 의존 함수 타입

**수학적 개념:** "모든 x에 대하여 P(x)이다."

**Lean 4 구현:** 이는 **의존 함수 타입(Dependent Function Type)** 또는 파이 타입(Pi Type)으로 구현된다.

```lean
-- 전칭 한정자 증명
example : ∀ n : Nat, n = n := by
  intro n    -- 임의의 자연수 n을 고정
  rfl        -- 반사성으로 증명

-- 함수 표현
def all_eq_self : ∀ n : Nat, n = n :=
  fun n => rfl
```

**프로그래머 비유:**

제네릭 함수(Generic Function)와 유사하다. 타입 매개변수 T를 받아 해당 타입에 대한 연산을 수행하는 함수처럼, 보편 수량사 증명은 임의의 값 x를 받아 P(x)라는 증명을 반환하는 함수이다.

#### 3.2 존재 수량사 (∃)와 의존 쌍 타입

**수학적 개념:** "D에 속하는 어떤 x에 대하여 P(x)이다."

**Lean 4 구현:** 이는 **의존 쌍 타입(Dependent Pair Type)** 또는 시그마 타입(Sigma Type)으로 모델링된다.

```lean
-- 존재성 증명: use로 증인 제시
example : ∃ x : Nat, x > 10 := by
  use 100        -- "여기 100이 증거입니다!"
  simp           -- 100 > 10 자동 증명

-- 존재 가정 분해
example (h : ∃ x, P x) : ... := by
  obtain ⟨x, hx⟩ := h   -- 증인 x와 성질 hx 추출
```

**주의점:**

프로그래머에게 `Exists`(Prop 타입, 증명 무관성 적용)와 `Sigma`(Type 타입, 데이터 포함)의 차이를 명확히 설명해야 한다.

- **알고리즘 내에서 값을 추출해 사용하려면:** `Sigma`
- **단순한 존재성 증명만 필요하다면:** `Exists`

#### 3.3 다중 수량사와 논리 퍼즐

**순서의 중요성:**

- `∀ x, ∃ y, ...` (모두에게 사랑하는 사람이 있다)
- `∃ y, ∀ x, ...` (모두가 사랑하는 아이돌이 있다)

**한정자의 부정:**

```lean
-- ¬∀x.P(x) ↔ ∃x.¬P(x)
-- ¬∃x.P(x) ↔ ∀x.¬P(x)

example : ¬(∀ x, P x) ↔ ∃ x, ¬P x := by
  push_neg
  rfl
```

`push_neg` 택틱을 사용하여 복잡한 논리식의 부정을 자동으로 계산한다.

---

## 핵심 개념 요약표

### 커리-하워드 대응

| 논리 | 타입 이론 | 프로그래밍 |
|-----|---------|----------|
| 명제 | 타입 | 타입 |
| 증명 | 항(Term) | 값/프로그램 |
| P → Q | P → Q | 함수 |
| P ∧ Q | P × Q | Pair |
| P ∨ Q | P + Q | Union/Enum |
| ∀x.P(x) | (x : A) → P x | 제네릭 함수 |
| ∃x.P(x) | Σ(x : A), P x | 의존 쌍 |

### Bool vs Prop

| 구분 | Bool | Prop |
|-----|------|------|
| 영역 | 계산 (컴퓨터) | 논리 (수학) |
| 값 | true / false | 증명 객체 |
| 확인 | `#eval` | 타입 검사 |
| 결정 가능성 | 항상 결정 가능 | 결정 불가능할 수 있음 |

### 주요 택틱

| 택틱 | 목표 형태 | 효과 |
|-----|---------|------|
| `intro h` | P → Q | 가정 도입 |
| `apply h` | Q (h : P → Q) | 후방 연쇄 |
| `exact h` | P (h : P) | 증명 완료 |
| `rw [h]` | a = b 포함 | 치환 |
| `constructor` | P ∧ Q | 분리 |
| `left` / `right` | P ∨ Q | 선택 |
| `use x` | ∃ x, P x | 증인 제시 |
| `obtain` | ∃ x, P x (가정) | 분해 |
| `cases` | 귀납적 타입 | 경우 분석 |
| `induction` | 귀납적 타입 | 귀납법 |

---

## 결론

Lean 4는 수학적 증명과 프로그래밍을 하나의 통합된 활동으로 융합한다. 이 교과과정을 통해:

1. **수학적 개념**이 실제 실행 가능한 **코드로 변환**됨을 경험한다
2. **논리적 추론**이 **함수 합성**과 동일함을 깨닫는다
3. **컴파일러**가 논리적 오류를 **자동으로 검출**하는 경험을 한다
4. **형식 검증**의 실용적 가치를 이해한다

> "대충 맞겠지"는 이제 통하지 않는다. 컴파일러가 여러분의 논리를 검증한다.

---

*— 끝 —*
