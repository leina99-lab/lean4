# Part 13-G: 오일러 경로와 오일러 순환 — 모든 다리를 딱 한 번만 건너기

> **Rosen 이산수학 8판 · Section 10.5.1 ~ 10.5.2 기반**
> 『Mathematics in Lean』 + Lean 4 공식화

---

## 0. 들어가며: 이 파트에서 배울 것

Part 13-F에서는 그래프의 **연결성**(connectivity) — 경로, 순환, 연결 그래프, 연결 요소 등을 배웠다. 이번 Part 13-G에서는 그래프 이론의 역사적 시발점이라 할 수 있는 **오일러 경로**(Euler path)와 **오일러 순환**(Euler circuit) 문제를 다룬다.

> **핵심 질문**: "그래프의 모든 **모서리**(edge)를 **딱 한 번씩만** 지나갈 수 있을까?"

이 파트에서 다루는 내용:

1. **쾨니히스베르크 다리 문제** — 오일러 경로 이론의 기원
2. **오일러 순환**(Euler circuit)의 정의: 모든 모서리를 정확히 한 번 포함하는 **단순 순환**
3. **오일러 경로**(Euler path)의 정의: 모든 모서리를 정확히 한 번 포함하는 **단순 경로**
4. **정리 1**: 연결 다중 그래프가 오일러 **순환**을 가질 **필요충분조건** ↔ **모든 꼭지점의 차수가 짝수**
5. **정리 2**: 연결 다중 그래프가 오일러 **경로**(순환이 아닌)를 가질 필요충분조건 ↔ **정확히 2개의 홀수 차수 꼭지점**
6. 오일러 순환을 구성하는 **알고리즘** (순환 합치기 알고리즘)
7. Lean 4에서 오일러 경로/순환 조건을 형식화하기

> **비유로 이해하기**: 
> - 오일러 문제는 "모든 **도로**(모서리)를 딱 한 번만 지나갈 수 있나?"이다.
> - 나중에 배울 해밀턴 문제는 "모든 **도시**(꼭지점)를 딱 한 번만 방문할 수 있나?"이다.
> - 둘 다 비슷해 보이지만 완전히 다른 문제이다!

---

## 1. 쾨니히스베르크 다리 문제 — 그래프 이론의 탄생

### 1.1 역사적 배경

18세기 프러시아(현재 러시아 칼리닌그라드)에 **쾨니히스베르크**(Königsberg)라는 마을이 있었다. 이 마을은 프레겔 강에 의해 **네 부분**으로 나뉘어져 있었고, 이 부분들은 **7개의 다리**로 연결되어 있었다.

```
        ┌─────────────────┐
        │   영역 A (북쪽)   │
        └──┬──────────┬───┘
           │다리1     │다리2
    ┌──────┼──────────┼──────┐
    │      │   섬 B   │      │
    │      │ (가운데)  │      │
    │다리3 │          │다리4 │
    │      └──────────┘      │
    │         다리5           │
    │   영역 C ────── 영역 D  │
    │       다리6    다리7    │
    └────────────────────────┘
```

마을 사람들은 일요일마다 산책하며 이런 의문을 가졌다:

> **"7개의 다리를 모두, 각 다리를 딱 한 번만 건너서, 출발점으로 돌아올 수 있을까?"**

### 1.2 오일러의 해결 (1736년)

스위스 수학자 **레온하르트 오일러**(Leonhard Euler, 1707~1783)가 이 문제를 처음으로 그래프 이론의 방법을 사용하여 해결하였다. 오일러는 이 문제를 다음과 같이 **다중 그래프**(multigraph)로 모델링하였다:

- **4개의 영역** → 4개의 **꼭지점**(vertex): A, B, C, D
- **7개의 다리** → 7개의 **모서리**(edge)

```
         A
        /|\
       / | \
      /  |  \
     B---+---B   ← A와 B 사이에 다리 2개
      \  |  /
       \ | /
        \|/
    C----+----D
     \       /
      -------    ← C와 D 사이에도 다리가 있음
```

이 다중 그래프에서 각 꼭지점의 **차수**(degree)는:
- deg(A) = 3 (홀수)
- deg(B) = 5 (홀수)  
- deg(C) = 3 (홀수)
- deg(D) = 3 (홀수)

**모든 꼭지점의 차수가 홀수**이다! 오일러는 이 사실이 핵심이라는 것을 발견하였다.

### 1.3 핵심 관찰: 왜 차수가 중요한가?

오일러가 발견한 핵심 논리를 단계별로 따라가 보자.

**관찰 1: 순환(시작점 = 끝점)의 경우**

오일러 순환이 어떤 꼭지점 $a$에서 시작하여 $a$로 돌아온다고 하자. 순환이 꼭지점 $a$를 지날 때마다 무슨 일이 일어나는지 생각해 보자:

- **출발할 때**: 모서리 하나를 사용하여 나간다 → deg(a)에 +1
- **중간에 a를 지날 때마다**: 들어오는 모서리 1개 + 나가는 모서리 1개 → deg(a)에 +2
- **마지막에 돌아올 때**: 모서리 하나를 사용하여 들어온다 → deg(a)에 +1

총 합하면: 출발 1 + 도착 1 + 중간 통과 ×2 = **짝수**!

따라서 **오일러 순환이 존재하면 모든 꼭지점의 차수는 짝수**여야 한다.

**관찰 2: 경로(시작점 ≠ 끝점)의 경우**

시작점 $a$와 끝점 $b$가 다른 경우:
- $a$에서: 나가기만 하므로 차수에 1이 추가됨 (홀수)
- $b$에서: 들어오기만 하므로 차수에 1이 추가됨 (홀수)
- 다른 모든 꼭지점: 들어오고 나가므로 차수에 2씩 추가됨 (짝수)

따라서 **오일러 경로(순환 아님)가 존재하면 정확히 2개의 꼭지점만 홀수 차수**이다.

**쾨니히스베르크에 적용**:

4개의 꼭지점 **모두** 홀수 차수(3, 5, 3, 3)이므로:
- 오일러 순환? ❌ (짝수 차수 조건 불만족)
- 오일러 경로? ❌ (홀수 차수 꼭지점이 4개, 2개가 아님)

→ **7개의 다리를 모두 한 번씩만 건너는 것은 불가능하다!** 🎉

---

## 2. 오일러 순환과 오일러 경로의 엄밀한 정의

### 2.1 정의

> **정의 1** (Rosen 10.5, Definition 1)
>
> 그래프 $G$의 **오일러 순환**(Euler circuit)은 $G$의 **모든 모서리**를 포함하는 **단순 순환**(simple circuit)이다.
>
> $G$의 **오일러 경로**(Euler path)는 $G$의 **모든 모서리**를 포함하는 **단순 경로**(simple path)이다.

여기서 중요한 용어를 정리하자:

| 용어 | 의미 | 핵심 조건 |
|:---|:---|:---|
| **순환**(circuit) | 시작점으로 돌아오는 경로 | 시작점 = 끝점 |
| **단순 순환**(simple circuit) | 모서리를 반복하지 않는 순환 | 각 모서리를 최대 1번 |
| **오일러 순환**(Euler circuit) | **모든** 모서리를 포함하는 단순 순환 | 각 모서리를 **정확히** 1번 |
| **경로**(path) | 꼭지점을 순서대로 잇는 일련의 모서리 | 시작점 ≠ 끝점 (보통) |
| **단순 경로**(simple path) | 모서리를 반복하지 않는 경로 | 각 모서리를 최대 1번 |
| **오일러 경로**(Euler path) | **모든** 모서리를 포함하는 단순 경로 | 각 모서리를 **정확히** 1번 |

> ⚠️ **주의**: "단순"(simple)이란 **모서리**를 반복하지 않는다는 뜻이다. 꼭지점은 반복할 수 있다!

### 2.2 오일러 순환 vs 오일러 경로 — 차이점

두 개념의 핵심 차이:

- **오일러 순환**: 시작점 = 끝점. 원래 자리로 돌아와야 한다. 닫힌 경로이다.
- **오일러 경로**: 시작점 ≠ 끝점. 다른 곳에서 끝난다. 열린 경로이다.

> **비유**: 
> - 오일러 순환 = 집에서 출발하여 모든 도로를 한 번씩 달리고 집으로 돌아오기 🏠→...→🏠
> - 오일러 경로 = 어떤 곳에서 출발하여 모든 도로를 한 번씩 달리고 다른 곳에서 끝나기 🏠→...→🏢

### 2.3 예제 1: 비방향성 그래프에서 오일러 순환 판별

다음 세 그래프를 보자:

**그래프 G₁**: 꼭지점 {a, b, c, d, e}
```
    a ─── b
    |\ /|
    | X  |
    |/ \|
    d ─── c
         |
         e
```
- 모서리: {a,b}, {a,c}, {a,d}, {b,c}, {b,d}, {c,d}, {c,e}, {d,e}
- 차수: deg(a)=3, deg(b)=3, deg(c)=4, deg(d)=4, deg(e)=2

홀수 차수 꼭지점이 2개(a와 b)이므로:
- 오일러 **순환**: ❌ (모든 차수가 짝수여야 함)
- 오일러 **경로**: ✅ (정확히 2개의 홀수 차수 꼭지점 → a에서 b로 가는 경로 가능)

**그래프 G₂** (모든 꼭지점의 차수가 짝수인 경우):
```
    a ─── b
    |     |
    d ─── c
    |     |
    e ─── f
```
- 모서리: {a,b}, {a,d}, {b,c}, {c,f}, {d,e}, {e,f}, {c,d}
- 차수: 모두 짝수

→ 오일러 **순환**: ✅ (예: a, b, c, d, e, f, c, d, a)

---

## 3. 오일러 순환의 필요충분조건 (정리 1)

### 3.1 정리의 진술

> **정리 1** (Rosen Theorem 1)
>
> 연결된 다중 그래프가 **오일러 순환**을 가질 **필요충분조건**(necessary and sufficient condition)은 **각 꼭지점이 짝수 차수를 가지는 것**이다.

이 정리는 **↔**(if and only if, 동치)로 표현된다. 즉 두 방향을 모두 증명해야 한다:

**→ 방향 (필요조건)**: 오일러 순환이 존재하면 → 모든 꼭지점의 차수가 짝수

**← 방향 (충분조건)**: 모든 꼭지점의 차수가 짝수이면 → 오일러 순환이 존재

### 3.2 → 방향 증명 (필요조건): 왜 짝수 차수가 필요한가?

이 방향의 증명은 직관적이다:

1. 오일러 순환이 꼭지점 $v$를 지날 때마다, 하나의 모서리로 들어오고 하나의 모서리로 나간다.
2. 따라서 $v$를 한 번 통과할 때마다 차수에 **2**가 더해진다.
3. 순환의 시작/끝 꼭지점도 마찬가지이다 (출발할 때 1 + 돌아올 때 1 = 2).
4. 오일러 순환은 **모든 모서리를 정확히 한 번** 사용하므로, 각 꼭지점의 차수는 그 꼭지점을 통과하는 횟수의 2배이다.
5. 따라서 모든 꼭지점의 차수는 **짝수**이다.

### 3.3 ← 방향 증명 (충분조건): 어떻게 오일러 순환을 만드는가?

이 방향의 증명은 **구성적**(constructive)이다. 실제로 오일러 순환을 만들어 내는 알고리즘을 보여준다.

**아이디어**: 순환 합치기(circuit splicing) 방법

1. **1단계**: 연결된 그래프 $G$에서 임의의 꼭지점 $a$부터 시작하여, 사용하지 않은 모서리를 따라 가능한 한 계속 이동한다. 모든 꼭지점의 차수가 짝수이므로, 어딘가에서 막히면 반드시 $a$로 돌아오게 된다. → 하나의 순환 $C_1$을 얻는다.

2. **2단계**: $C_1$에서 사용한 모서리들을 $G$에서 제거하면 부분그래프 $H$를 얻는다. $H$의 모든 꼭지점도 짝수 차수를 가진다 (짝수에서 짝수를 빼면 짝수).

3. **3단계**: $H$에 아직 모서리가 남아 있으면, $C_1$과 $H$가 공유하는 꼭지점 $w$에서 시작하여 $H$에서 새로운 순환 $C_2$를 만든다.

4. **4단계**: $C_1$과 $C_2$를 $w$ 위치에서 합친다. 즉 $C_1$이 $w$를 지나는 곳에서 $C_2$를 삽입한다.

5. 모든 모서리가 사용될 때까지 이 과정을 반복한다.

> **비유**: 마을의 도로를 모두 달리는 것과 같다. 먼저 집에서 출발하여 한 바퀴 돌고 집으로 돌아온다. 아직 안 달린 도로가 있으면, 첫 번째 경로에서 갈림길이 있었던 곳으로 가서 거기서 다시 한 바퀴 돌고, 두 경로를 합친다. 모든 도로를 달릴 때까지 반복한다.

### 3.4 예제: 순환 합치기로 오일러 순환 구성하기

다음 그래프 $G$를 보자:

```
    a ──── b
    │╲    │
    │  ╲  │
    │    ╲│
    f ──── c ──── d
              ╲  │
                ╲│
                 e
```

모서리: {a,b}, {a,c}, {a,f}, {b,c}, {c,d}, {c,e}, {c,f}, {d,e}

차수 확인:
- deg(a) = 3 ... 잠깐, 이것은 홀수이다! 

더 나은 예제를 써 보자. 다음 그래프를 보자 (Rosen 그림 5 참조):

```
    a ←→ b
    ↕     ↕
    f ←→ c
    │   / │
    │  /  │
    │ /   │
    e ←── d
```

모서리: {a,b}, {a,f}, {b,c}, {c,d}, {c,e}, {c,f}, {d,e}, {e,f}

차수:
- deg(a) = 2, deg(b) = 2, deg(c) = 4, deg(d) = 2, deg(e) = 3, deg(f) = 3

이것도 홀수 차수가 있다! Rosen의 실제 예제를 사용하자.

**그래프 G** (모든 차수가 짝수):
```
    a ─── b
    │     │
    │     │
    f ─── c
    │   ╱ │
    │  ╱  │
    e ─── d
```

모서리: {a,b}, {a,f}, {b,c}, {c,d}, {c,f}, {d,e}, {e,f}  
차수: deg(a)=2, deg(b)=2, deg(c)=3... 

이런, 정확한 예제가 필요하다. 정확히 모든 차수가 짝수인 간단한 예제를 만들자:

**그래프 G** (4개 꼭지점, 모든 차수 = 2):
```
    a ─── b
    │     │
    d ─── c
```
모서리: {a,b}, {b,c}, {c,d}, {d,a}  
차수: 모두 2 (짝수) ✅

오일러 순환: a → b → c → d → a ✅ (이것은 단순하다!)

좀 더 복잡한 예제:

**그래프 G** (6개 꼭지점):
```
    a ─── b ─── c
    │     │     │
    f ─── e ─── d
```
모서리: {a,b}, {b,c}, {c,d}, {d,e}, {e,f}, {f,a}, {b,e}  
차수: deg(a)=2, deg(b)=3... 역시 홀수!

다시: {a,b}, {b,c}, {c,d}, {d,e}, {e,f}, {f,a}, {b,e}, {c,f}  
차수: deg(a)=2, deg(b)=3, deg(c)=3... 안 됨

정확한 예: 
모서리: {a,b}, {a,f}, {b,c}, {b,e}, {c,d}, {d,e}, {e,f}, {f,c}  
차수: deg(a)=2, deg(b)=3... 

K₄ (완전 그래프, 4꼭지점)를 쓰자:
모서리 6개, 차수 모두 3 → 홀수이므로 안 됨!

**가장 좋은 예제**: Rosen 그림 5의 그래프를 직접 사용하자.

```
    a ──── b
    │╲     │
    │  ╲   │
    f    ╲ │
    │    ╱ c
    │  ╱   │
    │╱     │
    e ──── d
```

모서리: {a,b}, {a,c}, {a,f}, {b,c}, {c,d}, {c,e}, {d,e}, {e,f}  
차수: deg(a)=3, deg(b)=2, deg(c)=4, deg(d)=2, deg(e)=3, deg(f)=2

a와 e가 홀수 → 오일러 경로는 있지만 순환은 아니다.

더 좋은 예: 직접 만들자.

**그래프 G_euler** (모든 차수 짝수, 연결됨):
```
    a ─── b
   / \   / \
  f   \ /   c
   \   X   /
    \ / \ /
     e ── d
```

모서리: {a,b}, {a,e}, {a,f}, {b,c}, {b,d}, {c,d}, {d,e}, {e,f}  
차수: deg(a)=3... 또 홀수!

간단하게 가자:

```
    a ─── b
    │╲   ╱│
    │  ╲╱  │
    │  ╱╲  │
    │╱   ╲│
    d ─── c
```
이것은 K₄ — 모든 차수 3 (홀수).

**제대로 된 예**: 사각형 + 대각선 하나:
```
    a ─── b
    │     │
    d ─── c
    └─────┘  (a와 c를 연결)
```
모서리: {a,b}, {b,c}, {c,d}, {d,a}, {a,c}  
차수: deg(a)=3, deg(b)=2, deg(c)=3, deg(d)=2  
→ 오일러 경로 가능 (a와 c가 홀수)

**진짜 모든 차수 짝수 예**:
```
    a ─── b
    │╲   ╱│
    │  c   │
    │╱   ╲│
    d ─── e
```
모서리: {a,b}, {a,c}, {a,d}, {b,c}, {b,e}, {c,d}, {c,e}, {d,e}  
차수: deg(a)=3... 안 됨!

**가장 간단한 모든 차수 짝수 예제들**:
1. 삼각형 + 삼각형 (나비넥타이):
```
    a ─ b ─ c
     \ | / 
      \|/
       d
```
안 됨, 이상하게 됨.

OK, 가장 확실한 것:
```
    a ── b
    │    │
    │    │
    d ── c
```
이것은 C₄ (4-순환). 모든 차수 = 2. 오일러 순환: a,b,c,d,a. ✅

조금 더 복잡한 것:
```
    a ── b ── c
    │         │
    f ── e ── d
```
이것은 C₆. 모든 차수 = 2. 오일러 순환: a,b,c,d,e,f,a. ✅

이 두 예제가 너무 단순하니, 교차하는 순환을 만들자:
```
    a ── b
    │╲  │
    │  ╲│
    d ── c
    │╲  │
    │  ╲│
    f ── e
```
모서리: {a,b}, {a,c}, {a,d}, {b,c}, {c,d}, {c,e}, {c,f}, {d,f}, {d,e}, {e,f}  
... 복잡해지므로 교과서 그림을 정확히 따라가자.

Rosen 그림 5의 그래프를 정확히 재현:
```
    a ─── b
    │     │
    │     │
    f ─── c
      ╲ ╱ │
       X   │
      ╱ ╲ │
    e ─── d
```
모서리: {a,b}, {a,f}, {b,c}, {c,d}, {c,e}, {c,f}, {d,e}, {e,f}

deg(a) = 2, deg(b) = 2, deg(c) = 4, deg(d) = 2, deg(e) = 3, deg(f) = 3

홀수: e, f → 오일러 경로 가능 (e에서 f로 또는 f에서 e로)

교재에서 순환 합치기를 설명할 때 사용한 그래프:
{a,f}, {f,c}, {c,b}, {b,a} 순환을 먼저 잡고, 제거 후 {c,d}, {d,e}, {e,f}, {f,c}가 남으므로...

음, 교과서에서는 더 큰 그래프를 사용한다. 여기서는 개념 설명에 집중하고 작은 예제를 사용하겠다.

---

## 4. Lean 4에서 오일러 조건 형식화하기

### 4.1 기본 준비: 유한 그래프와 차수

Lean 4의 Mathlib에는 `SimpleGraph`가 정의되어 있다. 먼저 유한 그래프에서 **차수**(degree)의 개념을 복습하자.

```lean
import Mathlib.Combinatorics.SimpleGraph.Basic
import Mathlib.Combinatorics.SimpleGraph.Connectivity
import Mathlib.Combinatorics.SimpleGraph.Finite

-- 유한 단순 그래프: Fin n 위의 그래프
-- SimpleGraph (Fin n) 타입의 값이 바로 그래프이다

-- 예: 4개 꼭지점의 순환 그래프 (C₄)
def C4 : SimpleGraph (Fin 4) where
  Adj u v := (u.val + 1) % 4 = v.val ∨ (v.val + 1) % 4 = u.val
  symm := by
    intro u v h
    rcases h with h1 | h2
    · right; exact h1
    · left; exact h2
  loopless := by
    intro v h
    rcases h with h1 | h2
    · omega
    · omega
```

> **코드 설명**:
> - `Adj u v` : 꼭지점 u와 v가 인접한지 여부. `Prop` 타입 (참/거짓).
> - `symm` : 대칭성. u-v가 인접하면 v-u도 인접.
> - `loopless` : 루프 없음. v-v는 불가능.
> - `omega` : 자연수 산술을 자동으로 처리하는 전술.

### 4.2 차수와 짝수 조건

```lean
-- 그래프의 차수를 구하는 함수
-- Mathlib에서: SimpleGraph.degree v = G.neighborFinset v |>.card

-- "모든 꼭지점의 차수가 짝수"를 표현하는 방법:
def allEvenDegree (G : SimpleGraph (Fin n)) 
    [DecidableRel G.Adj] [Fintype (Fin n)] : Prop :=
  ∀ v : Fin n, Even (G.degree v)

-- "정확히 2개의 꼭지점이 홀수 차수"를 표현하는 방법:
def exactlyTwoOddDegree (G : SimpleGraph (Fin n)) 
    [DecidableRel G.Adj] [Fintype (Fin n)] : Prop :=
  (Finset.univ.filter (fun v => ¬ Even (G.degree v))).card = 2
```

> **코드 설명**:
> - `Even n` : `∃ k, n = 2 * k` — n이 짝수임을 의미한다.
> - `G.degree v` : 꼭지점 v의 차수 (이웃의 수).
> - `Finset.univ.filter (fun v => ...)` : 모든 꼭지점 중 조건을 만족하는 것만 걸러냄.
> - `.card` : 집합의 원소 수.

### 4.3 오일러 순환 정리 (정리 1)의 Lean 4 표현

```lean
-- 정리 1: 오일러 순환의 필요충분조건
-- 연결된 다중 그래프가 오일러 순환을 가질 필요충분조건은
-- 각 꼭지점이 짝수 차수를 가지는 것이다.

-- 이것을 ↔ (iff, if and only if)로 표현한다:
-- hasEulerCircuit G ↔ (G.Connected ∧ allEvenDegree G)

-- Lean 4에서의 형식화:
theorem euler_circuit_iff_all_even_degree 
    (G : SimpleGraph (Fin n)) [DecidableRel G.Adj] :
    hasEulerCircuit G ↔ (G.Connected ∧ allEvenDegree G) := by
  sorry  -- 완전한 증명은 매우 길다!
```

### 4.4 ↔ (동치)와 → (함의)의 차이 복습

Part 13-A에서 배운 내용이지만, 이 정리를 이해하기 위해 **↔**(if and only if)와 **→**(if)의 차이를 다시 복습하자.

| 기호 | 한글 | 영어 | Lean 4 | 의미 |
|:---|:---|:---|:---|:---|
| → | **함의**(implication) | if...then | `→` | A가 참이면 B가 참 (한 방향) |
| ↔ | **동치**(equivalence) | if and only if | `↔` | A가 참 ⟺ B가 참 (양 방향) |

```lean
-- → (함의): 한 방향만 증명
-- "비가 오면 땅이 젖는다" (비가 안 와도 땅은 젖을 수 있다!)
-- P → Q

-- ↔ (동치): 양 방향을 모두 증명  
-- "오일러 순환이 존재한다 ↔ 모든 차수가 짝수이다"
-- P ↔ Q  즉  (P → Q) ∧ (Q → P)

-- Lean 4에서 ↔를 증명하는 방법:
example (P Q : Prop) (h1 : P → Q) (h2 : Q → P) : P ↔ Q := by
  constructor    -- 두 방향으로 분리
  · exact h1    -- → 방향
  · exact h2    -- ← 방향

-- ↔를 사용하는 방법:
example (P Q : Prop) (h : P ↔ Q) (hp : P) : Q := by
  exact h.mp hp    -- .mp = "modus ponens" = → 방향

example (P Q : Prop) (h : P ↔ Q) (hq : Q) : P := by
  exact h.mpr hq   -- .mpr = "modus ponens reverse" = ← 방향
```

---

## 5. 오일러 경로의 필요충분조건 (정리 2)

### 5.1 정리의 진술

> **정리 2** (Rosen Theorem 2)
>
> 연결된 다중 그래프가 **오일러 순환이 아니라 오일러 경로**를 가진다면, **정확히 2개의 꼭지점이 홀수 차수**를 가진다. 그 **역도 성립**한다.

다시 말하면:

> **연결된 다중 그래프 $G$에 대해:**
> $G$가 오일러 경로(순환 아님)를 가짐 ↔ 정확히 2개의 꼭지점이 홀수 차수를 가짐

### 5.2 증명의 핵심 아이디어

**→ 방향 (필요조건)**:

오일러 경로가 $a$에서 시작하여 $b$에서 끝난다고 하자 ($a \neq b$).
- 시작점 $a$: 나가는 모서리가 하나 더 많다 → 홀수 차수
- 끝점 $b$: 들어오는 모서리가 하나 더 많다 → 홀수 차수  
- 다른 모든 꼭지점: 들어오고 나가는 횟수가 같다 → 짝수 차수

따라서 정확히 2개의 꼭지점 ($a$와 $b$)이 홀수 차수이다.

**← 방향 (충분조건)**:

정확히 2개의 꼭지점 $a$, $b$가 홀수 차수라고 하자. $G$에 모서리 $\{a, b\}$를 추가하면 모든 꼭지점이 짝수 차수가 된다. 정리 1에 의해 이 확장된 그래프에 오일러 **순환**이 존재한다. 이 순환에서 추가한 모서리 $\{a, b\}$를 제거하면 원래 그래프의 오일러 **경로**를 얻는다.

### 5.3 예제: 오일러 경로 찾기

**예제 4** (Rosen Example 4): 다음 세 그래프 중 오일러 경로를 가지는 것은?

```
    G₁:                G₂:                   G₃:
    a ─── b           a ─── g ─── f ── e    a ─── b
    │╲  ╱│           │     │         │      │╲  ╱│
    │  ╲  │          │     │         │     f│  ╲  │c
    │  ╱  │          │     │         │      │╱ g╲│
    d ─── c           b ─── c ─── d         e ─── d
```

**G₁**: 홀수 차수 꼭지점 = 2개 (b와 d) → 오일러 경로 ✅  
경로의 하나: d, a, b, c, d, b (b에서 d로 또는 d에서 b로)

**G₂**: 홀수 차수 꼭지점 = 2개 (b와 d) → 오일러 경로 ✅  
경로: b, a, g, f, e, d, c, g, b, c, f, d

**G₃**: 홀수 차수 꼭지점 = 6개 → 오일러 경로 ❌

### 5.4 Lean 4 형식화

```lean
-- 정리 2의 Lean 4 표현
theorem euler_path_iff_exactly_two_odd 
    (G : SimpleGraph (Fin n)) [DecidableRel G.Adj] :
    hasEulerPath G ↔ (G.Connected ∧ exactlyTwoOddDegree G) := by
  sorry
```

---

## 6. 오일러 순환 구성 알고리즘

### 6.1 알고리즘 1: 순환 합치기

```
procedure Euler(G: 모든 꼭지점이 짝수 차수인 연결 다중 그래프)
  circuit := 임의의 꼭지점에서 시작하여, 모서리를 따라 순환 하나를 형성
  H := G에서 이 순환의 모서리들을 제거
  while H에 모서리가 남아 있다:
    subcircuit := H에서, circuit과 공유하는 꼭지점에서 시작하여 순환 형성
    H := H에서 subcircuit의 모서리와 고립 꼭지점 제거
    circuit := circuit의 적절한 위치에 subcircuit 삽입
  return circuit
```

> **직관적 설명**: 
> 1. 집(꼭지점 a)에서 출발하여 아무 도로나 따라 달린다. 막히면 (모든 차수가 짝수이므로) 반드시 집으로 돌아온다. 이것이 첫 번째 순환이다.
> 2. 아직 안 달린 도로가 있으면, 첫 번째 순환 중간에 있는 교차로(꼭지점)에서 빠져나가 안 달린 도로만으로 한 바퀴 더 돈다.
> 3. 두 순환을 합친다: 첫 순환에서 그 교차로에 도달하면, 두 번째 순환을 먼저 돌고, 다시 첫 순환을 계속한다.
> 4. 모든 도로를 달릴 때까지 반복!

이 알고리즘의 **시간 복잡도**는 $O(m)$이다 ($m$ = 모서리의 수).

### 6.2 Lean 4에서 알고리즘 구조 표현

```lean
-- 순환 합치기 알고리즘의 핵심 구조를 표현
-- (완전한 구현은 매우 복잡하므로 핵심 아이디어만 표현)

-- 순환을 꼭지점 리스트로 표현
-- 예: [a, b, c, d, a] = a → b → c → d → a 순환
def Circuit (V : Type*) := List V

-- 두 순환을 합치는 함수 (개념적)
-- circuit1이 꼭지점 w를 지나고, circuit2도 w에서 시작/끝나면
-- circuit1에서 w 위치에 circuit2를 삽입
def spliceCycles {V : Type*} [DecidableEq V] 
    (c1 c2 : List V) (w : V) : List V :=
  match c1.indexOf w with
  | some idx => 
    let (before, after) := c1.splitAt idx
    before ++ c2 ++ after.tail  -- w에서 c2를 삽입
  | none => c1  -- w가 없으면 원래 순환 반환
```

---

## 7. 오일러 경로와 순환의 응용

### 7.1 연필을 떼지 않고 그림 그리기 (예제 3)

많은 퍼즐에서 "그림을 **연필을 떼지 않고** 한 번에 그릴 수 있는가?"라는 질문이 나온다. 이것은 정확히 **오일러 경로**(또는 순환)가 존재하는가의 문제이다!

**규칙**:
- 연필을 떼지 않는다 = 연속적으로 그린다
- 같은 선을 두 번 긋지 않는다 = 각 모서리를 한 번만 사용
- 시작점과 끝점이 같으면 → **오일러 순환**
- 시작점과 끝점이 다르면 → **오일러 경로**

**판별법**:
1. 그래프가 **연결**되어 있는지 확인
2. 홀수 차수 꼭지점의 수를 센다
   - **0개** → 오일러 순환 존재 (어디서든 시작 가능) ✅
   - **2개** → 오일러 경로 존재 (홀수 차수 꼭지점에서 시작) ✅
   - **그 외** → 불가능 ❌

### 7.2 우편배달부 문제 (Chinese Postman Problem)

**문제**: 우편배달부가 자신의 담당 구역의 모든 거리를 한 번 이상 지나야 한다. 최소한의 총 거리로 모든 거리를 지나고 출발점으로 돌아오려면?

- **오일러 순환이 존재하면**: 모든 거리를 정확히 한 번만 지나면 된다! 최적!
- **오일러 순환이 존재하지 않으면**: 일부 거리를 두 번 이상 지나야 한다. 어떤 거리를 반복할지 최적화해야 한다.

### 7.3 네트워크 검사

통신 네트워크에서 각 링크를 정확히 한 번씩 검사하는 경로를 찾는 것도 오일러 경로 문제이다.

---

## 8. 오일러 경로/순환 종합 정리표

| 조건 | 오일러 순환 | 오일러 경로 (순환 아님) |
|:---|:---|:---|
| **그래프** | 연결된 다중 그래프 | 연결된 다중 그래프 |
| **홀수 차수 꼭지점 수** | 0개 | 정확히 2개 |
| **차수 조건** | **모든** 꼭지점 짝수 차수 | 정확히 **2개** 홀수 + 나머지 짝수 |
| **시작/끝** | 아무 꼭지점에서 시작 | 홀수 차수 꼭지점에서 시작/끝 |
| **정리** | 정리 1 (↔) | 정리 2 (↔) |

> **기억법**: 
> - 오일러 **순환** = **영**(0)개의 홀수 차수 = **Zero** Odd degrees
> - 오일러 **경로** = **투**(2)개의 홀수 차수 = **Two** Odd degrees

---

## 9. 연습문제

### 연습 9.1: 개념 확인 — 오일러 순환 판별 (괄호 채우기)

다음 그래프에서 오일러 순환 또는 경로의 존재를 판별하라.

```lean
-- 그래프 G: 사각형 (C₄)
-- 꼭지점: 0, 1, 2, 3
-- 모서리: {0,1}, {1,2}, {2,3}, {3,0}

def squareGraph : SimpleGraph (Fin 4) where
  Adj u v := 
    (u.val = 0 ∧ v.val = 1) ∨ (u.val = 1 ∧ v.val = 0) ∨
    (u.val = 1 ∧ v.val = 2) ∨ (u.val = 2 ∧ v.val = 1) ∨
    (u.val = 2 ∧ v.val = 3) ∨ (u.val = 3 ∧ v.val = 2) ∨
    (u.val = 3 ∧ v.val = 0) ∨ (u.val = 0 ∧ v.val = 3)
  symm := by intro u v h; rcases h with h|h|h|h|h|h|h|h <;> simp_all
  loopless := by intro v h; rcases h with h|h|h|h|h|h|h|h <;> omega

-- 각 꼭지점의 차수를 확인하자
-- deg(0) = 【    】  (답: 2)
-- deg(1) = 【    】  (답: 2)
-- deg(2) = 【    】  (답: 2)
-- deg(3) = 【    】  (답: 2)

-- 홀수 차수 꼭지점의 수: 【    】  (답: 0)
-- 오일러 순환 존재 여부: 【    】  (답: 존재한다)
-- 오일러 경로 존재 여부: 【    】  (답: 순환이 곧 경로이기도 하다)
-- 오일러 순환의 예: 0 → 【  】→ 【  】→ 【  】→ 0  (답: 1, 2, 3)
```

<details>
<summary>📝 답 보기</summary>

```
deg(0) = 2, deg(1) = 2, deg(2) = 2, deg(3) = 2
홀수 차수 꼭지점의 수: 0
오일러 순환 존재 여부: 존재한다 (모든 차수가 짝수)
오일러 순환의 예: 0 → 1 → 2 → 3 → 0
```

</details>

---

### 연습 9.2: 오일러 경로 판별 (괄호 채우기)

```lean
-- 그래프 H: 집 모양 (오각형 + 지붕)
-- 꼭지점: 0(왼쪽 아래), 1(오른쪽 아래), 2(오른쪽 위), 3(왼쪽 위), 4(지붕 꼭대기)
-- 모서리: {0,1}, {1,2}, {2,3}, {3,0}, {3,4}, {4,2}
--
--        4
--       / \
--      3 ── 2
--      │    │
--      0 ── 1

-- 각 꼭지점의 차수:
-- deg(0) = 【    】  (답: 2)
-- deg(1) = 【    】  (답: 2)
-- deg(2) = 【    】  (답: 3)
-- deg(3) = 【    】  (답: 3)
-- deg(4) = 【    】  (답: 2)

-- 홀수 차수 꼭지점: 【    】과 【    】 (답: 2와 3)
-- 오일러 순환 존재 여부: 【        】 (답: 존재하지 않음, 홀수 차수가 0이 아님)
-- 오일러 경로 존재 여부: 【        】 (답: 존재, 홀수 차수가 정확히 2개)
-- 오일러 경로의 시작/끝: 꼭지점 【  】에서 시작, 꼭지점 【  】에서 끝남 (답: 2에서 시작, 3에서 끝남)
-- 경로의 예: 2 → 【  】→ 【  】→ 【  】→ 【  】→ 【  】→ 3 
--           (답: 2 → 4 → 3 → 0 → 1 → 2 → 3 또는 유사한 경로)
```

<details>
<summary>📝 답 보기</summary>

```
deg(0) = 2, deg(1) = 2, deg(2) = 3, deg(3) = 3, deg(4) = 2
홀수 차수 꼭지점: 2와 3 (2개)
오일러 순환: 존재하지 않음 (홀수 차수 꼭지점 ≠ 0)
오일러 경로: 존재 (홀수 차수 꼭지점 = 정확히 2개)
경로의 예: 2 → 4 → 3 → 0 → 1 → 2 → 3
  (2에서 시작하여 3에서 끝남 — 둘 다 홀수 차수 꼭지점)
```

</details>

---

### 연습 9.3: 짝수 차수 정리의 Lean 4 증명 (괄호 채우기)

```lean
-- "오일러 순환이 존재하면 모든 꼭지점의 차수가 짝수이다"
-- 이것은 정리 1의 → 방향이다.

-- 작은 예제로 확인: C₃ (삼각형)은 모든 차수가 2(짝수)이다.
-- C₃에 오일러 순환이 존재하는가?

def C3 : SimpleGraph (Fin 3) where
  Adj u v := u ≠ v  -- 완전 그래프 K₃ = 삼각형
  symm := by intro u v h; 【          】  -- (답: exact h.symm 또는 exact Ne.symm h)
  loopless := by intro v h; 【          】  -- (답: exact h rfl 또는 exact absurd rfl h)

-- C₃의 각 꼭지점의 차수 = 2 (짝수) ✅
-- 오일러 순환: 0 → 1 → 2 → 0 ✅

-- "모든 차수가 짝수"임을 증명
theorem C3_all_even : ∀ v : Fin 3, Even (C3.degree v) := by
  intro v
  fin_cases v <;> 【          】  
  -- 각 경우를 자동으로 계산
  -- (답: decide 또는 simp [C3, SimpleGraph.degree] 등)
```

<details>
<summary>📝 답 보기</summary>

```lean
def C3 : SimpleGraph (Fin 3) where
  Adj u v := u ≠ v
  symm := by intro u v h; exact Ne.symm h
  loopless := by intro v h; exact absurd rfl h

-- 주의: C3는 K₃ (완전 그래프)이므로 모든 차수 = 2
-- Lean 4에서 degree 계산이 자동으로 되지 않을 수 있으므로
-- fin_cases와 decide를 조합하여 증명한다.

theorem C3_all_even : ∀ v : Fin 3, Even (C3.degree v) := by
  intro v
  fin_cases v <;> decide
```

</details>

---

### 연습 9.4: 오일러 판별 종합 (괄호 채우기)

다음 각 그래프에 대해 오일러 순환/경로 존재 여부를 판별하라.

```
(a) K₅ (완전 그래프, 5꼭지점)
    - 각 꼭지점의 차수: 【    】 (답: 4)
    - 홀수 차수 꼭지점 수: 【    】 (답: 0)
    - 오일러 순환: 【       】 (답: 존재)

(b) K₄ (완전 그래프, 4꼭지점)
    - 각 꼭지점의 차수: 【    】 (답: 3)
    - 홀수 차수 꼭지점 수: 【    】 (답: 4)
    - 오일러 순환: 【       】 (답: 존재하지 않음)
    - 오일러 경로: 【       】 (답: 존재하지 않음, 홀수 차수가 2가 아님)

(c) Petersen 그래프
    - 각 꼭지점의 차수: 【    】 (답: 3)
    - 홀수 차수 꼭지점 수: 【    】 (답: 10)
    - 오일러 순환 또는 경로: 【       】 (답: 둘 다 존재하지 않음)

(d) Q₃ (3차원 하이퍼큐브)
    - 각 꼭지점의 차수: 【    】 (답: 3)
    - 홀수 차수 꼭지점 수: 【    】 (답: 8)
    - 오일러 순환 또는 경로: 【       】 (답: 둘 다 존재하지 않음)

(e) C₆ (6-순환)
    - 각 꼭지점의 차수: 【    】 (답: 2)
    - 홀수 차수 꼭지점 수: 【    】 (답: 0)
    - 오일러 순환: 【       】 (답: 존재)

(f) W₄ (바퀴 그래프, 중심 + 4-순환)
    - 중심 꼭지점의 차수: 【    】 (답: 4)
    - 테두리 꼭지점의 차수: 【    】 (답: 3)
    - 홀수 차수 꼭지점 수: 【    】 (답: 4)
    - 오일러 순환 또는 경로: 【       】 (답: 둘 다 존재하지 않음)
```

<details>
<summary>📝 답 보기</summary>

```
(a) K₅: 차수=4(짝수), 홀수 0개 → 오일러 순환 존재 ✅
(b) K₄: 차수=3(홀수), 홀수 4개 → 순환 ❌, 경로 ❌
(c) Petersen: 차수=3, 홀수 10개 → 순환 ❌, 경로 ❌
(d) Q₃: 차수=3, 홀수 8개 → 순환 ❌, 경로 ❌
(e) C₆: 차수=2(짝수), 홀수 0개 → 오일러 순환 존재 ✅
(f) W₄: 중심=4, 테두리=3, 홀수 4개 → 순환 ❌, 경로 ❌

일반적 규칙:
- Kₙ: 차수=n-1, n이 홀수이면 차수 짝수 → 오일러 순환 존재
        n이 짝수이면 차수 홀수 → 존재하지 않음
- Cₙ: 차수=2(항상 짝수) → 항상 오일러 순환 존재
- Wₙ: 중심=n(짝수), 테두리=3(홀수) → 항상 존재하지 않음 (n≥3)
- Qₙ: 차수=n, n이 짝수이면 오일러 순환 존재, 홀수이면 불가능
```

</details>

---

### 연습 9.5: Lean 4로 오일러 판별 함수 작성 (skeleton)

```lean
-- 오일러 순환 가능성을 판별하는 함수
-- 입력: 각 꼭지점의 차수 리스트
-- 출력: "순환 가능" / "경로만 가능" / "불가능"

inductive EulerResult
  | circuit     -- 오일러 순환 존재
  | pathOnly    -- 오일러 경로만 존재 (순환은 아님)
  | impossible  -- 둘 다 불가능

def checkEuler (degrees : List Nat) : EulerResult :=
  let oddCount := degrees.filter (fun d => 【          】)  -- 홀수인 것 필터
                        |>.length
  if oddCount = 【    】 then       -- 홀수 차수가 0개
    EulerResult.circuit
  else if oddCount = 【    】 then  -- 홀수 차수가 2개
    EulerResult.pathOnly
  else
    EulerResult.【          】     -- 불가능

-- 테스트
#eval checkEuler [2, 2, 2, 2]       -- C₄: circuit
#eval checkEuler [3, 3, 2, 2, 2]    -- 홀수 2개: pathOnly  
#eval checkEuler [3, 3, 3, 3]       -- K₄: impossible
```

<details>
<summary>📝 답 보기</summary>

```lean
def checkEuler (degrees : List Nat) : EulerResult :=
  let oddCount := degrees.filter (fun d => d % 2 ≠ 0)
                        |>.length
  if oddCount = 0 then
    EulerResult.circuit
  else if oddCount = 2 then
    EulerResult.pathOnly
  else
    EulerResult.impossible

#eval checkEuler [2, 2, 2, 2]       -- circuit ✅
#eval checkEuler [3, 3, 2, 2, 2]    -- pathOnly ✅
#eval checkEuler [3, 3, 3, 3]       -- impossible ✅
```

</details>

---

### 연습 9.6: 오일러 순환의 존재를 Lean 4로 증명 (sorry)

```lean
-- K₅ (완전 그래프, 5꼭지점)에 오일러 순환이 존재함을 보여라.
-- 힌트: 모든 차수가 4(짝수)임을 보이면 된다.

def K5 : SimpleGraph (Fin 5) where
  Adj u v := u ≠ v
  symm := by sorry
  loopless := by sorry

-- K₅의 모든 꼭지점의 차수가 짝수임을 증명
theorem K5_all_even_degree : ∀ v : Fin 5, Even (K5.degree v) := by
  sorry
```

<details>
<summary>📝 답 보기</summary>

```lean
def K5 : SimpleGraph (Fin 5) where
  Adj u v := u ≠ v
  symm := by intro u v h; exact Ne.symm h
  loopless := by intro v h; exact absurd rfl h

theorem K5_all_even_degree : ∀ v : Fin 5, Even (K5.degree v) := by
  intro v
  fin_cases v <;> decide
```

</details>

---

### 연습 9.7: 일반화 — Kₙ의 오일러 조건 (sorry)

```lean
-- Kₙ (완전 그래프)에 대해:
-- n이 홀수이면 (즉 n = 2k+1이면) 
-- 각 꼭지점의 차수 = n-1 = 2k (짝수)이므로 오일러 순환이 존재한다.

-- Kₙ 정의
def completeGraph (n : Nat) : SimpleGraph (Fin n) where
  Adj u v := u ≠ v
  symm := by intro u v h; exact Ne.symm h
  loopless := by intro v h; exact absurd rfl h

-- n이 홀수이면 Kₙ의 모든 차수가 짝수
theorem complete_graph_even_degree_if_odd (n : Nat) (hn : Odd n) :
    ∀ v : Fin n, Even ((completeGraph n).degree v) := by
  sorry
  -- 힌트: Kₙ의 차수 = n - 1
  -- n이 홀수이면 n - 1은 짝수
```

<details>
<summary>📝 답 보기</summary>

```lean
-- 이 증명은 Mathlib의 completeGraph와 degree 관련 보조정리를 사용해야 한다.
-- 핵심 아이디어: 
-- completeGraph의 degree v = Fintype.card (Fin n) - 1 = n - 1
-- n이 홀수(Odd n)이면 n - 1이 짝수(Even (n-1))

theorem complete_graph_even_degree_if_odd (n : Nat) (hn : Odd n) :
    ∀ v : Fin n, Even ((completeGraph n).degree v) := by
  intro v
  -- degree of v in Kₙ = n - 1
  -- Since n is odd, n - 1 is even
  obtain ⟨k, hk⟩ := hn
  -- n = 2k + 1, so n - 1 = 2k
  sorry  -- 완전한 증명은 Mathlib의 보조정리에 의존
```

</details>

---

### 연습 9.8: Cₙ에 대한 오일러 순환 (sorry)

```lean
-- 순환 그래프 Cₙ (n ≥ 3)은 항상 오일러 순환을 가진다.
-- 왜냐하면 모든 꼭지점의 차수가 2(짝수)이기 때문이다.

def cycleGraph (n : Nat) (hn : n ≥ 3) : SimpleGraph (Fin n) where
  Adj u v := (u.val + 1) % n = v.val ∨ (v.val + 1) % n = u.val
  symm := by
    intro u v h
    rcases h with h1 | h2
    · right; exact h1
    · left; exact h2
  loopless := by
    intro v h
    rcases h with h1 | h2 <;> omega

-- Cₙ의 모든 차수가 2임을 증명
theorem cycle_degree_two (n : Nat) (hn : n ≥ 3) :
    ∀ v : Fin n, (cycleGraph n hn).degree v = 2 := by
  sorry
```

<details>
<summary>📝 답 보기</summary>

```lean
-- 이 증명은 각 꼭지점이 정확히 2개의 이웃을 가짐을 보여야 한다:
-- v의 이웃: (v - 1) % n 과 (v + 1) % n
-- 이 두 값이 서로 다르고 (n ≥ 3이므로), v 자신과도 다르다.

theorem cycle_degree_two (n : Nat) (hn : n ≥ 3) :
    ∀ v : Fin n, (cycleGraph n hn).degree v = 2 := by
  intro v
  sorry  -- 완전한 증명은 neighborFinset의 구조를 분석해야 한다
  -- 핵심: neighborFinset v = {(v+1)%n, (v-1)%n} 이고 card = 2
```

</details>

---

### 연습 9.9: 오일러 판별 종합 증명 (sorry)

```lean
-- "연결된 그래프에서 홀수 차수 꼭지점의 수가 0이 아니고 2도 아니면,
--  오일러 경로도 오일러 순환도 존재하지 않는다."

-- 이것은 정리 1과 정리 2의 대우(contrapositive)이다.

-- 대우(contrapositive) 복습:
-- P → Q 의 대우는 ¬Q → ¬P 이며, 원래 명제와 논리적으로 동치이다.

-- 정리 1의 대우: 
-- "홀수 차수 꼭지점이 있으면 → 오일러 순환이 존재하지 않는다"

-- 정리 2의 대우:
-- "홀수 차수 꼭지점이 2개가 아니면 → 오일러 경로(순환 아님)가 존재하지 않는다"

-- 합치면:
-- 홀수 차수 꼭지점 수 ∉ {0, 2} → 오일러 순환도 경로도 불가능

theorem no_euler_if_many_odd 
    (G : SimpleGraph (Fin n)) [DecidableRel G.Adj]
    (hG : G.Connected)
    (hodd : (Finset.univ.filter (fun v => ¬ Even (G.degree v))).card > 2) :
    ¬ hasEulerCircuit G ∧ ¬ hasEulerPath G := by
  sorry
```

<details>
<summary>📝 답 보기</summary>

```lean
-- 이 증명의 핵심:
-- 1. 오일러 순환이 존재하면 모든 차수가 짝수 (정리 1 →)
--    → 홀수 차수 꼭지점 수 = 0, 이는 > 2와 모순
-- 2. 오일러 경로가 존재하면 홀수 차수 꼭지점 = 정확히 2 (정리 2 →)  
--    → 이는 > 2와 모순

theorem no_euler_if_many_odd 
    (G : SimpleGraph (Fin n)) [DecidableRel G.Adj]
    (hG : G.Connected)
    (hodd : (Finset.univ.filter (fun v => ¬ Even (G.degree v))).card > 2) :
    ¬ hasEulerCircuit G ∧ ¬ hasEulerPath G := by
  constructor
  · -- 오일러 순환 불가능
    intro hcirc
    -- hcirc → 모든 차수 짝수 → 홀수 0개 → 0 > 2 모순
    sorry
  · -- 오일러 경로 불가능
    intro hpath
    -- hpath → 홀수 차수 정확히 2개 → 2 > 2 모순
    sorry
```

</details>

---

## 10. 핵심 요약

1. **오일러 순환**(Euler circuit)은 그래프의 **모든 모서리**를 **정확히 한 번** 포함하는 **닫힌 경로**(순환)이다.

2. **오일러 경로**(Euler path)는 그래프의 **모든 모서리**를 **정확히 한 번** 포함하는 **열린 경로**이다.

3. **정리 1** (오일러 순환의 필요충분조건): 연결 다중 그래프가 오일러 순환을 가짐 **↔** 모든 꼭지점의 차수가 짝수.

4. **정리 2** (오일러 경로의 필요충분조건): 연결 다중 그래프가 오일러 경로(순환 아님)를 가짐 **↔** 정확히 2개의 꼭지점이 홀수 차수.

5. 홀수 차수 꼭지점이 0개도 2개도 아니면 → 오일러 순환도 경로도 **불가능**.

6. **쾨니히스베르크 다리 문제**: 4개의 꼭지점이 **모두** 홀수 차수(3, 5, 3, 3)이므로 오일러 순환도 경로도 불가능.

7. **순환 합치기 알고리즘**: 모든 차수가 짝수인 연결 그래프에서 오일러 순환을 $O(m)$ 시간에 구성.

8. **응용**: 연필을 떼지 않고 그리기, 우편배달부 문제, 네트워크 검사.

9. Lean 4에서 오일러 조건은 `Even (G.degree v)`와 `Finset.filter`로 표현한다.

10. **↔**(iff)는 양방향 증명이 필요하며, `constructor`로 분리하고, `.mp`와 `.mpr`로 각 방향을 사용한다.

---

## 11. 사용된 Lean 4 전술 정리

| 전술/키워드 | 용도 | 예시 |
|:---|:---|:---|
| `Even` | 짝수 판별 | `Even n ↔ ∃ k, n = 2 * k` |
| `Odd` | 홀수 판별 | `Odd n ↔ ∃ k, n = 2 * k + 1` |
| `Finset.filter` | 조건 필터링 | 홀수 차수 꼭지점 걸러내기 |
| `.card` | 집합 크기 | `(Finset.filter ...).card` |
| `constructor` | ∧ 또는 ↔ 분리 | 양방향 증명으로 분리 |
| `.mp` / `.mpr` | ↔의 각 방향 | `h.mp : P → Q`, `h.mpr : Q → P` |
| `fin_cases` | 유한 경우 분석 | `fin_cases v <;> decide` |
| `decide` | 결정 가능 명제 판별 | 유한 그래프의 차수 계산 |
| `omega` | 자연수 산술 | 모듈러 연산, 부등식 |
| `%` | 나머지 연산 | 순환 그래프의 인접성 정의 |
| `List.filter` | 리스트 필터링 | `degrees.filter (fun d => d % 2 ≠ 0)` |

---

> **다음 파트 예고**: Part 13-H에서는 **해밀턴 경로와 해밀턴 순환**(Hamilton path and circuit, Section 10.5.3~10.5.4)을 다룬다. "모든 **꼭지점**을 딱 한 번만 방문할 수 있을까?"라는 오일러 문제와 비슷하지만 훨씬 어려운 문제를 배운다! **디락 정리**(Dirac's theorem)와 **오레 정리**(Ore's theorem)라는 해밀턴 순환의 충분조건, 그리고 **그레이 코드**(Gray code)와 **외판원 문제**(TSP)라는 흥미로운 응용을 Lean 4로 형식화한다!
