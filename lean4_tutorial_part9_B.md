# 📘 Lean4 이산수학 튜토리얼 Part 9-B: 뺄셈 법칙, 나눗셈 법칙, 트리 도표

> **Rosen 이산수학 8판 6.1절 (후반부) 기반**
> **『Mathematics in Lean』 Chapter 6: Discrete Mathematics 참고**

---

## 9B.0 이전 편 복습

Part 9-A에서 우리는 계수의 두 가지 기본 법칙을 배웠다:

| 법칙 | 상황 | 연산 | Lean4 |
|------|------|------|-------|
| **곱셈 법칙** | 연속 작업 (AND) | n₁ × n₂ | `α × β`, `s ×ˢ t` |
| **덧셈 법칙** | 대안 선택 (OR, 서로소) | n₁ + n₂ | `α ⊕ β`, `s ∪ t` |

하지만 덧셈 법칙에는 중요한 **제한**이 있었다: 두 방법의 군이 **서로소**(disjoint)여야 한다는 것이다. 만약 두 방법의 군에 **공통 원소**가 있으면 어떻게 할까? 이것이 바로 **뺄셈 법칙**(포함-배제 원리)이다.

---

## 9B.1 **뺄셈 법칙**(Subtraction Rule) — **포함-배제 원리**(Inclusion-Exclusion)

### 직관적 이해

단순히 더하면 **중복 계수**가 발생한다. 이때 중복된 부분을 빼주어야 한다.

> 📐 **뺄셈 법칙**: 어떤 작업을 수행하는 n₁가지 방법들과 n₂가지 방법들이 존재한다면,
> 이 작업을 수행할 수 있는 방법들의 총 수는 **n₁ + n₂ - (두 방법에 공통으로 포함된 방법의 수)** 이다.

비유하자면:

```
🏫 영어반 학생: 20명
🏫 수학반 학생: 15명
🏫 둘 다 수강하는 학생: 5명

총 학생 수 = 20 + 15 - 5 = 30명 (중복 제거!)
```

### 수학적 공식

두 유한집합 A₁, A₂에 대해:

> |A₁ ∪ A₂| = |A₁| + |A₂| - |A₁ ∩ A₂|

이것을 **포함-배제 원리**(Inclusion-Exclusion Principle)라고도 한다.

### Lean4에서의 뺄셈 법칙

```lean
import Mathlib
open Finset

-- 포함-배제 원리
-- |s ∪ t| = |s| + |t| - |s ∩ t|
example (s t : Finset Nat) :
    #(s ∪ t) = #s + #t - #(s ∩ t) := by
  rw [card_union]
```

> ⚠️ **주의**: 자연수에서는 뺄셈이 0 아래로 내려가지 않는다. Lean4에서 `Nat`의 뺄셈은 `truncated subtraction`이다 (음수가 나오면 0이 된다). 하지만 포함-배제에서는 항상 `#(s ∩ t) ≤ #s + #t`이므로 문제가 없다.

---

## 9B.2 **교재 예제 18**: 비트 문자열 (뺄셈 법칙)

> **문제**: 1로 시작하거나 00으로 끝나는 길이 8의 비트 문자열은 모두 몇 개인가?

### 풀이

포함-배제 원리를 적용하기 위해 먼저 3가지 계수 문제를 해결해야 한다.

**1로 시작하는** 길이 8의 비트 문자열:
- 첫 번째 비트를 1로 고정하고 나머지 일곱 비트를 각각 2가지씩 선택
- 2⁷ = **128가지**

**00으로 끝나는** 길이 8의 비트 문자열:
- 마지막 두 비트를 0으로 고정하고 나머지 여섯 비트를 각각 2가지씩 선택
- 2⁶ = **64가지**

**1로 시작하면서 00으로 끝나는** 길이 8의 비트 문자열 (중복):
- 첫 비트를 1로, 마지막 두 비트를 0으로 고정, 나머지 다섯 비트를 선택
- 2⁵ = **32가지**

따라서 포함-배제에 의해: 128 + 64 - 32 = **160가지**

### Lean4 구현

```lean
-- 1로 시작하는 비트 문자열: 2^7
-- 00으로 끝나는 비트 문자열: 2^6
-- 1로 시작하고 00으로 끝나는: 2^5
-- 포함-배제: 2^7 + 2^6 - 2^5

theorem bit_string_incl_excl :
    2 ^ 7 + 2 ^ 6 - 2 ^ 5 = 160 := by norm_num
```

좀 더 형식적으로, 각 부분을 lemma로 나누어 증명할 수 있다:

```lean
-- 작은 정리들 (디딤돌)
lemma starts_with_1 : 2 ^ 7 = 128 := by norm_num
lemma ends_with_00 : 2 ^ 6 = 64 := by norm_num
lemma starts_1_ends_00 : 2 ^ 5 = 32 := by norm_num

-- 큰 정리 (포함-배제 적용)
theorem bit_string_count :
    128 + 64 - 32 = 160 := by norm_num
```

> 💡 이것이 바로 **작은 정리**(lemma)와 **큰 정리**(theorem)의 관계다! 작은 정리들이 벽돌이 되어 큰 정리를 완성한다.

---

## 9B.3 **교재 예제 19**: 포함-배제 응용 — 지원자 수

> **문제**: 한 컴퓨터 회사가 일련의 새 웹 서버들을 설치하는 작업을 위해 새 직원 모집을 공고하였고 이에 관련 졸업생 350명이 신청하였다. 신청자 중 220명이 컴퓨터과학을 전공하고 147명이 비즈니스(business)를, 그리고 51명이 컴퓨터과학과 비즈니스를 모두 전공하였다면 컴퓨터과학도 비즈니스도 전공하지 않은 지원자는 총 몇 명인가?

### 풀이

A₁ = 컴퓨터과학 전공 지원자 집합, A₂ = 비즈니스 전공 지원자 집합이라 하면:
- |A₁| = 220, |A₂| = 147, |A₁ ∩ A₂| = 51
- 뺄셈 법칙에 의해: |A₁ ∪ A₂| = 220 + 147 - 51 = **316명**
- 따라서 둘 다 전공하지 않은 지원자: 350 - 316 = **34명**

### Lean4 구현

```lean
-- 포함-배제
theorem applicants_union : 220 + 147 - 51 = 316 := by norm_num

-- 전공하지 않은 사람
theorem neither_major : 350 - 316 = 34 := by norm_num
```

---

## 9B.4 연습 세트 1: 뺄셈 법칙

### 연습 1-1: 비트 문자열 변형

> **문제**: 0으로 시작하거나 1로 끝나는 길이 10의 비트 문자열은 모두 몇 개인가?

**[괄호 채우기]**

```lean
-- 0으로 시작: 2^9 = 512
-- 1로 끝남: 2^9 = 512
-- 0으로 시작하고 1로 끝남: 2^8 = 256
-- 포함-배제: 512 + 512 - 256

theorem bit_string_10 :
    2 ^ 9 + 2 ^ 9 - 2 ^ 8 = (______) := by norm_num
```

<details>
<summary>📝 답 보기</summary>

```lean
theorem bit_string_10 :
    2 ^ 9 + 2 ^ 9 - 2 ^ 8 = 768 := by norm_num
```

풀이: 0으로 시작하는 것(512) + 1로 끝나는 것(512) - 둘 다(256) = **768개**.
</details>

### 연습 1-2: 교재 연습문제 55

> **문제**: 100 이하의 양의 정수 중에서 4 또는 6으로 나누어지는 수는 모두 몇 개인가?

**[괄호 채우기]**

```lean
-- 4로 나누어지는 수: ⌊100/4⌋ = 25개
-- 6으로 나누어지는 수: ⌊100/6⌋ = 16개 (16.67 → 16)
-- 4와 6 모두로 나누어지는 수 = 12(=lcm(4,6))로 나누어지는 수: ⌊100/12⌋ = 8개
-- 포함-배제: 25 + 16 - 8

theorem divisible_4_or_6 :
    25 + 16 - 8 = (______) := by norm_num
```

<details>
<summary>📝 답 보기</summary>

```lean
theorem divisible_4_or_6 :
    25 + 16 - 8 = 33 := by norm_num
```

풀이: 4의 배수(25개) + 6의 배수(16개) - 12의 배수(8개) = **33개**.
4와 6의 **최소공배수**(LCM)가 12이므로, 둘 다로 나누어지는 수는 12의 배수이다.
</details>

### 연습 1-3: 학생 전공 (sorry 문제)

> **문제**: 전산 전공자가 38명(다중 전공자 포함), 수학 전공자가 23명(다중 전공자 포함), 다중 전공자가 7명일 경우 이산수학 과목을 수강하는 학생은 모두 몇 명인가? (교재 연습문제 54)

```lean
-- 포함-배제: 38 + 23 - 7
theorem students_total : 38 + 23 - 7 = 54 := by
  sorry
```

<details>
<summary>📝 답 보기</summary>

```lean
theorem students_total : 38 + 23 - 7 = 54 := by norm_num
```
</details>

---

## 9B.5 **나눗셈 법칙**(Division Rule)

### 직관적 이해

> 📐 **나눗셈 법칙**: 어떤 작업을 수행하는 n가지 방법들이 존재하고,
> 모든 각각의 방법 w에 대해 정확히 n가지 방법들 중 **d가지의 방법들이 이에 대응**될 경우,
> 이 작업을 수행하는 방법의 개수는 **n/d** 가지가 존재한다.

비유하자면:

```
🧤 장갑 12개가 있다.
장갑은 항상 짝(2개씩)으로 구성된다.
→ 장갑 짝의 수 = 12 / 2 = 6쌍
```

### 수학적 정의

집합론적으로: "유한집합 A가 n개의 서로 겹치지 않는 부분집합들의 합집합으로 표현되고 각각의 부분집합들이 모두 d개의 원소들로 구성되어 있으면, n = |A|/d와 같게 된다."

함수 관점으로: "유한집합 A, B에 대해 어떤 함수 f가 A에서 B로 대응시키는 함수이고 모든 y ∈ B에 대해 f(x) = y를 만족시키는 x ∈ A가 정확히 d개 존재한다면, |B| = |A|/d와 같게 된다."

### Lean4에서의 나눗셈 법칙

나눗셈 법칙은 Lean4에서 **몫**(quotient)의 개념과 관련된다:

```lean
-- d-to-1 함수가 있을 때의 카디널리티 관계
-- 만약 f : A → B가 정확히 d-대-1이면
-- |B| = |A| / d

-- 간단한 예시: 원소 12개를 3개씩 묶으면 4묶음
theorem division_rule_example : 12 / 3 = 4 := by norm_num
```

---

## 9B.6 **교재 예제 20**: 소의 다리 (나눗셈 법칙)

> **문제**: 목초지 내 모든 소의 다리 개수를 계수해주는, 어떤 자동화 시스템이 개발되었다고 가정하자. 이 시스템에 의해 어떤 농장 내 목초지에는 소의 다리 개수가 정확히 572개 있음을 확인하였다. 만약 모든 소의 다리가 4개씩이고 목초지 내 다른 동물들이 존재하지 않는 라면, 이 목초지에는 모두 몇 마리의 소가 존재하는가?

### 풀이

n = 572 (소의 다리 수), d = 4 (소 한 마리당 다리 수)

나눗셈 법칙에 의해: 572 / 4 = **143마리**

### Lean4 구현

```lean
-- 소의 다리 문제
theorem cows_in_pasture : 572 / 4 = 143 := by norm_num
```

---

## 9B.7 **교재 예제 21**: 원형 탁자 (나눗셈 법칙)

> **문제**: 4인용 원형 탁자에 4명의 사람들을 앉힐 수 있는 서로 다른 방법의 수를 구하시오. 단, 자신의 왼쪽 옆과 오른쪽 옆에 같은 사람들이 앉아 있는 경우는 같은 방법으로 간주한다.

### 풀이

- 먼저 4명을 일렬로 세우는 방법: 4! = 24가지
- 원형 탁자이므로, 4가지 **회전**이 모두 동일한 배치로 간주된다
- 나눗셈 법칙에 의해: 24 / 4 = **6가지**

### Lean4 구현

```lean
-- 원형 순열: n명의 원형 배치 = n! / n = (n-1)!
-- 4명: 4! / 4 = 24 / 4 = 6

-- 팩토리얼 정의
def fac : Nat → Nat
  | 0 => 1
  | n + 1 => (n + 1) * fac n

#eval fac 4   -- 24

theorem circular_permutation_4 :
    fac 4 / 4 = 6 := by native_decide

-- 일반 공식: (n-1)!
-- 4명의 원형 배치 = 3! = 6
theorem circular_perm_alt : fac 3 = 6 := by native_decide
```

---

## 9B.8 연습 세트 2: 나눗셈 법칙

### 연습 2-1: 짝 지어 세기

> **문제**: 교실에 손이 모두 60개 있다. (모든 학생의 손이 2개라면) 학생은 몇 명인가?

**[괄호 채우기]**

```lean
theorem students_count : 60 / 2 = (______) := by norm_num
```

<details>
<summary>📝 답 보기</summary>

```lean
theorem students_count : 60 / 2 = 30 := by norm_num
```
</details>

### 연습 2-2: 교재 연습문제 46

> **문제**: 10명의 사람들로 구성된 그룹에서 4명을 골라 원형 탁자 주위로 앉힐 수 있는 방법은 모두 몇 개인지 찾아라. 단, 좌우로 같은 사람이 앉아있는 경우는 같은 방법으로 간주한다.

**[sorry 문제]**

```lean
-- 10명에서 4명을 순서대로 뽑기: 10 × 9 × 8 × 7 = 5040
-- 원형 배치이므로 4로 나눔: 5040 / 4 = 1260
theorem circular_seating_10_4 : 10 * 9 * 8 * 7 / 4 = 1260 := by
  sorry
```

<details>
<summary>📝 답 보기</summary>

```lean
theorem circular_seating_10_4 : 10 * 9 * 8 * 7 / 4 = 1260 := by norm_num
```
</details>

---

## 9B.9 **트리 도표**(Tree Diagrams)

### 직관적 이해

**트리 도표**(Tree Diagram)는 계수 문제를 시각적으로 풀 수 있는 도구다. 트리는 **루트**(root)에서 시작하여, 각 **분기**(branch)는 가능한 선택을 나타내고, **잎**(leaf)은 최종 결과를 나타낸다.

```
        ●  (루트)
       / \
      /   \
     A     B      ← 첫 번째 선택 (2가지)
    / \   / \
   1   2 1   2    ← 두 번째 선택 (각 2가지)
```

위 트리에서 잎의 수 = 4 = 2 × 2 (곱셈 법칙!)

### 트리 도표가 유용한 이유

곱셈 법칙이나 덧셈 법칙만으로는 풀기 어려운 문제에서, 트리 도표를 그리면 **모든 경우**를 체계적으로 나열할 수 있다.

### Lean4에서 트리 도표: 귀납적 타입

Lean4에서 트리 구조는 **귀납적 타입**(inductive type)으로 자연스럽게 표현된다:

```lean
-- 이진 트리 (Part 8-E에서 다룬 내용)
inductive BinTree (α : Type) where
  | leaf : BinTree α
  | node : BinTree α → α → BinTree α → BinTree α
```

---

## 9B.10 **교재 예제 22**: 연속 1 없는 비트 문자열 (트리 도표)

> **문제**: 연속된 두 개의 1을 갖지 않는, 길이 4의 비트 문자열은 모두 몇 개인가?

### 풀이

트리 도표를 그려 모든 경우를 나열하면 **8개**임을 알 수 있다:

```
0000, 0001, 0010, 0100, 0101, 1000, 1001, 1010
```

### Lean4 구현

```lean
-- 연속 1이 없는 비트 문자열 판별
def noConsecutiveOnes : List Bool → Bool
  | [] => true
  | [_] => true
  | true :: true :: _ => false
  | _ :: rest => noConsecutiveOnes rest

-- 길이 4의 모든 비트 문자열 생성
def allBitStrings : Nat → List (List Bool)
  | 0 => [[]]
  | n + 1 => (allBitStrings n).flatMap fun bs => [false :: bs, true :: bs]

-- 연속 1이 없는 것만 필터
#eval (allBitStrings 4).filter noConsecutiveOnes |>.length   -- 8

theorem no_consec_ones_4 :
    (allBitStrings 4).filter noConsecutiveOnes |>.length = 8 := by native_decide
```

> 💡 **흥미로운 사실**: 연속 1이 없는 길이 n 비트 문자열의 수는 **피보나치 수열**을 따른다! 길이 1: 2개, 길이 2: 3개, 길이 3: 5개, 길이 4: **8개**, 길이 5: 13개, ...

---

## 9B.11 연습 세트 3: 트리 도표

### 연습 3-1: 교재 연습문제 66

> **문제**: 트리 도표를 이용하여, 연속된 3개의 0을 포함하지 않는 길이 4의 비트 문자열의 개수를 구하라.

**[괄호 채우기]**

```lean
def noThreeConsecZeros : List Bool → Bool
  | false :: false :: false :: _ => false
  | _ :: rest => noThreeConsecZeros rest
  | _ => true

theorem no_three_zeros_4 :
    (allBitStrings 4).filter noThreeConsecZeros |>.length = (______) := by
  native_decide
```

<details>
<summary>📝 답 보기</summary>

```lean
theorem no_three_zeros_4 :
    (allBitStrings 4).filter noThreeConsecZeros |>.length = 13 := by
  native_decide
```

풀이: 길이 4의 전체 16개 비트 문자열 중, 연속된 3개의 0이 포함된 것은 0000, 0001, 1000의 **3개**이다. 따라서 16 - 3 = **13개**. (단, 0000에는 연속 3개의 0이 두 번 나타나지만 문자열 자체는 한 번만 셈.)
</details>

### 연습 3-2: 플레이오프 방법 (교재 예제 23)

> **문제**: 두 팀 간의 플레이오프는 최대 5번으로 진행되며 먼저 3경기를 이기는 팀이 플레이오프의 승자가 된다. 플레이오프가 진행되는 방법은 모두 몇 가지인가?

**[sorry 문제]**

```lean
-- 3판 2선승 × 2팀 = 다양한 시나리오
-- 트리 도표로 세면: 20가지
-- (3경기: 2가지, 4경기: 2×2×2=8가지, 5경기: 2×2×...=10가지 등)
-- 정확한 계산: 20가지

-- 시뮬레이션으로 확인
def playoffs : List (List Bool) :=
  -- true = Team1 승, false = Team2 승
  -- 먼저 3승하면 종료
  let all5 := allBitStrings 5
  all5.filter fun game =>
    let t1_wins := (game.take 3).filter id |>.length  -- 처음 3경기 T1 승수
    -- 사실 이건 복잡하므로 직접 열거가 낫다
    true  -- placeholder

-- 알려진 결과: 20가지
theorem playoff_count : 20 = 20 := by
  sorry   -- 이 문제는 트리 도표를 직접 그려서 세는 것이 핵심!
```

<details>
<summary>📝 답 보기</summary>

트리 도표를 그리면:
- 3경기 만에 끝나는 경우: 2가지 (TTT, FFF)
- 4경기 만에 끝나는 경우: 2 × C(3,2) = 2 × 3 = 6가지 (3경기 중 2번 이기고 4경기째 이김)
  - T가 이기는 경우: TFTT, TTFT, FTTT → 아니, 정확히는 T가 4경기째에 3번째 승을 거두는 경우
  - 마찬가지로 F가 이기는 경우도 동일
  - 총 2 × 3 = 6가지
  - 하지만 구체적으로 열거하면 TTFT, TFTT, FTTT, FFTF, FTFF, TFFF → 6가지
- 5경기 만에 끝나는 경우: 2 × C(4,2) = 2 × 6 = 12가지

총: 2 + 6 + 12 = **20가지**

```lean
theorem playoff_count : 2 + 6 + 12 = 20 := by norm_num
```
</details>

---

## 9B.12 **교재 예제 15~16**: 보다 복잡한 계수 문제

### 교재 예제 15: BASIC 변수 이름 (덧셈 + 곱셈 조합)

> **문제**: 어떤 BASIC 언어에서 변수의 이름은 하나 또는 두 개의 영숫자 문자로 구성되는데, 소문자와 대문자는 구별하지 않는다. 또한, 변수의 이름은 문자로 시작하여야 하고, 프로그래밍에 사용되는 2글자로 된 예약어 5개는 사용할 수 없다. 이 BASIC 언어에 서로 다른 변수의 이름이 모두 몇 개 있는가?

### 풀이

서로 다른 변수 이름의 개수를 V라 하자.
- 한 글자 변수(V₁): 26개 (영문자 26개)
- 두 글자 변수(V₂): 첫 글자는 문자(26가지) × 둘째 글자는 영숫자(36가지) = 26 × 36 = 936, 예약어 5개 제외 → 936 - 5 = **931개**
- 덧셈 법칙: V = V₁ + V₂ = 26 + 931 = **957개**

### Lean4 구현

```lean
-- BASIC 변수 이름
lemma one_char_vars : 26 = 26 := rfl
lemma two_char_vars : 26 * 36 - 5 = 931 := by norm_num
theorem basic_var_names : 26 + 931 = 957 := by norm_num
```

### 교재 예제 16: 패스워드 수 (여러 길이의 합)

> **문제**: 컴퓨터 시스템의 사용자는 6에서 8개의 글자로 패스워드를 구성하는데, 각 글자는 대문자이거나 숫자이고 패스워드에는 적어도 한 개의 숫자가 있어야 한다. 가능한 패스워드의 수는 얼마인가?

### 풀이

길이 k의 패스워드 수를 Pₖ라 하자. 모든 글자: 대문자(26) + 숫자(10) = 36가지.

Pₖ = (전체 문자열 수) - (숫자가 없는 문자열 수) = 36ᵏ - 26ᵏ

- P₆ = 36⁶ - 26⁶ = 2,176,782,336 - 308,915,776 = **1,867,866,560**
- P₇ = 36⁷ - 26⁷ = **70,332,353,920**
- P₈ = 36⁸ - 26⁸ = **2,612,282,842,880**

총 패스워드 수 P = P₆ + P₇ + P₈ = **2,684,483,063,360**

### Lean4 구현

```lean
-- 길이 k 패스워드: 36^k - 26^k (적어도 1개 숫자)
def passwordCount (k : Nat) : Nat := 36 ^ k - 26 ^ k

#eval passwordCount 6    -- 1867866560
#eval passwordCount 7    -- 70332353920
#eval passwordCount 8    -- 2612282842880

theorem total_passwords :
    passwordCount 6 + passwordCount 7 + passwordCount 8 = 2684483063360 := by
  native_decide
```

---

## 9B.13 연습 세트 4: 종합 문제

### 연습 4-1: 교재 연습문제 7 — 이니셜

> **문제**: 3자의 영문 이니셜로 표현할 수 있는 서로 다른 사람의 수는?

**[괄호 채우기]**

```lean
-- 3자리 이니셜: 각 자리 26가지 → 26^3
theorem initials_3 : 26 ^ 3 = (______) := by norm_num
```

<details>
<summary>📝 답 보기</summary>

```lean
theorem initials_3 : 26 ^ 3 = 17576 := by norm_num
```
</details>

### 연습 4-2: 교재 연습문제 11 — 비트 문자열 (1로 시작하여 1로 끝남)

> **문제**: 1로 시작하여 1로 끝나는 길이 10의 비트 문자열은 모두 몇 가지인가?

**[괄호 채우기]**

```lean
-- 첫 비트 = 1 (고정), 마지막 비트 = 1 (고정)
-- 나머지 8비트: 각 2가지 → 2^8
theorem bit_1_to_1 : 2 ^ 8 = (______) := by norm_num
```

<details>
<summary>📝 답 보기</summary>

```lean
theorem bit_1_to_1 : 2 ^ 8 = 256 := by norm_num
```
</details>

### 연습 4-3: 교재 연습문제 12 — 비트 문자열 (공백 없음, 길이 ≤ 6)

> **문제**: 공백 문자열을 포함하지 않는 경우 길이가 6 이하인 비트 문자열은 모두 몇 가지인가?

**[sorry 문제]**

```lean
-- 길이 1: 2^1 = 2
-- 길이 2: 2^2 = 4
-- ...
-- 길이 6: 2^6 = 64
-- 덧셈 법칙: 2 + 4 + 8 + 16 + 32 + 64
theorem bit_strings_upto_6 :
    2 + 4 + 8 + 16 + 32 + 64 = 126 := by
  sorry
```

<details>
<summary>📝 답 보기</summary>

```lean
theorem bit_strings_upto_6 :
    2 + 4 + 8 + 16 + 32 + 64 = 126 := by norm_num
```

풀이: 2¹ + 2² + 2³ + 2⁴ + 2⁵ + 2⁶ = 2⁷ - 2 = 128 - 2 = **126**. 이것은 등비급수의 공식이기도 하다!
</details>

### 연습 4-4: 교재 연습문제 36 — 함수의 수

> **문제**: 양의 정수 n에 대하여 집합 {1, 2, ..., n}으로부터 집합 {0, 1}로의 함수는 모두 몇 개인가?

**[sorry 문제]**

```lean
-- {1,...,n} → {0,1} 의 함수 수 = 2^n
-- Lean4: Fin n → Fin 2 ≅ Fin n → Bool
example (n : Nat) : Fintype.card (Fin n → Fin 2) = 2 ^ n := by
  sorry
```

<details>
<summary>📝 답 보기</summary>

```lean
example (n : Nat) : Fintype.card (Fin n → Fin 2) = 2 ^ n := by simp
```
</details>

### 연습 4-5: 교재 연습문제 37(a) — 1대1 함수

> **문제**: 양의 정수 n에 대하여 집합 {1, 2, ..., n}으로부터 집합 {0, 1}로의 **1대1 함수**는 모두 몇 개인가?

**[sorry 문제]**

```lean
-- n > 2이면 1대1 함수가 존재하지 않음 (비둘기집 원리!)
-- n = 1이면: 2가지 (0에 보내거나 1에 보내거나)
-- n = 2이면: 2가지 (0→0,1→1 또는 0→1,1→0)
-- n ≥ 3이면: 0가지

-- n = 2일 때
theorem injective_fns_2_to_2 : 2 * 1 = 2 := by
  sorry
```

<details>
<summary>📝 답 보기</summary>

```lean
theorem injective_fns_2_to_2 : 2 * 1 = 2 := by norm_num
```

풀이: n ≤ 2일 때만 1대1 함수가 존재한다. n = 1이면 2가지, n = 2이면 2 × 1 = 2가지, n ≥ 3이면 0가지 (원소가 3개 이상인데 보낼 곳이 2개뿐이므로 1대1이 불가).
</details>

---

## 9B.14 전술 및 함수 종합 요약

### 이번 파트에서 추가된 핵심 공식

| 공식 | 설명 | Lean4 |
|------|------|-------|
| \|A ∪ B\| = \|A\| + \|B\| - \|A ∩ B\| | **뺄셈 법칙**(포함-배제) | `card_union` |
| \|A\|/d | **나눗셈 법칙** | `Nat.div` |
| (n-1)! | **원형 순열** (나눗셈 법칙 응용) | `fac (n-1)` |

### 핵심 전략: 어떤 법칙을 쓸까?

| 상황 | 키워드 | 법칙 |
|------|--------|------|
| 작업 A **그리고** 작업 B | AND, 연속 | **곱셈 법칙** |
| 작업 A **또는** 작업 B (겹침 없음) | OR, 서로소 | **덧셈 법칙** |
| 작업 A **또는** 작업 B (겹침 있음) | OR, 중복 | **뺄셈 법칙** |
| n가지 방법이 d개씩 같은 결과 | 대칭, 동치류 | **나눗셈 법칙** |

---

## 9B.15 핵심 요약

1. **뺄셈 법칙**(포함-배제): |A ∪ B| = |A| + |B| - |A ∩ B|. 중복을 빼준다!

2. **나눗셈 법칙**: d개씩 같은 것이면 전체를 d로 나눈다. 원형 순열은 대표적 응용이다.

3. **트리 도표**: 선택의 흐름을 시각적으로 나타내어, 복잡한 경우의 수를 체계적으로 셀 수 있다.

4. Lean4에서 `card_union`은 포함-배제를, `card_union_of_disjoint`은 서로소 경우의 덧셈 법칙을 제공한다.

5. 복잡한 문제는 **여러 법칙의 조합**으로 풀어야 한다 — 덧셈 + 곱셈 + 뺄셈을 함께 사용!

---

## 다음 편 예고

**Part 9-C**에서는 Rosen 6.2절 **비둘기집 원리**(Pigeonhole Principle)를 다룬다:
- 기본 비둘기집 원리
- 일반화된 비둘기집 원리
- 단조 부분수열 정리 (에르되시-세게디)
- 램지 이론 소개
