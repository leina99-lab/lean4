# Lean4 완전 정복 가이드 — 제7-C편

## **정수의 표현**(Representations of Integers)과 **진법 전환**(Base Conversion) 완전 정복

> **교재**: Kenneth H. Rosen, "Discrete Mathematics and Its Applications" 8판, 4.2절  
> **선수 학습**: 제7-A편(가분성), 제7-B편(합동과 나머지 산술)

---

## 7C.0 이 장의 목표

1. **밑 b 전개**(base b expansion): 정수를 다양한 진법으로 표현하는 방법
2. **2진법**(binary), **8진법**(octal), **16진법**(hexadecimal) 상호 전환
3. **밑수 전환 알고리즘**: 반복적으로 나누어서 진법 변환하기
4. Lean4에서 진법 변환을 `#eval`과 함수로 검증하기
5. **2진수 덧셈과 곱셈 알고리즘**의 원리

---

## 7C.1 **밑 b 전개**란?

### 7C.1.1 10진법 — 우리가 매일 쓰는 것

숫자 965를 "9백 6십 5"라고 읽는다. 이것은:

965 = 9 × 10² + 6 × 10¹ + 5 × 10⁰ = 9 × 100 + 6 × 10 + 5 × 1

이처럼 **10을 밑**(base)으로 하여 각 자릿수에 10의 거듭제곱을 곱하는 것이 **10진 전개**(decimal expansion)이다.

### 7C.1.2 교재 정리 1: 밑 b 전개의 존재성

> **정리 1** (Rosen 4.2절):  
> b가 1보다 큰 정수라고 하자. 그러면 만약 n이 양의 정수라면, 다음과 같은 유일한 형태로 표현할 수 있다.  
> n = aₖbᵏ + aₖ₋₁bᵏ⁻¹ + ... + a₁b + a₀  
> 여기서 k는 음이 아닌 정수이며, a₀, a₁, ..., aₖ는 b 미만인 음이 아닌 정수이며, aₖ ≠ 0이다.

쉽게 말하면: **어떤 양의 정수도 밑 b를 사용하여 유일하게 표현**할 수 있다.

### 7C.1.3 다양한 진법

| 진법 | 밑(base) | 자릿수 | 용도 |
|------|---------|--------|------|
| **2진법**(binary) | 2 | 0, 1 | 컴퓨터 내부 |
| **8진법**(octal) | 8 | 0~7 | Unix 파일 권한 등 |
| **10진법**(decimal) | 10 | 0~9 | 일상생활 |
| **16진법**(hexadecimal) | 16 | 0~9, A~F | 색상 코드, 메모리 주소 |

---

## 7C.2 **2진법**(Binary) — 컴퓨터의 언어

### 7C.2.1 2진법의 원리

2진법에서는 자릿수가 0 또는 1만 가능하다. 각 자리는 2의 거듭제곱을 나타낸다.

예: (1 0101 1111)₂의 10진 값은?

```
1×2⁸ + 0×2⁷ + 1×2⁶ + 0×2⁵ + 1×2⁴ + 1×2³ + 1×2² + 1×2¹ + 1×2⁰
= 256 + 0 + 64 + 0 + 16 + 8 + 4 + 2 + 1
= 351
```

### 7C.2.2 교재 예제 1: 2진수를 10진수로

> **예제 1**: 2진 전개로 (1 0101 1111)₂인 수의 10진 전개는 무엇인가?

**Lean4 코드**:

```lean
-- 예제 1: (1 0101 1111)₂ = 351
-- 1×256 + 0×128 + 1×64 + 0×32 + 1×16 + 1×8 + 1×4 + 1×2 + 1×1

example : 1*256 + 0*128 + 1*64 + 0*32 + 1*16 + 1*8 + 1*4 + 1*2 + 1*1 = 351 := by
  norm_num

-- 또는 Lean4의 2진수 리터럴 사용:
#eval 0b101011111      -- 결과: 351
```

Lean4에서는 `0b` 접두사로 2진수를 직접 입력할 수 있다!

### 7C.2.3 중간 괄호 채우기 연습

```lean
-- 연습: (1011)₂의 10진 값은?
-- 1×8 + 0×4 + 1×2 + 1×1 = ?
example : 1*8 + 0*4 + 1*2 + 1*1 = _ := by norm_num   -- 🔲
```

<details>
<summary>💡 답 보기</summary>

```lean
example : 1*8 + 0*4 + 1*2 + 1*1 = 11 := by norm_num
-- 확인: #eval 0b1011 = 11
```

</details>

```lean
-- 연습: (11001)₂의 10진 값은?
example : 1*16 + 1*8 + 0*4 + 0*2 + 1*1 = _ := by norm_num   -- 🔲
```

<details>
<summary>💡 답 보기</summary>

```lean
example : 1*16 + 1*8 + 0*4 + 0*2 + 1*1 = 25 := by norm_num
```

</details>

---

## 7C.3 **8진법**(Octal)과 **16진법**(Hexadecimal)

### 7C.3.1 교재 예제 2: 8진수를 10진수로

> **예제 2**: 8진 전개로 (7016)₈인 정수의 10진 전개는 무엇인가?  
> 풀이: b = 8인 밑 b 전개의 정의를 사용하면  
> (7016)₈ = 7 · 8³ + 0 · 8² + 1 · 8 + 6 = 3598

```lean
-- 예제 2
example : 7 * 512 + 0 * 64 + 1 * 8 + 6 = 3598 := by norm_num

-- Lean4의 8진수 리터럴: 0o 접두사
#eval 0o7016    -- 결과: 3598
```

### 7C.3.2 교재 예제 3: 16진수를 10진수로

> **예제 3**: 16진 전개로 (2AE0B)₁₆인 정수의 10진 전개는 무엇인가?  
> 풀이: (2AE0B)₁₆ = 2 · 16⁴ + 10 · 16³ + 14 · 16² + 0 · 16 + 11 = 175627

```lean
-- 예제 3
-- A=10, E=14, B=11
example : 2 * 65536 + 10 * 4096 + 14 * 256 + 0 * 16 + 11 = 175627 := by norm_num

-- Lean4의 16진수 리터럴: 0x 접두사
#eval 0x2AE0B    -- 결과: 175627
```

### 7C.3.3 16진법 자릿수 표

| 10진 | 16진 | 2진 |
|------|------|------|
| 0 | 0 | 0000 |
| 1 | 1 | 0001 |
| 2 | 2 | 0010 |
| ... | ... | ... |
| 9 | 9 | 1001 |
| 10 | A | 1010 |
| 11 | B | 1011 |
| 12 | C | 1100 |
| 13 | D | 1101 |
| 14 | E | 1110 |
| 15 | F | 1111 |

### 7C.3.4 중간 괄호 채우기 연습

```lean
-- 연습: (ABBA)₁₆의 10진 값은?
-- A=10, B=11
example : 10 * 4096 + 11 * 256 + 11 * 16 + 10 = _ := by norm_num   -- 🔲
```

<details>
<summary>💡 답 보기</summary>

```lean
example : 10 * 4096 + 11 * 256 + 11 * 16 + 10 = 43962 := by norm_num
-- 확인: #eval 0xABBA = 43962
```

</details>

---

## 7C.4 **밑수 전환 알고리즘**(Base Conversion Algorithm)

### 7C.4.1 원리

10진수 n을 밑 b로 변환하려면, **반복적으로 b로 나누어** 나머지를 모으면 된다.

1. n을 b로 나눈다: 몫 q₀, 나머지 a₀ (a₀가 가장 오른쪽 자릿수)
2. q₀를 b로 나눈다: 몫 q₁, 나머지 a₁
3. 이 과정을 몫이 0이 될 때까지 반복
4. 나머지를 **역순으로** 읽으면 밑 b 전개

### 7C.4.2 교재 예제 4: (12345)₁₀의 8진 전개

> **예제 4**: (12345)₁₀의 8진 전개를 구하라.  
> 풀이: 12345를 8로 나누면  
> 12345 = 8 · 1543 + 1  
> 1543 = 8 · 192 + 7  
> 192 = 8 · 24 + 0  
> 24 = 8 · 3 + 0  
> 3 = 8 · 0 + 3  
> 나머지를 역순으로 읽으면: (30071)₈

**Lean4 코드**:

```lean
-- 예제 4: 각 단계를 #eval로 확인
#eval 12345 / 8     -- 1543 (몫)
#eval 12345 % 8     -- 1    (나머지 → 첫째 자리)

#eval 1543 / 8      -- 192
#eval 1543 % 8      -- 7    (나머지 → 둘째 자리)

#eval 192 / 8       -- 24
#eval 192 % 8       -- 0    (나머지 → 셋째 자리)

#eval 24 / 8        -- 3
#eval 24 % 8        -- 0    (나머지 → 넷째 자리)

#eval 3 / 8         -- 0    (종료!)
#eval 3 % 8         -- 3    (나머지 → 다섯째 자리)

-- 나머지를 역순으로: 3, 0, 0, 7, 1 → (30071)₈
-- 검증: (30071)₈ = 3×8⁴ + 0×8³ + 0×8² + 7×8 + 1
example : 3 * 4096 + 0 * 512 + 0 * 64 + 7 * 8 + 1 = 12345 := by norm_num

-- 또는 직접 확인:
#eval 0o30071    -- 결과: 12345 ✓
```

### 7C.4.3 Lean4로 밑수 전환 함수 구현

```lean
-- 밑수 전환 함수: 10진수 → 밑 b의 자릿수 리스트 (LSB first)
-- (교재의 알고리즘 1을 구현)
def toBaseDigits (b : ℕ) (n : ℕ) : List ℕ :=
  if h : b ≤ 1 then [n]     -- b가 1 이하이면 의미 없음
  else if n = 0 then []
  else
    have : n / b < n := Nat.div_lt_self (by omega) (by omega)
    (n % b) :: toBaseDigits b (n / b)

-- 테스트
#eval toBaseDigits 8 12345    -- [1, 7, 0, 0, 3] (역순으로 읽으면 30071)
#eval toBaseDigits 2 241      -- [1, 0, 0, 0, 1, 1, 1, 1] (역순: 11110001)
#eval toBaseDigits 16 177130  -- [10, 14, 3, 11, 2] (역순: 2B3EA)
```

### 7C.4.4 교재 예제 6: (241)₁₀의 2진 전개

> **예제 6**: (241)₁₀의 2진 전개를 구하라.

```lean
-- 단계별 계산
#eval 241 / 2    -- 120, 나머지 1
#eval 120 / 2    -- 60, 나머지 0
#eval 60 / 2     -- 30, 나머지 0
#eval 30 / 2     -- 15, 나머지 0
#eval 15 / 2     -- 7, 나머지 1
#eval 7 / 2      -- 3, 나머지 1
#eval 3 / 2      -- 1, 나머지 1
#eval 1 / 2      -- 0, 나머지 1 (종료!)

-- 나머지: 1, 0, 0, 0, 1, 1, 1, 1 → 역순: (11110001)₂
-- 검증:
example : 0b11110001 = 241 := by norm_num
```

### 7C.4.5 중간 괄호 채우기 연습

```lean
-- 연습: (100)₁₀의 2진 전개를 구하라
-- 100 / 2 = 50 나머지 0
-- 50 / 2 = 25 나머지 0
-- 25 / 2 = 12 나머지 1
-- 12 / 2 = 6 나머지 0
-- 6 / 2 = 3 나머지 0
-- 3 / 2 = 1 나머지 1
-- 1 / 2 = 0 나머지 1
-- 역순: (1100100)₂
example : 0b1100100 = _ := by norm_num   -- 🔲
```

<details>
<summary>💡 답 보기</summary>

```lean
example : 0b1100100 = 100 := by norm_num
```

</details>

---

## 7C.5 2진, 8진, 16진 상호 전환

### 7C.5.1 핵심 아이디어

8 = 2³이고 16 = 2⁴이므로:
- **8진수의 한 자리 = 2진수 3자리**
- **16진수의 한 자리 = 2진수 4자리**

이 관계 덕분에, 2진수와 8진수, 16진수 사이의 전환이 매우 쉽다.

### 7C.5.2 교재 예제 7: 세 진법 간의 전환

> **예제 7**: (11 1110 1011 1100)₂의 8진, 16진 전개와  
> (765)₈의 2진 전개, (A8D)₁₆의 2진 전개를 구하라.

```lean
-- (11 1110 1011 1100)₂를 10진수로
#eval 0b11111010111100     -- 16060

-- 8진으로: 세 자리씩 묶기
-- 011 111 010 111 100 → 3 7 2 7 4 → (37274)₈
#eval 0o37274              -- 16060 ✓

-- 16진으로: 네 자리씩 묶기  
-- 0011 1110 1011 1100 → 3 E B C → (3EBC)₁₆
#eval 0x3EBC               -- 16060 ✓

-- (765)₈ → 2진: 각 자리를 3비트로
-- 7→111, 6→110, 5→101 → (111 110 101)₂
example : 0o765 = 0b111110101 := by norm_num

-- (A8D)₁₆ → 2진: 각 자리를 4비트로
-- A→1010, 8→1000, D→1101 → (1010 1000 1101)₂
example : 0xA8D = 0b101010001101 := by norm_num
```

---

## 7C.6 **나머지 지수승**(Modular Exponentiation)

### 7C.6.1 교재의 설명 (4.2.4절)

암호학에서 bⁿ mod m을 효율적으로 계산하는 것은 매우 중요하다. 직접 bⁿ을 계산하면 엄청나게 큰 수가 되지만, **중간에 mod를 적용**하면 수를 작게 유지할 수 있다.

핵심 아이디어: 지수 n을 2진 전개하여, **반복 제곱법**(repeated squaring)으로 계산한다.

### 7C.6.2 교재 예제 12: 3⁶⁴⁴ mod 645 (알고리즘 5)

이 예제는 매우 큰 지수승을 효율적으로 계산하는 방법을 보여준다.

```lean
-- Lean4는 내장 함수로 이것을 바로 계산할 수 있다!
-- Nat.mod을 이용하면 중간 결과가 자동으로 작아진다
-- (Lean4의 내부 구현이 효율적이다)

-- 하지만 직접 반복 제곱법을 구현해 보자:
def modPow (b : ℕ) (n : ℕ) (m : ℕ) : ℕ :=
  if m = 0 then 0
  else if n = 0 then 1 % m
  else
    have : n / 2 < n := Nat.div_lt_self (by omega) (by omega)
    let half := modPow b (n / 2) m
    let sq := (half * half) % m
    if n % 2 = 1 then (sq * b) % m
    else sq

-- 테스트: 3⁶⁴⁴ mod 645
#eval modPow 3 644 645    -- 결과: 36

-- 검증: 교재의 답과 일치
example : modPow 3 644 645 = 36 := by native_decide
```

### 7C.6.3 단계별 설명 (알고리즘 5의 원리)

644의 2진 전개: 644 = (1010000100)₂

알고리즘은 다음과 같이 작동한다:
1. b mod m = 3 mod 645 = 3 (power)
2. 2진 전개를 오른쪽부터 왼쪽으로 스캔
3. 각 비트가 1이면: x = (x × power) mod m
4. 매 단계: power = (power × power) mod m

---

## 7C.7 연습 세트: 진법 전환과 나머지 지수승

### 연습 7C.1: 2진수 → 10진수 (중간 괄호)

```lean
-- (10110)₂의 10진 값은?
example : 1*16 + 0*8 + 1*4 + 1*2 + 0*1 = _ := by norm_num   -- 🔲
```

<details>
<summary>💡 답 보기</summary>

```lean
example : 1*16 + 0*8 + 1*4 + 1*2 + 0*1 = 22 := by norm_num
```

</details>

### 연습 7C.2: 10진수 → 2진수 (중간 괄호)

```lean
-- (37)₁₀의 2진 전개를 구하고 검증하라
-- 37 / 2 = 18 나머지 1
-- 18 / 2 = 9 나머지 0
-- 9 / 2 = 4 나머지 1
-- 4 / 2 = 2 나머지 0
-- 2 / 2 = 1 나머지 0
-- 1 / 2 = 0 나머지 1
-- 역순: (100101)₂
example : 0b100101 = _ := by norm_num   -- 🔲
```

<details>
<summary>💡 답 보기</summary>

```lean
example : 0b100101 = 37 := by norm_num
```

</details>

### 연습 7C.3: 8진수 → 10진수 (sorry)

```lean
-- (572)₈의 10진 값
example : 0o572 = _ := by sorry   -- 🔲
```

<details>
<summary>💡 답 보기</summary>

```lean
example : 0o572 = 378 := by norm_num
-- 5×64 + 7×8 + 2 = 320 + 56 + 2 = 378
```

</details>

### 연습 7C.4: 16진수 → 10진수 (sorry)

```lean
-- (1AE)₁₆의 10진 값
-- 1×256 + A(10)×16 + E(14)×1
example : 0x1AE = _ := by sorry   -- 🔲
```

<details>
<summary>💡 답 보기</summary>

```lean
example : 0x1AE = 430 := by norm_num
-- 1×256 + 10×16 + 14 = 256 + 160 + 14 = 430
```

</details>

### 연습 7C.5: 진법 간 전환 확인 (sorry)

```lean
-- (ABBA)₁₆ = (?)₈ 인지 확인
-- 먼저 10진 값을 구하고, 8진 값과 비교
-- 힌트: #eval 0xABBA 와 #eval 0o125672 를 비교해 보라
example : 0xABBA = 0o125672 := by sorry
```

<details>
<summary>💡 답 보기</summary>

```lean
-- 0xABBA = 43962
-- 43962를 8진으로: 43962 / 8 = 5495 r 2, 5495/8 = 686 r 7, ...
-- #eval 0o125672 = 43962
example : 0xABBA = 0o125672 := by norm_num
```

</details>

### 연습 7C.6: 나머지 지수승 (sorry)

```lean
-- 교재 연습문제 25: 7⁶⁴⁴ mod 645를 구하라
-- #eval modPow 7 644 645 로 먼저 답을 확인하라
example : modPow 7 644 645 = _ := by sorry   -- 🔲
```

<details>
<summary>💡 답 보기</summary>

```lean
-- #eval modPow 7 644 645 → 결과 확인 후 입력
-- (실제 Lean4 환경에서 #eval로 확인 필요)
-- 여기서는 native_decide로 검증
example : modPow 7 644 645 = 436 := by native_decide
```

</details>

### 연습 7C.7: 2진수 덧셈 (중간 괄호)

```lean
-- 교재 예제 8: (1110)₂ + (1011)₂ = ?
-- 일반 덧셈으로 계산:
example : 0b1110 + 0b1011 = _ := by norm_num   -- 🔲
-- 결과를 2진수로 확인: 어떤 2진수와 같은가?
```

<details>
<summary>💡 답 보기</summary>

```lean
example : 0b1110 + 0b1011 = 25 := by norm_num
-- 14 + 11 = 25
-- 25 = (11001)₂
-- 확인: #eval 0b11001 = 25
example : 0b1110 + 0b1011 = 0b11001 := by norm_num
```

</details>

### 연습 7C.8: 2진수 곱셈 (sorry)

```lean
-- 교재 예제 10: (110)₂ × (101)₂ = ?
example : 0b110 * 0b101 = _ := by sorry   -- 🔲
```

<details>
<summary>💡 답 보기</summary>

```lean
example : 0b110 * 0b101 = 30 := by norm_num
-- 6 × 5 = 30
-- 30 = (11110)₂
example : 0b110 * 0b101 = 0b11110 := by norm_num
```

</details>

---

## 7C.8 Lean4 진법 관련 기능 요약

| 표기 | 의미 | 예시 |
|------|------|------|
| `0b...` | 2진수 리터럴 | `0b1101 = 13` |
| `0o...` | 8진수 리터럴 | `0o17 = 15` |
| `0x...` | 16진수 리터럴 | `0xFF = 255` |
| `n / b` | 나눗셈의 몫 | `17 / 3 = 5` |
| `n % b` | 나눗셈의 나머지 | `17 % 3 = 2` |
| `#eval` | 식의 값 계산 | `#eval 0xABBA` |

---

## 7C.9 전술 요약

### 새로운 전술 & 개념

| 전술/개념 | 용도 | 예시 |
|---------|------|------|
| `0b`, `0o`, `0x` | 2/8/16진 리터럴 | `0b1010 = 10` |
| `native_decide` | 계산 가능한 명제를 결정 | 큰 수의 등식 검증 |
| `def ... : ... :=` | 재귀 함수 정의 | `def modPow ...` |
| `have : ... := ...` | 종료 힌트 (재귀) | `have : n / b < n := ...` |

### 이전 장 전술 (복습)

| 전술 | 최초 등장 |
|------|---------|
| `norm_num` | Part 7-A |
| `use`, `obtain` | Part 7-A |
| `rw`, `ring`, `omega` | Part 4-5 |

---

## 7C.10 핵심 정리 요약

1. **밑 b 전개**: 모든 양의 정수는 밑 b를 사용하여 유일하게 표현 가능

2. **밑수 전환**: 반복적으로 b로 나누어 나머지를 역순으로 읽기

3. **진법 간 관계**: 8진 1자리 = 2진 3자리, 16진 1자리 = 2진 4자리

4. **나머지 지수승**: 반복 제곱법으로 bⁿ mod m을 O(log n) 곱셈으로 계산

5. **2진수 연산**: 자리올림(carry)을 이용한 덧셈, 분배법칙을 이용한 곱셈

---

## 다음 편(7-D) 예고

**제7-D편**에서는 교재 4.3절 이후의 내용을 다룬다:
- **소수**(primes)와 합성수
- **최대공약수**(GCD)와 **유클리드 알고리즘**
- **대수학의 기본 정리**: 유일한 소인수분해
- Lean4에서 Nat.Prime, Nat.gcd 사용하기

---

**(끝)**
