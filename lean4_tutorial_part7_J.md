# Lean4 μ™„μ „ μ •λ³µ κ°€μ΄λ“ β€” μ 7-JνΈ

## **μ•”νΈν•™ μ…λ¬Έ**(Introduction to Cryptography) β€” **κ³ μ „ μ•”νΈ**(Classical Ciphers) μ™„μ „ μ •λ³µ

> **κµμ¬**: Kenneth H. Rosen, "Discrete Mathematics and Its Applications" 8ν, 4.6.1~4.6.2μ   
> **μ°Έκ³ **: γ€Mathematics in Leanγ€ Chapter 5 Elementary Number Theory  
> **μ„ μ ν•™μµ**: μ 7-A~7-IνΈ (κ°€λ¶„μ„±, ν•©λ™, GCD, νλ¥΄λ§ μ •λ¦¬, κ²€μ‚¬μ«μ)

---

## 7J.0 μ΄ μ¥μ λ©ν‘

μ΄ μ¥μ—μ„ λ°°μΈ λ‚΄μ©μ€ λ‹¤μκ³Ό κ°™λ‹¤:

1. **μ•”νΈν•™**(cryptography)μ΄λ€ λ¬΄μ—‡μΈκ°€ β€” μ •λ³΄λ¥Ό μ•μ „ν•κ² λ³€ν™ν•λ” ν•™λ¬Έ
2. **μΉ΄μ΄μ‚¬λ¥΄ μ•”νΈ**(Caesar cipher): κ°€μ¥ μ¤λλ μ•”νΈ λ°©μ‹
3. **μλ¦¬μ΄λ™ μ•”νΈ**(shift cipher): μΉ΄μ΄μ‚¬λ¥΄ μ•”νΈμ μΌλ°ν™”
4. **μ•„ν•€ μ•”νΈ**(affine cipher): κ³±μ…κ³Ό λ§μ…μ„ κ²°ν•©ν• μ•”νΈ
5. **μ•”νΈν•΄λ…**(cryptanalysis): λΉλ„ λ¶„μ„μΌλ΅ μ•”νΈλ¥Ό κΉ¨λ” λ°©λ²•
6. **λΈ”λ΅ μ•”νΈ**(block cipher)μ™€ **μ „μΉμ•”νΈ**(transposition cipher)
7. **μ•”νΈμ‹μ¤ν…**(cryptosystem)μ μν•™μ  μ •μ
8. Lean4λ΅ μ•”νΈν™”/ν•΄λ… ν•¨μλ¥Ό κµ¬ν„ν•κ³  κ²€μ¦ν•κΈ°

μ΄ μ¥μ€ μ΄μ „κΉμ§€ λ°°μ΄ **ν•©λ™**(congruence), **λ‚λ¨Έμ§€ μ‚°μ **(modular arithmetic), **λ¨λ“λ¬ μ—­μ›**(modular inverse) λ“±μ κ°λ…μ΄ μ‹¤μ λ΅ μ–΄λ–»κ² ν™μ©λλ”μ§€ λ³΄μ—¬μ£Όλ” μ¥μ΄λ‹¤. μν•™μ΄ μ‹¤μƒν™μ—μ„ μ •λ³΄λ¥Ό λ³΄νΈν•λ” λ° ν•µμ‹¬μ μΈ μ—­ν• μ„ ν•λ‹¤λ” κ²ƒμ„ μ‹¤κ°ν•  μ μμ„ κ²ƒμ΄λ‹¤.

---

## 7J.1 **μ•”νΈν•™**(Cryptography)μ΄λ€?

### 7J.1.1 μ•”νΈν•™μ μ •μ

**μ•”νΈν•™**(cryptography)μ€ μ •λ³΄λ¥Ό **λ³€ν•**(transform)ν•μ—¬, νΉλ³„ν• μ§€μ‹ μ—†μ΄λ” μ›λ¬Έμ λ³µμ›μ„ μ‰½κ² ν•  μ μ—†λ„λ΅ ν•λ” ν•™λ¬Έμ΄λ‹¤.

μΌμƒμ μΈ λΉ„μ λ΅ μ„¤λ…ν•λ©΄:

- λ„μ™€ μΉκµ¬κ°€ λΉ„λ°€ μ½μ§€λ¥Ό μ£Όκ³ λ°›κ³  μ‹¶λ‹¤κ³  ν•μ.
- λ„κµ°κ°€ μ½μ§€λ¥Ό κ°€λ΅μ±„λ”λΌλ„ λ‚΄μ©μ„ μ• μ μ—†κ² ν•κ³  μ‹¶λ‹¤.
- μ΄λ• μ½μ§€μ λ‚΄μ©μ„ **μ•”νΈν™”**(encryption)ν•μ—¬ λ³΄λ‚΄κ³ , μΉκµ¬λ” **ν•΄λ…**(decryption)ν•μ—¬ μ½λ”λ‹¤.

### 7J.1.2 ν•µμ‹¬ μ©μ–΄

| μ©μ–΄ | ν•κΈ€ | μλ¬Έ | μλ―Έ |
|------|------|------|------|
| **ν‰λ¬Έ** | ν‰λ¬Έ | plaintext | μ•”νΈν™”ν•κΈ° μ „μ μ›λ λ©”μ‹μ§€ |
| **μ•”νΈλ¬Έ** | μ•”νΈλ¬Έ | ciphertext | μ•”νΈν™”λ ν›„μ λ©”μ‹μ§€ |
| **μ•”νΈν™”** | μ•”νΈν™” | encryption | ν‰λ¬Έμ„ μ•”νΈλ¬ΈμΌλ΅ λ³€ν™ν•λ” κ³Όμ • |
| **ν•΄λ…** | ν•΄λ… | decryption | μ•”νΈλ¬Έμ„ ν‰λ¬ΈμΌλ΅ λλλ¦¬λ” κ³Όμ • |
| **ν‚¤** | ν‚¤ | key | μ•”νΈν™”/ν•΄λ…μ— μ‚¬μ©ν•λ” λΉ„λ°€ μ •λ³΄ |

### 7J.1.3 μ—­μ‚¬μ  λ°°κ²½

μ •μλ΅ μ€ μ•”νΈν•™μ—μ„ μ¤‘μ”ν• μ—­ν• μ„ ν•λ‹¤. κ³ μ „μ μΈ μ•”νΈλ” μμ² λ…„ μ „μ— μ²μ μ‚¬μ©λμ—κ³ , 20μ„ΈκΈ°κΉμ§€λ” λ„λ¦¬ μ‚¬μ©λμ—λ‹¤. μ΄ μ•”νΈμ—μ„ λ©”μ‹μ§€λ” κ° κΈ€μλ¥Ό λ‹¤λ¥Έ κΈ€μλ΅ λ°”κΎΈκ±°λ‚, ν• λΈ”λ΅μ κΈ€μλ“¤μ„ λ‹¤λ¥Έ κΈ€μλ“¤μ λΈ”λ΅μΌλ΅ λ°”κΎΈμ–΄ **μ•”νΈν™”**(encryption)ν•λ‹¤.

ν„λ€μ—λ” **κ³µκ°ν‚¤ μ•”νΈ**(public key cryptography)κ°€ λ“±μ¥ν•μ—¬, μ•”νΈν™”μ™€ ν•΄λ…μ— μ„λ΅ λ‹¤λ¥Έ ν‚¤λ¥Ό μ‚¬μ©ν•λ‹¤. μ΄ λ‚΄μ©μ€ λ‹¤μ νΈ(7-K)μ—μ„ λ‹¤λ£¬λ‹¤.

---

## 7J.2 κΈ€μμ™€ μ«μμ λ€μ‘ β€” **β„¤β‚‚β‚†**(Z mod 26)

### 7J.2.1 μ•νλ²³μ„ μ«μλ΅

μ•”νΈλ¥Ό μν•™μ μΌλ΅ λ‹¤λ£¨λ ¤λ©΄, λ¨Όμ € **μ•νλ²³ κΈ€μλ¥Ό μ«μλ΅ λ€μΉ**ν•΄μ•Ό ν•λ‹¤.

| κΈ€μ | A | B | C | D | E | F | G | H | I | J | K | L | M |
|------|---|---|---|---|---|---|---|---|---|---|---|---|---|
| μ«μ | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |

| κΈ€μ | N | O | P | Q | R | S | T | U | V | W | X | Y | Z |
|------|---|---|---|---|---|---|---|---|---|---|---|---|---|
| μ«μ | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 |

μ¦‰, **β„¤β‚‚β‚†**(Zβ‚‚β‚†, 0λ¶€ν„° 25κΉμ§€μ μ •μ)μ μ›μ†λ΅ κΈ€μλ¥Ό ν‘ν„ν•λ‹¤.

### 7J.2.2 Lean4 κµ¬ν„

```lean
-- κΈ€μλ¥Ό μ«μλ΅ λ³€ν™
def charToNum (c : Char) : Nat :=
  if 'A' β‰¤ c β§ c β‰¤ 'Z' then c.toNat - 'A'.toNat
  else if 'a' β‰¤ c β§ c β‰¤ 'z' then c.toNat - 'a'.toNat
  else 0  -- μ•νλ²³μ΄ μ•„λ‹ λ¬Έμλ” 0μΌλ΅ μ²λ¦¬

-- μ«μλ¥Ό κΈ€μλ΅ λ³€ν™
def numToChar (n : Nat) : Char :=
  Char.ofNat ('A'.toNat + n % 26)

-- ν™•μΈ
#eval charToNum 'A'   -- 0
#eval charToNum 'Z'   -- 25
#eval charToNum 'M'   -- 12
#eval numToChar 0     -- 'A'
#eval numToChar 25    -- 'Z'
#eval numToChar 12    -- 'M'
```

### 7J.2.3 μ™ 26μΈκ°€?

μμ–΄ μ•νλ²³μ΄ 26κΈ€μμ΄κΈ° λ•λ¬Έμ΄λ‹¤. λ‹¤λ¥Έ μ–Έμ–΄μ μ•”νΈμ—μ„λ” λ‹¤λ¥Έ μλ¥Ό μ‚¬μ©ν•λ‹¤. ν•µμ‹¬μ€ **λ‚λ¨Έμ§€ μ‚°μ **(modular arithmetic)μ„ μ‚¬μ©ν•λ‹¤λ” κ²ƒμ΄λ‹¤. λ¨λ“  μ—°μ‚°μ€ **mod 26**μΌλ΅ μν–‰ν•λ‹¤.

```lean
-- λ¨λ“  μ—°μ‚°μ€ mod 26
-- μ: 23 + 5 = 28μ΄μ§€λ§, mod 26 = 2
#eval (23 + 5) % 26   -- 2 (= C)
-- μ¦‰, X(=23)μ—μ„ 5μΉΈ μ΄λ™ν•λ©΄ C(=2)κ°€ λλ‹¤
```

---

## 7J.3 **μΉ΄μ΄μ‚¬λ¥΄ μ•”νΈ**(Caesar Cipher)

### 7J.3.1 μ—­μ‚¬

μ•”νΈλ¥Ό κ°€μ¥ λ¨Όμ € μ‚¬μ©ν• μ‚¬λμΌλ΅λ” **μ¨λ¦¬μ°μ¤ μΉ΄μ΄μ‚¬λ¥΄**(Julius Caesar)κ°€ μλ‹¤. κ·Έλ” κ° κΈ€μλ¥Ό **3κΈ€μ λ’¤**μ— μλ” κΈ€μλ΅ λ°”κΎΈμ–΄ μ•”νΈλ¬Έμ„ λ§λ“¤μ—λ‹¤.

μλ¥Ό λ“¤λ©΄: Bλ” Eλ΅, Xλ” Aλ΅ λ³΄λ‚Έλ‹¤.

### 7J.3.2 μν•™μ  ν‘ν„

μΉ΄μ΄μ‚¬λ¥΄ μ•”νΈμ **μ•”νΈν™” ν•¨μ** *f*λ” λ‹¤μκ³Ό κ°™λ‹¤:

> **f(p) = (p + 3) mod 26**

μ—¬κΈ°μ„ pλ” ν‰λ¬Έμ κΈ€μμ— ν•΄λ‹Ήν•λ” μ«μ(0~25)μ΄λ‹¤.

**ν•΄λ… ν•¨μ** *fβ»ΒΉ*μ€:

> **fβ»ΒΉ(p) = (p - 3) mod 26**

μ¦‰, μ•”νΈλ¬Έμ—μ„ ν‰λ¬Έμ„ λ³µμ›ν•λ ¤λ©΄ κ° κΈ€μλ¥Ό μ•νλ²³ μ„Έ μΉΈ μ•μ λ¬Έμλ΅ λ°”κΎΈλ©΄ λλ‹¤.

### 7J.3.3 Lean4 κµ¬ν„

```lean
-- μΉ΄μ΄μ‚¬λ¥΄ μ•”νΈν™”
def caesarEncrypt (p : Nat) : Nat := (p + 3) % 26

-- μΉ΄μ΄μ‚¬λ¥΄ ν•΄λ…
def caesarDecrypt (c : Nat) : Nat := (c + 23) % 26
-- μ£Όμ: (c - 3) mod 26 λ€μ‹  (c + 23) mod 26 μ‚¬μ©
-- μ™? μμ—°μμ—μ„ λΊ„μ…μ€ μμκ°€ λ  μ μμ–΄μ„ μ„ν—ν•λ‹¤.
-- (c + 23) mod 26 = (c - 3 + 26) mod 26 = (c - 3) mod 26

-- ν™•μΈ
#eval caesarEncrypt 0    -- 3  (A β†’ D)
#eval caesarEncrypt 1    -- 4  (B β†’ E)
#eval caesarEncrypt 23   -- 0  (X β†’ A)
#eval caesarDecrypt 3    -- 0  (D β†’ A)
#eval caesarDecrypt 0    -- 23 (A β†’ X)
```

**μ™ (c - 3) λ€μ‹  (c + 23)μ„ μ“°λ”κ°€?**

Lean4μ—μ„ μμ—°μ(β„•)μ λΊ„μ…μ€ "0 μ•„λλ΅ λ‚΄λ ¤κ°€λ©΄ 0μ΄ λλ‹¤"λ” **μλ¦Ό λΊ„μ…**(truncated subtraction)μ΄λ‹¤. μλ¥Ό λ“¤μ–΄ `2 - 5 = 0`μ΄ λλ‹¤(μμκ°€ μ• λλ‹¤). κ·Έλμ„ `(1 - 3) % 26`μ€ `0 % 26 = 0`μ΄ λμ–΄ μλ»λ κ²°κ³Όκ°€ λ‚μ¨λ‹¤.

ν•΄κ²° λ°©λ²•: **mod 26μ—μ„ -3μ€ +23κ³Ό κ°™λ‹¤!** μ™λƒν•λ©΄ -3 + 26 = 23μ΄κΈ° λ•λ¬Έμ΄λ‹¤.

```lean
-- κ²€μ¦: μ•”νΈν™” ν›„ ν•΄λ…ν•λ©΄ μ›λλ΅ λμ•„μ¨λ‹¤
example : caesarDecrypt (caesarEncrypt 12) = 12 := by native_decide
-- M(=12)λ¥Ό μ•”νΈν™”ν•λ©΄ P(=15), Pλ¥Ό ν•΄λ…ν•λ©΄ M(=12)
```

### 7J.3.4 κµμ¬ μμ  1: MEET YOU IN THE PARK

> ν‰λ¬Έ "MEET YOU IN THE PARK"λ¥Ό μΉ΄μ΄μ‚¬λ¥΄ μ•”νΈλ¥Ό ν†µν•΄ λ§λ“¤μ–΄μ§„ μ•”νΈλ¬Έμ€ λ¬΄μ—‡μΈκ°€?

**ν’€μ΄**: λ¨Όμ € λ©”μ‹μ§€μ λ¬Έμλ¥Ό μ«μλ΅ λ°”κΎΌλ‹¤.

| κΈ€μ | M | E | E | T | Y | O | U | I | N | T | H | E | P | A | R | K |
|------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| μ«μ | 12 | 4 | 4 | 19 | 24 | 14 | 20 | 8 | 13 | 19 | 7 | 4 | 15 | 0 | 17 | 10 |

μ΄μ  κ° μ«μ pλ¥Ό f(p) = (p + 3) mod 26μΌλ΅ λ€μΉν•λ‹¤:

| μ›λ | 12 | 4 | 4 | 19 | 24 | 14 | 20 | 8 | 13 | 19 | 7 | 4 | 15 | 0 | 17 | 10 |
|------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| μ•”νΈν™” | 15 | 7 | 7 | 22 | 1 | 17 | 23 | 11 | 16 | 22 | 10 | 7 | 18 | 3 | 20 | 13 |

μ΄λ¥Ό λ‹¤μ‹ λ¬Έμλ΅ λ°”κΎΈλ©΄: **"PHHW BRX LQ WKH SDUN"**

```lean
-- Lean4λ΅ λ¬Έμμ—΄ λ‹¨μ„ μ•”νΈν™” ν•¨μ
def encryptString (f : Nat β†’ Nat) (msg : String) : String :=
  β¨msg.data.map fun c =>
    if 'A' β‰¤ c β§ c β‰¤ 'Z' then numToChar (f (charToNum c))
    else if 'a' β‰¤ c β§ c β‰¤ 'z' then numToChar (f (charToNum c))
    else cβ©

-- μΉ΄μ΄μ‚¬λ¥΄ μ•”νΈ μ μ©
#eval encryptString caesarEncrypt "MEETYOUINTHEPARK"
-- κ²°κ³Ό: "PHHWBRXLQWKHSDUN"
```

### 7J.3.5 μ¤‘κ°„ κ΄„νΈ μ±„μ°κΈ° μ—°μµ: μΉ΄μ΄μ‚¬λ¥΄ μ•”νΈ κ²€μ¦

```lean
-- λΉμΉΈμ„ μ±„μ›λΌ: μΉ΄μ΄μ‚¬λ¥΄ μ•”νΈλ΅ 'A'(=0)λ¥Ό μ•”νΈν™”ν•λ©΄?
example : caesarEncrypt 0 = _ := by native_decide   -- π”²

-- λΉμΉΈμ„ μ±„μ›λΌ: μΉ΄μ΄μ‚¬λ¥΄ μ•”νΈλ΅ 'Z'(=25)λ¥Ό μ•”νΈν™”ν•λ©΄?
example : caesarEncrypt 25 = _ := by native_decide  -- π”²
```

<details>
<summary>π’΅ λ‹µ λ³΄κΈ°</summary>

```lean
example : caesarEncrypt 0 = 3 := by native_decide    -- A β†’ D
example : caesarEncrypt 25 = 2 := by native_decide   -- Z β†’ C
-- (25 + 3) % 26 = 28 % 26 = 2
```

</details>

---

## 7J.4 **μλ¦¬μ΄λ™ μ•”νΈ**(Shift Cipher) β€” μΉ΄μ΄μ‚¬λ¥΄ μ•”νΈμ μΌλ°ν™”

### 7J.4.1 μ •μ

μΉ΄μ΄μ‚¬λ¥΄ μ•”νΈλ¥Ό **μΌλ°ν™”**ν•λ©΄, 3 λ€μ‹  **μ„μμ μ •μ k**λ§νΌ μ΄λ™ν•  μ μλ‹¤.

> **μ•”νΈν™”**: f(p) = (p + k) mod 26  
> **ν•΄λ…**: fβ»ΒΉ(c) = (c - k) mod 26

μ—¬κΈ°μ„ μ •μ kλ¥Ό **ν‚¤**(key)λΌκ³  ν•λ‹¤. μΉ΄μ΄μ‚¬λ¥΄ μ•”νΈλ” k = 3μΈ νΉμν• κ²½μ°μ΄λ‹¤.

### 7J.4.2 Lean4 κµ¬ν„

```lean
-- μΌλ° μλ¦¬μ΄λ™ μ•”νΈ
def shiftEncrypt (k : Nat) (p : Nat) : Nat := (p + k) % 26

-- ν•΄λ…: -k mod 26 = (26 - k % 26) mod 26
def shiftDecrypt (k : Nat) (c : Nat) : Nat := (c + 26 - k % 26) % 26

-- k = 3μ΄λ©΄ μΉ΄μ΄μ‚¬λ¥΄ μ•”νΈμ™€ λ™μΌ
example : shiftEncrypt 3 0 = caesarEncrypt 0 := by native_decide
example : shiftEncrypt 3 12 = caesarEncrypt 12 := by native_decide
```

### 7J.4.3 κµμ¬ μμ  2: k = 11λ΅ μλ¦¬μ΄λ™

> ν‚¤ k = 11λ΅ μλ¦¬μ΄λ™ μ•”νΈλ¥Ό μ‚¬μ©ν•μ—¬ ν‰λ¬Έ "STOP GLOBAL WARMING"μ„ μ•”νΈν™”ν•λΌ.

**ν’€μ΄**:

| κΈ€μ | S | T | O | P | G | L | O | B | A | L | W | A | R | M | I | N | G |
|------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| μ«μ | 18 | 19 | 14 | 15 | 6 | 11 | 14 | 1 | 0 | 11 | 22 | 0 | 17 | 12 | 8 | 13 | 6 |

κ° μμ— f(p) = (p + 11) mod 26μ„ μ μ©:

| μ›λ | 18 | 19 | 14 | 15 | 6 | 11 | 14 | 1 | 0 | 11 | 22 | 0 | 17 | 12 | 8 | 13 | 6 |
|------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| μ•”νΈν™” | 3 | 4 | 25 | 0 | 17 | 22 | 25 | 12 | 11 | 22 | 7 | 11 | 2 | 23 | 19 | 24 | 17 |

μ΄ λ¬Έμμ—΄μ„ κΈ€μλ΅ μ®κΈ°λ©΄: **"DEZA RWZMLW HLCXTYR"**

```lean
-- Lean4λ΅ ν™•μΈ
#eval shiftEncrypt 11 18   -- 3  (S β†’ D)
#eval shiftEncrypt 11 19   -- 4  (T β†’ E)
#eval shiftEncrypt 11 22   -- 7  (W β†’ H)
```

### 7J.4.4 κµμ¬ μμ  3: ν•΄λ…

> k = 7λ΅ μλ¦¬μ΄λ™ μ•”νΈλ΅ μ•”νΈν™”ν• μ•”νΈλ¬Έ "LEWLYPLUJL PZ H NYLHA ALHJOLY"λ¥Ό ν•΄λ…ν•λΌ.

**ν’€μ΄**: ν•΄λ… ν•¨μ fβ»ΒΉ(c) = (c - 7) mod 26 = (c + 19) mod 26μ„ μ μ©ν•λ‹¤.

```lean
#eval shiftDecrypt 7 11   -- 4  (L β†’ E)
#eval shiftDecrypt 7 4    -- 23 (E β†’ X)
#eval shiftDecrypt 7 22   -- 15 (W β†’ P)
-- ... μ „μ²΄λ¥Ό ν•΄λ…ν•λ©΄: "EXPERIENCE IS A GREAT TEACHER"
```

### 7J.4.5 μ—°μµ: μλ¦¬μ΄λ™ μ•”νΈ κµ¬ν„ (κ΄„νΈ μ±„μ°κΈ°)

```lean
-- λΉμΉΈμ„ μ±„μ›λΌ: k = 5λ΅ 'H'(= 7)λ¥Ό μ•”νΈν™”ν•λ©΄?
example : shiftEncrypt 5 7 = _ := by native_decide   -- π”²

-- λΉμΉΈμ„ μ±„μ›λΌ: k = 5λ΅ μ•”νΈν™”λ κΈ€μ 12λ¥Ό ν•΄λ…ν•λ©΄?
example : shiftDecrypt 5 12 = _ := by native_decide  -- π”²
```

<details>
<summary>π’΅ λ‹µ λ³΄κΈ°</summary>

```lean
example : shiftEncrypt 5 7 = 12 := by native_decide   -- H β†’ M
-- (7 + 5) % 26 = 12

example : shiftDecrypt 5 12 = 7 := by native_decide   -- M β†’ H
-- (12 + 26 - 5) % 26 = 33 % 26 = 7
```

</details>

### 7J.4.6 sorry μ—°μµ: μ•”νΈν™” ν›„ ν•΄λ… = μ›λ¬Έ

```lean
-- sorryλ¥Ό μ±„μ›λΌ: k = 11λ΅ μ•”νΈν™”ν• ν›„ ν•΄λ…ν•λ©΄ μ›λ κ°’μ΄ λμ•„μ΄μ„ ν™•μΈ
-- (κµ¬μ²΄μ μΈ κ°’μΌλ΅)
example : shiftDecrypt 11 (shiftEncrypt 11 18) = 18 := by sorry

-- μΌλ°μ  μ„±μ§: 0~25 λ²”μ„μ λ¨λ“  pμ— λ€ν•΄
-- (μ΄κ²ƒμ€ μΆ€ μ–΄λ µλ‹¤ β€” λ„μ „ λ¬Έμ !)
theorem shift_decrypt_encrypt (k p : Nat) (hp : p < 26) :
    shiftDecrypt k (shiftEncrypt k p) = p := by
  sorry
```

<details>
<summary>π’΅ λ‹µ λ³΄κΈ°</summary>

```lean
example : shiftDecrypt 11 (shiftEncrypt 11 18) = 18 := by native_decide

-- μΌλ°μ  μ¦λ…μ€ omegaλ‚ mod_cast μ „μ  μ΅°ν•©μ΄ ν•„μ”ν•λ‹¤.
-- κµ¬μ²΄μ  ν‚¤μ— λ€ν•΄μ„λ” decide/native_decideλ΅ κ²€μ¦ κ°€λ¥
-- μΌλ°μ  μ¦λ…:
-- shiftDecrypt k (shiftEncrypt k p)
-- = ((p + k) % 26 + 26 - k % 26) % 26
-- = (p + k + 26 - k) % 26   (mod 26 λ‚΄μ—μ„ k μƒμ‡„)
-- = (p + 26) % 26 = p       (p < 26μΌ λ•)
-- Lean4μ—μ„ μ΄λ¥Ό μ •ν™•ν μ¦λ…ν•λ ¤λ©΄ mod μ‚°μ  λ³΄μ΅°μ •λ¦¬κ°€ ν•„μ”ν•λ‹¤.
```

</details>

---

## 7J.5 **μ•”νΈν•΄λ…**(Cryptanalysis) β€” λΉλ„ λ¶„μ„

### 7J.5.1 μ•”νΈν•΄λ…μ΄λ€?

**μ•”νΈν•΄λ…**(cryptanalysis)μ€ μ•”νΈν™” λ°©λ²•κ³Ό ν‚¤λ¥Ό λ¨λ¥΄λ” μƒνƒμ—μ„ μ•”νΈλ¬ΈμΌλ΅λ¶€ν„° ν‰λ¬Έμ„ μ°Ύμ•„λ‚΄λ” κ³Όμ •μ΄λ‹¤. "μ½”λ“ κΉ¨κΈ°"(breaking codes)λΌκ³ λ„ ν•λ‹¤.

### 7J.5.2 μλ¦¬μ΄λ™ μ•”νΈ κΉ¨κΈ°: λΉλ„ λ¶„μ„

μλ¦¬μ΄λ™ μ•”νΈλ¥Ό κΉ¨λ” κΈ°λ³Έ λ°©λ²•μ€ **κΈ€μ λΉλ„**(frequency)λ¥Ό μ΄μ©ν•λ” κ²ƒμ΄λ‹¤.

μμ–΄μ—μ„ 9κ°μ κ°€μ¥ ν”ν• κΈ€μμ™€ μ΄ κΈ€μλ“¤μ μƒλ€μ μΈ λΉλ„λ” λ‹¤μκ³Ό κ°™λ‹¤:

| κΈ€μ | E | T | A | O | I | N | S | H | R |
|------|---|---|---|---|---|---|---|---|---|
| λΉλ„ | μ•½ 13% | 9% | 8% | 8% | 7% | 7% | 7% | 6% | 6% |

**μ „λµ**: μ•”νΈλ¬Έμ—μ„ κ°€μ¥ μμ£Ό λ‚νƒ€λ‚λ” κΈ€μκ°€ ν‰λ¬Έμ Eλ¥Ό μ•”νΈν™”ν• κ²ƒμ΄λΌκ³  κ°€μ •ν•λ‹¤. κ·Έλ¬λ©΄ ν‚¤ kλ¥Ό μ¶”μ •ν•  μ μλ‹¤.

### 7J.5.3 κµμ¬ μμ  5: λΉλ„ λ¶„μ„μΌλ΅ ν•΄λ…

> μ•”νΈλ¬Έ "ZNK KGXRE HOXJ MKZY ZNK CUXS"λ¥Ό μ¤‘κ°„μ—μ„ κ°€λ΅μ±κ³ , μ΄ μ•”νΈλ¬Έμ΄ μλ¦¬μ΄λ™ μ•”νΈλ΅ λ§λ“¤μ–΄μ΅λ‹¤λ” κ²ƒμ„ μ•κ³  μλ‹¤. μ›λ¬Έμ€ λ¬΄μ—‡μΌκΉ?

**ν’€μ΄**:

1. μ•”νΈλ¬Έμ—μ„ κ°€μ¥ μμ£Ό λ‚νƒ€λ‚λ” κΈ€μλ¥Ό μ„Έλ©΄ **K**κ°€ κ°€μ¥ λΉλ²ν•λ‹¤.
2. ν‰λ¬Έμ Eκ°€ μ•”νΈλ¬Έμ Kλ΅ λ°”λ€μ—λ‹¤κ³  κ°€μ •ν•λ‹¤.
3. E = 4, K = 10μ΄λ―€λ΅ k = 10 - 4 = **6**μ΄λ‹¤.
4. κ° κΈ€μλ¥Ό -6λ§νΌ μλ¦¬μ΄λ™ν•λ©΄(= +20λ§νΌ):

"**THE EARLY BIRD GETS THE WORM**"

```lean
-- ν™•μΈ: K(=10)λ¥Ό k=6μΌλ΅ ν•΄λ…ν•λ©΄ E(=4)
#eval shiftDecrypt 6 10   -- 4 (E)
-- Z(=25)λ¥Ό ν•΄λ…ν•λ©΄ T(=19)
#eval shiftDecrypt 6 25   -- 19 (T)
```

### 7J.5.4 Lean4λ΅ λΉλ„ λ¶„μ„ κµ¬ν„

```lean
-- λ¬Έμμ—΄μ—μ„ κ° κΈ€μμ λΉλ„λ¥Ό μ„Έλ” ν•¨μ
def countLetters (msg : String) : Array Nat := Id.run do
  let mut counts := Array.mkArray 26 0
  for c in msg.data do
    if 'A' β‰¤ c β§ c β‰¤ 'Z' then
      let idx := c.toNat - 'A'.toNat
      counts := counts.set! idx (counts.get! idx + 1)
  return counts

-- κ°€μ¥ λΉλ²ν• κΈ€μμ μΈλ±μ¤λ¥Ό μ°Ύλ” ν•¨μ
def mostFrequent (counts : Array Nat) : Nat := Id.run do
  let mut maxIdx := 0
  let mut maxVal := 0
  for i in [:26] do
    if counts.get! i > maxVal then
      maxIdx := i
      maxVal := counts.get! i
  return maxIdx

-- λΉλ„ λ¶„μ„μΌλ΅ ν‚¤λ¥Ό μ¶”μ •
def guessKey (ciphertext : String) : Nat :=
  let counts := countLetters ciphertext
  let freqIdx := mostFrequent counts
  -- κ°€μ¥ λΉλ²ν• κΈ€μκ°€ E(=4)λ¥Ό μ•”νΈν™”ν• κ²ƒμ΄λΌκ³  κ°€μ •
  (freqIdx + 26 - 4) % 26

-- μμ  5 ν™•μΈ
#eval guessKey "ZNKKGXREHOXJMKZYZNKCUXS"
-- ν‚¤ μ¶”μ •κ°’μ΄ λ‚μ¨λ‹¤
```

---

## 7J.6 **μ•„ν•€ μ•”νΈ**(Affine Cipher)

### 7J.6.1 μλ¦¬μ΄λ™λ³΄λ‹¤ κ°•ν• μ•”νΈ

μλ¦¬μ΄λ™ μ•”νΈλ” ν‚¤κ°€ 26κ°λ°–μ— μ—†μ–΄μ„ (0~25) μ‰½κ² κΉ° μ μλ‹¤. λ³΄μ•μ„ μ•½κ°„ λ†’μ΄λ ¤λ©΄ **κ³±μ…**μ„ μ¶”κ°€ν•λ©΄ λλ‹¤.

### 7J.6.2 μ •μ

**μ•„ν•€ λ³€ν™**(affine transformation)μ€ λ‹¤μ ν•νƒμ ν•¨μμ΄λ‹¤:

> **f(p) = (ap + b) mod 26**

μ—¬κΈ°μ„ aμ™€ bλ” μ •μμ΄κ³ , **fκ°€ μ „λ‹¨μ‚¬ ν•¨μ**(bijection)κ°€ λλ ¤λ©΄ **gcd(a, 26) = 1**μ΄μ–΄μ•Ό ν•λ‹¤.

μ™ gcd(a, 26) = 1μ΄μ–΄μ•Ό ν•λ”κ°€? 7-EνΈμ—μ„ λ°°μ΄ κ²ƒμ²λΌ, **λ¨λ“λ¬ μ—­μ›**(modular inverse)μ΄ μ΅΄μ¬ν•λ ¤λ©΄ gcd(a, m) = 1μ΄μ–΄μ•Ό ν•λ‹¤. ν•΄λ…ν•  λ• aμ μ—­μ›μ΄ ν•„μ”ν•κΈ° λ•λ¬Έμ΄λ‹¤.

### 7J.6.3 ν•΄λ…

μ•”νΈλ¬Έ cμ—μ„ ν‰λ¬Έ pλ¥Ό λ³µμ›ν•λ ¤λ©΄:

1. c = ap + b (mod 26)μ—μ„ bλ¥Ό λΉΌλ©΄: c - b β‰΅ ap (mod 26)
2. μ–‘λ³€μ— aμ λ¨λ“λ¬ μ—­μ› Δλ¥Ό κ³±ν•λ©΄: Δ(c - b) β‰΅ p (mod 26)

λ”°λΌμ„:

> **fβ»ΒΉ(c) = Δ(c - b) mod 26**

μ—¬κΈ°μ„ Δλ” aμ λ¨λ“λ΅ 26μ— λ€ν• μ—­μ› (μ¦‰, Δa β‰΅ 1 (mod 26))μ΄λ‹¤.

### 7J.6.4 Lean4 κµ¬ν„

```lean
-- λ¨λ“λ¬ μ—­μ› (μ΄μ „ νΈμ—μ„ λ°°μ΄ κ²ƒ)
-- κ°„λ‹¨ν• λ°©λ²•: λΈλ£¨νΈ ν¬μ¤λ΅ μ°ΎκΈ°
def modInverse (a m : Nat) : Nat := Id.run do
  for i in [:m] do
    if (a * i) % m = 1 then return i
  return 0  -- μ—­μ›μ΄ μ—†λ” κ²½μ°

-- μ•„ν•€ μ•”νΈν™”
def affineEncrypt (a b : Nat) (p : Nat) : Nat := (a * p + b) % 26

-- μ•„ν•€ ν•΄λ…
def affineDecrypt (a b : Nat) (c : Nat) : Nat :=
  let ainv := modInverse a 26
  (ainv * (c + 26 - b % 26)) % 26

-- ν™•μΈ: gcd(7, 26) = 1μ΄λ―€λ΅ a = 7 μ‚¬μ© κ°€λ¥
#eval Nat.gcd 7 26   -- 1 β“
#eval modInverse 7 26  -- 15 (μ™λƒν•λ©΄ 7 Γ— 15 = 105 β‰΅ 1 (mod 26))
```

### 7J.6.5 κµμ¬ μμ  4: μ•„ν•€ μ•”νΈ

> ν•¨μ f(p) = (7p + 3) mod 26μ„ μ΄μ©ν•μ—¬ μ•”νΈν™”ν•  λ•, λ¬Έμ Kλ” μ–΄λ–¤ λ¬Έμλ΅ λ°”λ€λ”κ°€?

**ν’€μ΄**: Kμ— ν•΄λ‹Ήν•λ” μ«μλ” 10μ΄λ‹¤.

f(10) = (7 Γ— 10 + 3) mod 26 = 73 mod 26 = 21

21μ΄ λ‚νƒ€λ‚΄λ” κΈ€μλ” **V**μ΄λ―€λ΅ Kλ” μ•”νΈν™”λ λ©”μ‹μ§€μ—μ„ Vλ΅ λ°”λ€λ‹¤.

```lean
-- Lean4λ΅ ν™•μΈ
#eval affineEncrypt 7 3 10   -- 21 (K β†’ V)
-- (7 * 10 + 3) % 26 = 73 % 26 = 21

-- ν•΄λ… ν™•μΈ: V(=21)λ¥Ό ν•΄λ…ν•λ©΄ K(=10)κ°€ λ‚μ™€μ•Ό ν•λ‹¤
#eval affineDecrypt 7 3 21   -- 10 (V β†’ K) β“
```

### 7J.6.6 μ¤‘κ°„ κ΄„νΈ μ±„μ°κΈ°: μ•„ν•€ μ•”νΈ

```lean
-- λΉμΉΈμ„ μ±„μ›λΌ: f(p) = (5p + 8) mod 26μΌλ΅ 'A'(=0)λ¥Ό μ•”νΈν™”ν•λ©΄?
example : affineEncrypt 5 8 0 = _ := by native_decide   -- π”²

-- λΉμΉΈμ„ μ±„μ›λΌ: gcd(5, 26) = ?
example : Nat.gcd 5 26 = _ := by native_decide          -- π”²
```

<details>
<summary>π’΅ λ‹µ λ³΄κΈ°</summary>

```lean
example : affineEncrypt 5 8 0 = 8 := by native_decide   -- A β†’ I
-- (5 * 0 + 8) % 26 = 8

example : Nat.gcd 5 26 = 1 := by native_decide          -- μ„λ΅μ† β“
```

</details>

### 7J.6.7 sorry μ—°μµ: μ•„ν•€ μ•”νΈ κ²€μ¦

```lean
-- sorryλ¥Ό μ±„μ›λΌ
-- (1) a = 3, b = 7μΌ λ• gcd(a, 26) = 1μΈμ§€ ν™•μΈ
example : Nat.gcd 3 26 = 1 := by sorry

-- (2) a = 3, b = 7λ΅ 'M'(=12)λ¥Ό μ•”νΈν™”
example : affineEncrypt 3 7 12 = 17 := by sorry

-- (3) ν•΄λ…ν•λ©΄ λ‹¤μ‹ 12κ°€ λ‚μ¤λ”μ§€ ν™•μΈ
example : affineDecrypt 3 7 17 = 12 := by sorry
```

<details>
<summary>π’΅ λ‹µ λ³΄κΈ°</summary>

```lean
example : Nat.gcd 3 26 = 1 := by native_decide
example : affineEncrypt 3 7 12 = 17 := by native_decide
-- (3 * 12 + 7) % 26 = 43 % 26 = 17 (= R)
example : affineDecrypt 3 7 17 = 12 := by native_decide
-- modInverse 3 26 = 9 (3*9=27β‰΅1), 9*(17+26-7)%26 = 9*36%26 = 324%26 = 12
```

</details>

### 7J.6.8 μ–΄λ–¤ a κ°’μ΄ μ ν¨ν•κ°€?

gcd(a, 26) = 1μΈ aλ§ μ•„ν•€ μ•”νΈμ ν‚¤λ΅ μ‚¬μ©ν•  μ μλ‹¤. 26 = 2 Γ— 13μ΄λ―€λ΅, aλ” 2μ λ°°μλ„ μ•„λ‹κ³  13μ λ°°μλ„ μ•„λ‹μ–΄μ•Ό ν•λ‹¤.

μ ν¨ν• a κ°’(1~25 μ¤‘): 1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, 25 β†’ **12κ°**

λ”°λΌμ„ μ•„ν•€ μ•”νΈμ κ°€λ¥ν• ν‚¤μ μ: 12 Γ— 26 = **312κ°** (μλ¦¬μ΄λ™ μ•”νΈμ 26κ°λ³΄λ‹¤ ν›¨μ”¬ λ§λ‹¤)

```lean
-- μ ν¨ν• a κ°’ ν™•μΈ
#eval (List.range 26).filter (fun a => Nat.gcd a 26 == 1)
-- [1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, 25]
```

---

## 7J.7 **μ•”νΈμ‹μ¤ν…**(Cryptosystem)μ μν•™μ  μ •μ

### 7J.7.1 κµμ¬ μ •μ 1

> **μ •μ 1** (Rosen 4.6μ ):  
> **μ•”νΈμ‹μ¤ν…**(cryptosystem)μ€ 5-**νν”**(tuple) (π’«, π’, π’¦, β„°, π’)μ΄λ‹¤.  
> - π’«λ” **ν‰λ¬Έ λ¬Έμμ—΄μ μ§‘ν•©**(set of plaintext strings)  
> - π’λ” **μ•”νΈλ¬Έ λ¬Έμμ—΄μ μ§‘ν•©**(set of ciphertext strings)  
> - π’¦λ” **ν‚¤ κ³µκ°„**(key space, λ¨λ“  κ°€λ¥ν• ν‚¤μ μ§‘ν•©)  
> - β„°λ” **μ•”νΈν™” ν•¨μμ μ§‘ν•©**(set of encryption functions)  
> - π’λ” **ν•΄λ… ν•¨μμ μ§‘ν•©**(set of decryption functions)  
>  
> ν‚¤ kμ— λ€μ‘ν•λ” β„°μ μ›μ†μΈ μ•”νΈν™” ν•¨μλ¥Ό E_kλΌ ν•κ³ , D_kλ” E_kλ΅ μ•”νΈν™”λ μ•”νΈλ¬Έμ„ ν•΄λ…ν•λ” π’μ μ›μ†μΈ ν•΄λ… ν•¨μλ¥Ό λ‚νƒ€λ‚Έλ‹¤. μ¦‰, λ¨λ“  ν‰λ¬Έ λ¬Έμμ—΄ pμ— λ€ν•΄ D_k(E_k(p)) = pμ΄λ‹¤.

μ‰½κ² λ§ν•΄, μ•”νΈμ‹μ¤ν…μ€ "ν‰λ¬Έμ„ μ•”νΈλ¬ΈμΌλ΅ λ°”κΎΈκ³ , λ‹¤μ‹ μ›λλ΅ λλλ¦΄ μ μλ” μ²΄κ³„"μ΄λ‹¤.

### 7J.7.2 κµμ¬ μμ  7: μλ¦¬μ΄λ™ μ•”νΈλ¥Ό μ•”νΈμ‹μ¤ν…μΌλ΅

μλ¦¬μ΄λ™ μ•”νΈμ μ•”νΈμ‹μ¤ν…:
- π’« = π’ = β„¤β‚‚β‚†μ μ›μ†λ΅ λ§λ“¤μ–΄μ§„ λ¬Έμμ—΄μ μ§‘ν•©
- π’¦ = β„¤β‚‚β‚† (κ°€λ¥ν• μ΄λ™μ μ§‘ν•©)
- β„° = {E_k : E_k(p) = (p + k) mod 26} ν•νƒμ ν•¨μλ“¤
- π’ = {D_k : D_k(c) = (c - k) mod 26} ν•νƒμ ν•¨μλ“¤

**ν•µμ‹¬ μ„±μ§**: D_k(E_k(p)) = p β€” μ•”νΈν™”ν• κ²ƒμ„ ν•΄λ…ν•λ©΄ μ›λλ΅ λμ•„μ¨λ‹¤.

### 7J.7.3 Lean4μ—μ„ μ•”νΈμ‹μ¤ν…μ ν•µμ‹¬ μ„±μ§ κ²€μ¦

```lean
-- μλ¦¬μ΄λ™ μ•”νΈμ ν•µμ‹¬ μ„±μ§: κµ¬μ²΄μ  κ°’μΌλ΅ ν™•μΈ
-- k = 11, p = 18 (S)
example : shiftDecrypt 11 (shiftEncrypt 11 18) = 18 := by native_decide

-- k = 7, p = 4 (E)
example : shiftDecrypt 7 (shiftEncrypt 7 4) = 4 := by native_decide

-- μ•„ν•€ μ•”νΈμ ν•µμ‹¬ μ„±μ§: a = 7, b = 3, p = 10 (K)
example : affineDecrypt 7 3 (affineEncrypt 7 3 10) = 10 := by native_decide
```

---

## 7J.8 **λΈ”λ΅ μ•”νΈ**(Block Cipher)μ™€ **μ „μΉμ•”νΈ**(Transposition Cipher)

### 7J.8.1 λ¬Έμ μ•”νΈ vs λΈ”λ΅ μ•”νΈ

μ§€κΈκΉμ§€ λ°°μ΄ μλ¦¬μ΄λ™ μ•”νΈμ™€ μ•„ν•€ μ•”νΈλ” **κ° κΈ€μλ¥Ό ν•λ‚μ”© λ…λ¦½μ μΌλ΅** λ°”κΎΈλ” λ°©μ‹μ΄λ‹¤. μ΄λ° μ•”νΈλ¥Ό **λ¬Έμ μ•”νΈ**(character cipher) λλ” **λ‹¨μΌμ μ•”νΈ**(monoalphabetic cipher)λΌ λ¶€λ¥Έλ‹¤.

μ΄λ° λ°©μ‹μ€ **λΉλ„ λ¶„μ„μ— μ·¨μ•½**ν•λ‹¤. λ” κ°•ν•κ² λ§λ“¤λ ¤λ©΄ **ν• λΈ”λ΅μ κΈ€μλ“¤μ„ ν•κΊΌλ²μ—** λ°”κΎΈμ–΄μ•Ό ν•λ‹¤. μ΄λ° μ•”νΈλ¥Ό **λΈ”λ΅ μ•”νΈ**(block cipher)λΌ λ¶€λ¥Έλ‹¤.

### 7J.8.2 μ „μΉμ•”νΈ(Transposition Cipher)

**μ „μΉμ•”νΈ**(transposition cipher)λ” κΈ€μ μμ²΄λ¥Ό λ°”κΎΈλ” κ²ƒμ΄ μ•„λ‹λΌ, **κΈ€μλ“¤μ μμ„λ¥Ό μ¬λ°°μ—΄**ν•λ” λ°©μ‹μ΄λ‹¤.

ν‚¤λ΅λ” μ–΄λ–¤ μ–‘μ μ •μ mμ— λ€ν• μ§‘ν•© {1, 2, ..., m}μ **μμ—΄**(permutation) Οƒλ¥Ό μ‚¬μ©ν•λ‹¤.

**μ•”νΈν™” κ³Όμ •**:
1. λ©”μ‹μ§€λ¥Ό ν¬κΈ° mμ λΈ”λ΅μΌλ΅ λ‚λλ‹¤.
2. κ° λΈ”λ΅ pβ‚pβ‚‚...pβ‚μ„ p_Οƒ(1) p_Οƒ(2) ... p_Οƒ(m)μΌλ΅ μ•”νΈν™”ν•λ‹¤.

**ν•΄λ… κ³Όμ •**:
- Οƒμ **μ—­**(inverse) Οƒβ»ΒΉμ„ μ‚¬μ©ν•λ‹¤.

### 7J.8.3 κµμ¬ μμ  6: μ „μΉμ•”νΈ

> Οƒ(1) = 3, Οƒ(2) = 1, Οƒ(3) = 4, Οƒ(4) = 2μΈ μ§‘ν•© {1, 2, 3, 4}μ μμ—΄ Οƒμ— κΈ°λ°ν• μ „μΉμ•”νΈλ¥Ό μ‚¬μ©ν•μ—¬:
> (a) ν‰λ¬Έ PIRATE ATTACKμ„ μ•”νΈν™”ν•λΌ.
> (b) μ „μΉμ•”νΈλ΅ μ•”νΈν™”ν• μ•”νΈλ¬Έ SWUE TRAE OEHSλ¥Ό ν•΄λ…ν•λΌ.

**ν’€μ΄ (a)**:

ν‰λ¬Έμ„ λ„¤ κΈ€μμ”©μ λΈ”λ΅μΌλ΅ λ‚λ„μ: **PIRA | TEAT | TACK**

| μ„μΉ | 1 | 2 | 3 | 4 |
|------|---|---|---|---|
| Οƒ | 3 | 1 | 4 | 2 |

κ° λΈ”λ΅μ„ μ•”νΈν™”ν•λ©΄:
- PIRA: Οƒ(1)=3λ²μ§Έ, Οƒ(2)=1λ²μ§Έ, Οƒ(3)=4λ²μ§Έ, Οƒ(4)=2λ²μ§Έ β†’ R, P, A, I β†’ **RPAI** 
  
  μ•„, μ κΉ. μΆ€ λ” μ •ν™•ν ν•μ:
  - μƒλ΅μ΄ μ„μΉ 1μ—λ” μ›λ μ„μΉ Οƒ(1)=3μ κΈ€μκ°€ μ¨λ‹¤: **R**
  - μƒλ΅μ΄ μ„μΉ 2μ—λ” μ›λ μ„μΉ Οƒ(2)=1μ κΈ€μκ°€ μ¨λ‹¤: **P**
  
  μ΄κ²ƒλ„ ν•΄μ„μ΄ μ΅°κΈ ν—·κ°λ¦΄ μ μλ‹¤. κµμ¬μ μ •μλ¥Ό λ”°λ¥΄λ©΄:
  
  λΈ”λ΅ cβ‚cβ‚‚...cβ‚μ—μ„ cβ±Ό = p_Οƒ(j)μ΄λ‹¤. μ¦‰:
  - μƒ μ„μΉ 1μ κΈ€μ = μ›λ μ„μΉ Οƒ(1) = 3μ κΈ€μ = R
  - μƒ μ„μΉ 2μ κΈ€μ = μ›λ μ„μΉ Οƒ(2) = 1μ κΈ€μ = P  
  
  μ•„λ‹™λ‹λ‹¤. κµμ¬ μ›λ¬Έμ„ λ‹¤μ‹ λ³΄λ©΄: "μ°λ¦¬λ” λΈ”λ΅ pβ‚pβ‚‚ ... pβ‚μ„ cβ‚cβ‚‚ ... cβ‚ = p_Οƒ(1) p_Οƒ(2) ... p_Οƒ(m)μΌλ΅ μ•”νΈν™”ν•λ‹¤."
  
  μ¦‰ PIRA λΈ”λ΅μ—μ„:
  - cβ‚ = p_Οƒ(1) = pβ‚ƒ = R
  - cβ‚‚ = p_Οƒ(2) = pβ‚ = P
  - cβ‚ƒ = p_Οƒ(3) = pβ‚„ = A
  - cβ‚„ = p_Οƒ(4) = pβ‚‚ = I

  κ²°κ³Ό: **RPAI**

κ°™μ€ λ°©λ²•μΌλ΅:
- TEAT: pβ‚ƒ=A, pβ‚=T, pβ‚„=T, pβ‚‚=E β†’ **ATTE**... 

  μ•„, λ‹¤μ‹ κ³„μ‚°ν•μ:
  - cβ‚ = p_Οƒ(1) = pβ‚ƒ = A
  - cβ‚‚ = p_Οƒ(2) = pβ‚ = T
  - cβ‚ƒ = p_Οƒ(3) = pβ‚„ = T
  - cβ‚„ = p_Οƒ(4) = pβ‚‚ = E
  κ²°κ³Ό: **ATTE**

- TACK: pβ‚ƒ=C, pβ‚=T, pβ‚„=K, pβ‚‚=A β†’ **CTKA**

  μ•„λ‹™λ‹λ‹¤:
  - cβ‚ = p_Οƒ(1) = pβ‚ƒ = C
  - cβ‚‚ = p_Οƒ(2) = pβ‚ = T  
  - cβ‚ƒ = p_Οƒ(3) = pβ‚„ = K
  - cβ‚„ = p_Οƒ(4) = pβ‚‚ = A
  κ²°κ³Ό: **CTKA**

  ν•μ§€λ§ κµμ¬ λ‹µμ€ **IAPR ETTA AKTC**λΌκ³  ν•λ‹¤. λ‹¤μ‹ ν™•μΈν•μ.

κµμ¬: "μ²« λ²μ§Έ κΈ€μλ” μ„Έ λ²μ§Έλ΅, λ‘ λ²μ§Έ κΈ€μλ” μ²« λ²μ§Έλ΅, μ„Έ λ²μ§Έ κΈ€μλ” λ„¤ λ²μ§Έλ΅, λ„¤ λ²μ§Έ κΈ€μλ” λ‘ λ²μ§Έλ΅ λ³΄λ‚Έλ‹¤."

μ΄κ²ƒμ€ Οƒλ¥Ό "μ›λ iλ²μ§Έ κΈ€μκ°€ Οƒ(i)λ²μ§Έ μ„μΉλ΅ κ°„λ‹¤"κ³  ν•΄μ„ν•λ” κ²ƒμ΄λ‹¤!

- P(1λ²μ§Έ) β†’ μ„μΉ Οƒ(1)=3
- I(2λ²μ§Έ) β†’ μ„μΉ Οƒ(2)=1  
- R(3λ²μ§Έ) β†’ μ„μΉ Οƒ(3)=4
- A(4λ²μ§Έ) β†’ μ„μΉ Οƒ(4)=2

κ²°κ³Ό: μ„μΉ 1=I, μ„μΉ 2=A, μ„μΉ 3=P, μ„μΉ 4=R β†’ **IAPR**

λ§μ°¬κ°€μ§€λ΅ TEAT β†’ **ETTA**, TACK β†’ **AKTC**

μ•”νΈλ¬Έ: **"IAPR ETTA AKTC"**

```lean
-- μ „μΉμ•”νΈ κµ¬ν„
def transpositionEncrypt (sigma : Array Nat) (block : Array Char) : Array Char := Id.run do
  let m := sigma.size
  let mut result := Array.mkArray m ' '
  for i in [:m] do
    -- iλ²μ§Έ κΈ€μλ¥Ό sigma[i]λ²μ§Έ μ„μΉλ΅ λ³΄λ‚Έλ‹¤
    let newPos := sigma.get! i
    result := result.set! (newPos - 1) (block.get! i)  -- 1-indexed β†’ 0-indexed
  return result

-- Οƒ = [3, 1, 4, 2]
#eval transpositionEncrypt #[3, 1, 4, 2] #['P', 'I', 'R', 'A']
-- κ²°κ³Ό: #['I', 'A', 'P', 'R'] = "IAPR"
```

### 7J.8.4 ν’€μ΄ (b): ν•΄λ…

Οƒβ»ΒΉμ„ κµ¬ν•μ. Οƒ = {1β†’3, 2β†’1, 3β†’4, 4β†’2}μ΄λ―€λ΅:
- Οƒβ»ΒΉ: 1β†’2 (Οƒ(2)=1μ΄λ―€λ΅), 2β†’4, 3β†’1, 4β†’3

κ° λΈ”λ΅μ— Οƒβ»ΒΉ(m)μ„ μ μ©ν•λ©΄:
- SWUE β†’ μ„μΉ(Οƒβ»ΒΉ(1)=2, Οƒβ»ΒΉ(2)=4, Οƒβ»ΒΉ(3)=1, Οƒβ»ΒΉ(4)=3): Sβ†’μ„μΉ2, Wβ†’μ„μΉ4, Uβ†’μ„μΉ1, Eβ†’μ„μΉ3 β†’ **USEW**
- TRAE β†’ **ATER**
- OEHS β†’ **HOSE**

ν‰λ¬Έ: **USEW ATER HOSE** β†’ "**USE WATER HOSE**"λ΅ μ¶”μΈ΅ν•  μ μλ‹¤.

---

## 7J.9 **λΉ„λ°€ν‚¤ μ•”νΈμ‹μ¤ν…**(Private Key Cryptosystem) vs **κ³µκ°ν‚¤ μ•”νΈμ‹μ¤ν…**(Public Key Cryptosystem)

### 7J.9.1 λΉ„λ°€ν‚¤ μ•”νΈμ‹μ¤ν…

μ§€κΈκΉμ§€ λ°°μ΄ λ¨λ“  μ•”νΈ(μλ¦¬μ΄λ™, μ•„ν•€, μ „μΉ)λ” **λΉ„λ°€ν‚¤ μ•”νΈμ‹μ¤ν…**(private key cryptosystem)μ μμ΄λ‹¤.

νΉμ§•:
- μ•”νΈν‚¤λ¥Ό μ•λ©΄ ν•΄λ…ν‚¤λ„ λΉ λ¥΄κ² μ°Ύμ„ μ μλ‹¤
- λ”°λΌμ„ λ‘ μ‚¬λμ€ **λΉ„λ°€ν‚¤λ¥Ό κ³µμ **ν•΄μ•Ό ν•λ‹¤
- ν‚¤λ¥Ό μ•μ „ν•κ² κµν™ν•λ” κ²ƒμ΄ λ¬Έμ μ΄λ‹¤

### 7J.9.2 κ³µκ°ν‚¤ μ•”νΈμ‹μ¤ν…

1970λ…„λ€μ— μ•”νΈν•™μλ“¤μ€ **κ³µκ°ν‚¤ μ•”νΈ μ‹μ¤ν…**(public key cryptosystem)μ΄λΌλ” κ°λ…μ„ λ„μ…ν–λ‹¤.

νΉμ§•:
- μ•”νΈν™”ν•  μ μλ‹¤κ³  ν•΄μ„ μ΄λ¥Ό ν•΄λ…ν•  μ μλ” κ²ƒμ€ **μ•„λ‹λ‹¤**
- κ³µκ°λ μ•”νΈν‚¤λ¥Ό λ¨λ“  μ‚¬λμ΄ μ•κ³  μμ§€λ§, ν•΄λ…ν‚¤λ” λΉ„λ°€λ΅ μ μ§€ν•λ‹¤
- κ°€μ¥ μ λ…ν• κ²ƒμ΄ **RSA μ‹μ¤ν…**μ΄λ‹¤ (λ‹¤μ νΈμ—μ„ μƒμ„Έν λ‹¤λ£¬λ‹¤)

---

## 7J.10 μ—°μµ μ„ΈνΈ: κ³ μ „ μ•”νΈ

### μ—°μµ 7J.1: μΉ΄μ΄μ‚¬λ¥΄ μ•”νΈ (μ¤‘κ°„ κ΄„νΈ)

```lean
-- κµμ¬ μ—°μµλ¬Έμ  1a: f(p) = (p + 3) mod 26 (μΉ΄μ΄μ‚¬λ¥΄ μ•”νΈ)
-- "DO NOT PASS GO"μ—μ„ D(=3), O(=14)λ¥Ό μ•”νΈν™”ν•λΌ
example : caesarEncrypt 3 = 6 := by native_decide    -- D β†’ _  π”²
example : caesarEncrypt 14 = _ := by native_decide   -- O β†’ _  π”²
```

<details>
<summary>π’΅ λ‹µ λ³΄κΈ°</summary>

```lean
example : caesarEncrypt 3 = 6 := by native_decide    -- D β†’ G
example : caesarEncrypt 14 = 17 := by native_decide  -- O β†’ R
-- DO NOT PASS GO β†’ GR QRW SDVV JR
```

</details>

### μ—°μµ 7J.2: μλ¦¬μ΄λ™ μ•”νΈ ν•΄λ… (sorry)

```lean
-- κµμ¬ μ—°μµλ¬Έμ  4a: μΉ΄μ΄μ‚¬λ¥΄ μ•”νΈλ΅ μ•”νΈν™”λ "EOXH MHDQV"λ¥Ό ν•΄λ…ν•λΌ
-- (k = 3μΌλ΅ ν•΄λ…)
-- ννΈ: E(=4)λ¥Ό ν•΄λ…ν•λ©΄? shiftDecrypt 3 4 = ?
example : shiftDecrypt 3 4 = 1 := by sorry    -- E β†’ B
example : shiftDecrypt 3 14 = 11 := by sorry  -- O β†’ L
```

<details>
<summary>π’΅ λ‹µ λ³΄κΈ°</summary>

```lean
example : shiftDecrypt 3 4 = 1 := by native_decide    -- E β†’ B
example : shiftDecrypt 3 14 = 11 := by native_decide  -- O β†’ L
-- EOXH MHDQV β†’ BLUE JEANS
```

</details>

### μ—°μµ 7J.3: μ•„ν•€ μ•”νΈ (sorry)

```lean
-- κµμ¬ μ—°μµλ¬Έμ  2c: f(p) = (17p + 22) mod 26
-- "STOP POLLUTION"μ S(=18), T(=19)λ¥Ό μ•”νΈν™”ν•λΌ
example : affineEncrypt 17 22 18 = _ := by sorry   -- π”²
example : affineEncrypt 17 22 19 = _ := by sorry   -- π”²
```

<details>
<summary>π’΅ λ‹µ λ³΄κΈ°</summary>

```lean
example : affineEncrypt 17 22 18 = 22 := by native_decide
-- (17 * 18 + 22) % 26 = 328 % 26 = 22 (= W)

example : affineEncrypt 17 22 19 = 13 := by native_decide
-- (17 * 19 + 22) % 26 = 345 % 26 = 13 (= N)
```

</details>

### μ—°μµ 7J.4: μ•„ν•€ μ•”νΈ μ ν¨μ„± (μ¤‘κ°„ κ΄„νΈ)

```lean
-- a = 4λ΅ μ•„ν•€ μ•”νΈλ¥Ό λ§λ“¤ μ μλ”κ°€?
-- gcd(4, 26) = ?
example : Nat.gcd 4 26 = _ := by native_decide   -- π”²
-- 2μ΄λ―€λ΅ μ‚¬μ© λ¶κ°€! (1μ΄ μ•„λ‹λ©΄ μ—­μ›μ΄ μ—†λ‹¤)
```

<details>
<summary>π’΅ λ‹µ λ³΄κΈ°</summary>

```lean
example : Nat.gcd 4 26 = 2 := by native_decide
-- gcd(4, 26) = 2 β‰  1 μ΄λ―€λ΅ a = 4λ” μ•„ν•€ μ•”νΈμ ν‚¤λ΅ μ‚¬μ©ν•  μ μ—†λ‹¤
```

</details>

### μ—°μµ 7J.5: μλ¦¬μ΄λ™ μ•”νΈ μ „μμ΅°μ‚¬ (sorry)

```lean
-- μλ¦¬μ΄λ™ μ•”νΈμ κ°€λ¥ν• ν‚¤λ” 26κ°μ΄λ‹¤.
-- (0μλ¦¬ μ΄λ™ ν¬ν•¨)
-- 26κ°€μ§€λ¥Ό λ¨λ‘ μ‹λ„ν•λ©΄ λ°λ“μ‹ μ›λ¬Έμ„ μ°Ύμ„ μ μλ‹¤.

-- ν‚¤ λ©λ΅ μƒμ„±
#eval (List.range 26).map (fun k => (k, shiftDecrypt k 10))
-- κ° kμ— λ€ν•΄ K(=10)μ ν•΄λ… κ²°κ³Όλ¥Ό λ³΄μ—¬μ¤€λ‹¤
```

### μ—°μµ 7J.6: λΉλ„ λ¶„μ„ (μ„μ  λ¬Έμ )

> λ‹Ήμ‹ μ΄ μ•”νΈλ¬ΈμΌλ΅ λ λ©”μ‹μ§€λ¥Ό μ¤‘κ°„μ— κ°€λ΅μ±κ³ , μ΄ λ©”μ‹μ§€μ κΈ€μ λΉλ„λ¥Ό μ΅°μ‚¬ν•΄λ³΄λ‹ μμ–΄μ κΈ€μ λΉλ„μ™€ λΉ„μ·ν•λ‹¤λ” κ²ƒμ„ μ•κ² λμ—λ‹¤. μ–΄λ–¤ μΆ…λ¥μ μ•”νΈλ¥Ό μ‚¬μ©ν• κ²ƒμΌλ΅ μƒκ°ν•  μ μλ”κ°€?

<details>
<summary>π’΅ λ‹µ λ³΄κΈ°</summary>

**μ „μΉμ•”νΈ**(transposition cipher)λ¥Ό μ‚¬μ©ν–μ„ κ°€λ¥μ„±μ΄ λ†’λ‹¤. μ „μΉμ•”νΈλ” κΈ€μ μμ²΄λ¥Ό λ°”κΎΈλ” κ²ƒμ΄ μ•„λ‹λΌ **μμ„λ§ μ¬λ°°μ—΄**ν•λ―€λ΅, κ° κΈ€μμ λΉλ„λ” μ›λ¬Έκ³Ό λ™μΌν•κ² μ μ§€λλ‹¤. λ°λ©΄, μλ¦¬μ΄λ™ μ•”νΈλ‚ μ•„ν•€ μ•”νΈλ” κΈ€μλ¥Ό λ‹¤λ¥Έ κΈ€μλ΅ λ°”κΎΈλ―€λ΅ λΉλ„ λ¶„ν¬κ°€ λ‹¬λΌμ§„λ‹¤(λ‹¨, λ¶„ν¬μ "λ¨μ–‘"μ€ μ΄λ™λ§ ν•λ‹¤).

</details>

### μ—°μµ 7J.7: μ•„ν•€ μ•”νΈ ν•΄λ… ν•¨μ (sorry)

```lean
-- f(p) = (15p + 13) mod 26μΌ λ•, ν•΄λ… ν•¨μλ”?
-- λ¨Όμ € 15μ mod 26 μ—­μ›μ„ κµ¬ν•λΌ
example : modInverse 15 26 = _ := by sorry   -- π”²

-- ν•΄λ… ν•¨μ: fβ»ΒΉ(c) = μ—­μ› * (c - 13) mod 26
-- 'A'(=0)λ¥Ό μ΄ ν•¨μλ΅ μ•”νΈν™”ν•λ©΄?
example : affineEncrypt 15 13 0 = _ := by sorry   -- π”²
-- κ·Έ κ²°κ³Όλ¥Ό ν•΄λ…ν•λ©΄ 0μ΄ λ‚μ¤λ”μ§€ ν™•μΈ
```

<details>
<summary>π’΅ λ‹µ λ³΄κΈ°</summary>

```lean
example : modInverse 15 26 = 7 := by native_decide
-- 15 * 7 = 105, 105 % 26 = 1 β“

example : affineEncrypt 15 13 0 = 13 := by native_decide
-- (15 * 0 + 13) % 26 = 13 (= N)

example : affineDecrypt 15 13 13 = 0 := by native_decide
-- μ—­μ›(7) * (13 - 13) = 7 * 0 = 0 β“
```

</details>

### λ„μ „ 7J.1: μ ν¨ν• μ•„ν•€ ν‚¤ κ°μ μ„ΈκΈ°

```lean
-- μ•„ν•€ μ•”νΈμ—μ„ μ ν¨ν• ν‚¤μ μ΄ κ°μλ¥Ό κµ¬ν•λΌ
-- μ ν¨ν• a κ°’μ κ°μ Γ— b κ°’μ κ°μ(26)

-- μ ν¨ν• aμ κ°μ
#eval ((List.range 26).filter (fun a => Nat.gcd a 26 == 1)).length
-- κ²°κ³Ό: π”²

-- μ΄ μ ν¨ν• ν‚¤ μ = π”² Γ— 26 = π”²
```

<details>
<summary>π’΅ λ‹µ λ³΄κΈ°</summary>

```lean
#eval ((List.range 26).filter (fun a => Nat.gcd a 26 == 1)).length
-- 12

-- μ΄ μ ν¨ν• ν‚¤ μ = 12 Γ— 26 = 312
-- (κ·Έλ¬λ‚ a=1, b=0μ€ ν‰λ¬Έ κ·Έλ€λ΅μ΄λ―€λ΅ μ‹¤μ§μ μΌλ΅ 311κ°)

-- μ¤μΌλ¬ νμ΄ ν•¨μμ™€μ κ΄€κ³„:
-- Ο†(26) = Ο†(2) Γ— Ο†(13) = 1 Γ— 12 = 12
#eval Nat.totient 26   -- 12
```

</details>

---

## 7J.11 μ „μ  μ”μ•½

### μƒλ΅μ΄ μ „μ  & κ°λ…

| μ „μ /κ°λ… | μ©λ„ | μμ‹ |
|---------|------|------|
| `native_decide` | κ³„μ‚° κ°€λ¥ν• λ…μ  κ²€μ¦ | `affineEncrypt 7 3 10 = 21` |
| `charToNum` / `numToChar` | κΈ€μβ†”μ«μ λ³€ν™ | μ•”νΈ ν•¨μμ κΈ°λ³Έ λ„κµ¬ |
| `% 26` | mod 26 μ‚°μ  | λ¨λ“  μ•”νΈ μ—°μ‚°μ ν•µμ‹¬ |
| `Nat.gcd` | μµλ€κ³µμ•½μ | μ•„ν•€ μ•”νΈμ μ ν¨μ„± ν™•μΈ |
| `modInverse` | λ¨λ“λ¬ μ—­μ› | μ•„ν•€ μ•”νΈ ν•΄λ… |
| `Array.map` / `List.map` | λ¦¬μ¤νΈ λ³€ν™ | λ¬Έμμ—΄ λ‹¨μ„ μ•”νΈν™” |

### μ΄μ „ μ¥ μ „μ  (λ³µμµ)

| μ „μ  | μµμ΄ λ“±μ¥ |
|------|---------|
| `norm_num`, `omega`, `ring` | Part 4-5 |
| `use`, `obtain`, `have` | Part 7-A |
| `%`, `Nat.add_mod`, `Nat.mul_mod` | Part 7-B |
| `Nat.gcd`, `modInverse` | Part 7-E |

---

## 7J.12 ν•µμ‹¬ μ •λ¦¬ μ”μ•½

1. **μΉ΄μ΄μ‚¬λ¥΄ μ•”νΈ**: f(p) = (p + 3) mod 26, ν‚¤ = 3 κ³ μ •

2. **μλ¦¬μ΄λ™ μ•”νΈ**: f(p) = (p + k) mod 26, ν‚¤ = k β β„¤β‚‚β‚†, 26κ°€μ§€

3. **μ•„ν•€ μ•”νΈ**: f(p) = (ap + b) mod 26, gcd(a, 26) = 1 ν•„μ”, 312κ°€μ§€

4. **μ „μΉμ•”νΈ**: κΈ€μ μμ„λ¥Ό μμ—΄ Οƒλ΅ μ¬λ°°μ—΄, λΈ”λ΅ λ‹¨μ„ μ²λ¦¬

5. **μ•”νΈν•΄λ…**: λΉλ„ λ¶„μ„μΌλ΅ μλ¦¬μ΄λ™ μ•”νΈλ¥Ό κΉ° μ μλ‹¤

6. **μ•”νΈμ‹μ¤ν…**: 5-νν” (π’«, π’, π’¦, β„°, π’), D_k(E_k(p)) = p

7. **λΉ„λ°€ν‚¤ vs κ³µκ°ν‚¤**: λΉ„λ°€ν‚¤λ” μ–‘μ½μ΄ ν‚¤λ¥Ό κ³µμ , κ³µκ°ν‚¤λ” μ•”νΈν‚¤λ§ κ³µκ°

---

## λ‹¤μ νΈ(7-K) μκ³ 

**μ 7-KνΈ**μ—μ„λ” κµμ¬ 4.6.3~4.6.9μ μ λ‚΄μ©μ„ λ‹¤λ£¬λ‹¤:
- **RSA μ•”νΈλ°©μ‹**: ν„λ€ μ•”νΈμ ν•µμ‹¬
- **RSA μ•”νΈν™”μ™€ ν•΄λ…**: μν•™μ  μ›λ¦¬μ™€ Lean4 κµ¬ν„
- **ν‚¤ κµν™ ν”„λ΅ν† μ½**: λ””ν”Ό-ν—¬λ§ ν‚¤ ν•©μ
- **λ””μ§€ν„Έ μ„λ…**: RSAλ¥Ό μ΄μ©ν• μΈμ¦
- **λ™ν•ν™” μ•”νΈ**: μ•”νΈν™”λ λ°μ΄ν„°μ— μ§μ ‘ μ—°μ‚°ν•κΈ°

---

**(λ)**
