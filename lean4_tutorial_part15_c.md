# Part 15-C: NFA, 정규 표현식, 클레이니 정리 — 유한상태 기계의 한계

> **Rosen 이산수학 8판 · Chapter 13 (Section 13.3 후반 ~ 13.4) 기반**
> **Lean 4 형식화 + 3단계 연습문제**

---

## 0. 들어가며

Part 15-B에서 DFA(결정적 유한상태 오토마톤)를 배웠다. 이번 Part에서는:

1. **NFA**(비결정적 유한상태 오토마톤) — 여러 가능한 다음 상태
2. NFA ↔ DFA **동치** — 부분집합 구성법
3. **정규 표현식**(regular expression) — 패턴을 표현하는 수학적 도구
4. **클레이니 정리**(Kleene's theorem) — 정규 표현식 = DFA = NFA = 정규 문법
5. **펌핑 보조정리**(pumping lemma) — DFA로 인식할 수 **없는** 언어

---

## 1. 비결정적 유한상태 오토마톤 (NFA)

### 1.1 "비결정적"이란?

DFA에서는 각 상태에서 각 입력에 대해 **정확히 하나**의 다음 상태가 결정된다. NFA에서는 **여러 개**의 다음 상태가 가능하거나, **아무 상태로도 갈 수 없을** 수 있다.

| | DFA | NFA |
|---|---|---|
| 전이함수 | f : S × I → S (하나) | f : S × I → **P(S)** (집합) |
| 다음 상태 | 정확히 1개 | 0개, 1개, 또는 여러 개 |
| 수용 조건 | 최종 도달 상태 ∈ F | 가능한 경로 중 **하나라도** 최종 상태 도달 |

> 💡 비유: DFA는 "갈림길에서 반드시 하나의 길만 선택하는" 여행자이고, NFA는 "갈림길에서 **분신술을 써서 모든 길을 동시에** 가는" 여행자이다. 분신 중 **하나라도** 목적지에 도착하면 성공!

### 1.2 형식적 정의

> **정의 5** (Rosen 정의 5)
> **비결정적 유한상태 오토마톤**(NFA) M = (S, I, f, s₀, F):
> - **S**: 상태의 유한집합
> - **I**: 입력 알파벳
> - **f**: 전이함수 f : S × I → **P(S)** (S의 **멱집합**으로의 함수)
> - **s₀**: 시작 상태
> - **F** ⊆ S: 최종 상태 집합

핵심: f(s, a)가 **집합**을 반환한다. 예를 들어 f(s₀, 0) = {s₀, s₂}이면, s₀에서 입력 0을 받으면 s₀으로 갈 수도 있고 s₂로 갈 수도 있다.

### 1.3 NFA의 수용 조건

문자열 x = x₁x₂...xₖ가 NFA에 의해 인식되려면:
1. s₀에서 출발
2. 각 단계에서 **가능한 모든 다음 상태**를 추적
3. 마지막에 추적된 상태 중 **하나라도 F에 속하면** → 수용!

### 1.4 Lean 4에서의 NFA

```lean
-- 비결정적 유한상태 오토마톤
structure NFA (S I : Type) [BEq S] [Hashable S] where
  transition : S → I → List S     -- 가능한 다음 상태들의 리스트
  initial    : S
  accepting  : S → Bool

-- NFA 실행: 가능한 모든 상태 추적
def NFA.reachable (m : NFA S I) (inputs : List I) : List S :=
  inputs.foldl
    (fun states input =>
      (states.bind (fun s => m.transition s input)).eraseDups)
    [m.initial]

-- NFA 수용 여부
def NFA.accepts (m : NFA S I) (inputs : List I) : Bool :=
  (m.reachable inputs).any m.accepting
```

### 1.5 NFA 예제

**문제**: 0이 0개 이상 나온 후 01 또는 11로 끝나는 문자열을 인식하는 NFA

| 상태 | 입력 0 | 입력 1 |
|------|--------|--------|
| s₀ | {s₀, s₂} | {s₁} |
| s₁ | {s₃} | {s₄} |
| s₂ | ∅ | {s₄} |
| s₃ | ∅ | ∅ |
| s₄ (**수용**) | ∅ | ∅ |

s₀에서 0이 오면 "자기 자신에 머물면서도" s₂로 분기할 수 있다. 이것이 비결정성이다!

L(M) = {0ⁿ01 | n ≥ 0} ∪ {0ⁿ11 | n ≥ 0}

```lean
inductive NS where | s0 | s1 | s2 | s3 | s4
  deriving BEq, DecidableEq, Repr

open NS Bit

def nfaExample : NFA NS Bit := {
  initial := s0
  transition := fun s i => match s, i with
    | s0, b0 => [s0, s2]  -- 비결정적! 두 상태로
    | s0, b1 => [s1]
    | s1, b0 => [s3]  | s1, b1 => [s4]
    | s2, b1 => [s4]
    | _, _   => []         -- 전이 없음
  accepting := fun s => match s with
    | s4 => true | _ => false
}
```

---

## 2. NFA와 DFA의 동치 — 부분집합 구성법

### 2.1 핵심 정리

> **정리 1** (Rosen 정리 1)
> 언어 L이 NFA에 의해 인식되면, L은 **DFA에 의해서도** 인식된다.

즉, NFA가 DFA보다 "더 강력한" 것은 **아니다**! NFA가 인식할 수 있는 모든 언어는 DFA로도 인식할 수 있다.

### 2.2 부분집합 구성법 (Subset Construction)

NFA M₀ = (S, I, f, s₀, F)에서 DFA M₁을 구성하는 방법:

1. **M₁의 상태** = S의 **모든 부분집합** (즉, P(S))
2. **M₁의 시작 상태** = {s₀}
3. **M₁의 전이**: {sᵢ₁, sᵢ₂, ...}에서 입력 x를 받으면 → f(sᵢ₁, x) ∪ f(sᵢ₂, x) ∪ ...
4. **M₁의 최종 상태** = F의 원소를 **하나라도** 포함하는 부분집합

> ⚠️ **상태 폭발**: NFA의 상태가 n개이면, DFA는 최대 **2ⁿ**개의 상태를 가질 수 있다! 실제로는 도달 가능한 상태만 사용하므로 보통 훨씬 적다.

### 2.3 Lean 4로 부분집합 구성

```lean
-- NFA를 DFA로 변환 (부분집합 구성법의 핵심 아이디어)
def nfaToDFA (nfa : NFA S I) : DFA (List S) I := {
  initial := [nfa.initial]
  transition := fun stateSet input =>
    (stateSet.bind (fun s => nfa.transition s input)).eraseDups
  accepting := fun stateSet =>
    stateSet.any nfa.accepting
}
```

---

## 3. 정규 표현식 — 패턴의 수학

### 3.1 정규 표현식이란?

프로그래밍에서 `grep`, `sed`, JavaScript의 `/pattern/` 등에서 사용하는 **정규 표현식**(regular expression, regex)의 수학적 원형이다.

> **정의 1** (Rosen 정의 1, 13.4절)
> 알파벳 I에서의 **정규 표현**(regular expression)은 다음과 같이 **재귀적으로** 정의된다:
> 1. **∅** 는 정규 표현이다 (빈 집합)
> 2. **λ** 는 정규 표현이다 (공 문자열의 집합 {λ})
> 3. I의 원소 **x** 는 정규 표현이다 (집합 {x})
> 4. A, B가 정규 표현이면 **(AB)** 는 정규 표현이다 (연결)
> 5. A, B가 정규 표현이면 **(A ∪ B)** 는 정규 표현이다 (합집합)
> 6. A가 정규 표현이면 **A*** 는 정규 표현이다 (클레이니 폐쇄)

### 3.2 정규 표현식 예제 (Rosen 예제 1~2)

| 정규 표현 | 나타내는 집합 | 예시 문자열 |
|----------|-------------|-----------|
| 10* | 1 다음에 0이 0개 이상 | 1, 10, 100, 1000 |
| (10)* | "10"이 0번 이상 반복 | λ, 10, 1010, 101010 |
| 0 ∪ 01 | "0" 또는 "01" | 0, 01 |
| 0(0 ∪ 1)* | 0으로 시작하는 모든 비트열 | 0, 00, 01, 010, 011, ... |
| (0*1)* | 0으로 끝나지 않는 모든 비트열 | λ, 1, 01, 001, 11, ... |

#### 실전 문제 (Rosen 예제 2)

**(a)** 짝수 길이 비트열: **(00 ∪ 01 ∪ 10 ∪ 11)***

**(b)** 0으로 끝나면서 11을 포함하지 않음: **(0 ∪ 10)*(0 ∪ 10)**

**(c)** 홀수 개의 0을 포함: **1\*01\*(01\*01\*)\***

### 3.3 Lean 4로 정규 표현식 모델링

```lean
-- 정규 표현식의 귀납적 정의
inductive Regex (α : Type) where
  | empty   : Regex α               -- ∅
  | epsilon : Regex α               -- λ
  | char    : α → Regex α           -- 단일 문자
  | concat  : Regex α → Regex α → Regex α  -- AB (연결)
  | union   : Regex α → Regex α → Regex α  -- A ∪ B (합집합)
  | star    : Regex α → Regex α     -- A* (클레이니 폐쇄)

-- 정규 표현식이 문자열을 매치하는지 판별
-- (간략화된 재귀적 정의)
def Regex.matches : Regex α → List α → Prop
  | .empty,      _  => False
  | .epsilon,    w  => w = []
  | .char c,     w  => w = [c]
  | .concat a b, w  => ∃ w₁ w₂, w = w₁ ++ w₂ ∧
                        a.matches w₁ ∧ b.matches w₂
  | .union a b,  w  => a.matches w ∨ b.matches w
  | .star a,     w  => w = [] ∨
                        ∃ w₁ w₂, w = w₁ ++ w₂ ∧
                        w₁ ≠ [] ∧ a.matches w₁ ∧ (Regex.star a).matches w₂
```

---

## 4. 클레이니 정리 — 모든 것이 연결된다

### 4.1 정리 내용

> **정리 (클레이니 정리)**: 다음 네 가지는 모두 **동치**이다:
> 1. 언어 L이 **정규 표현식**으로 표현 가능하다
> 2. 언어 L이 **DFA**에 의해 인식 가능하다
> 3. 언어 L이 **NFA**에 의해 인식 가능하다
> 4. 언어 L이 **정규 문법**(유형 3)에 의해 생성 가능하다

이 네 가지가 모두 같은 것을 말한다! 이 동치인 집합들을 **정규 집합**(regular set) 또는 **정규 언어**(regular language)라 부른다.

### 4.2 동치 관계 그림

```
    정규 표현식
    ↗        ↘
  NFA    ↔    DFA
    ↘        ↗
    정규 문법
```

모든 방향으로 변환이 가능하다:
- 정규 표현식 → NFA: 클레이니 정리 증명의 핵심 (∅, {λ}, {a}, AB, A∪B, A*에 대해 NFA 구성)
- NFA → DFA: 부분집합 구성법 (Section 2)
- DFA → 정규 표현식: 상태 제거법 (State elimination)
- 정규 문법 ↔ NFA: 생성 규칙과 전이의 대응

### 4.3 정규 표현식 → NFA 구성 (증명의 핵심)

클레이니 정리의 충분조건 증명은 **구조적 귀납법**을 사용한다:

| 기본 경우 | NFA |
|----------|-----|
| ∅ (빈 집합) | 최종 상태 없는 1-상태 기계 |
| {λ} (공 문자열) | 시작 상태 = 최종 상태인 기계 |
| {a} (단일 문자) | s₀ →ᵃ s₁(최종) |

| 귀납 단계 | 구성 방법 |
|----------|---------|
| AB (연결) | M_A의 최종 상태에서 M_B의 시작 상태로 연결 |
| A ∪ B (합집합) | 새 시작 상태에서 M_A, M_B로 분기 |
| A* (클레이니 폐쇄) | M_A의 최종 상태에서 시작 상태로 되돌아가는 전이 추가 |

```lean
-- 정규 표현식 → NFA 변환 (개념적 정의)
-- 실제 구현은 복잡하므로 핵심 아이디어만 표현
def regexToNFA : Regex α → NFA Nat α := sorry
-- 이 변환이 존재한다는 것이 클레이니 정리의 핵심!
```

---

## 5. 펌핑 보조정리 — DFA의 한계

### 5.1 DFA로 인식할 수 없는 언어가 있다!

**{0ⁿ1ⁿ | n ≥ 0}** 은 DFA로 인식할 수 **없다**. 왜 그럴까?

직관: DFA는 상태가 유한하므로, 아무리 많은 0을 읽어도 0의 **정확한 개수**를 기억할 수 없다. 상태가 k개이면, 0을 k+1개 이상 읽으면 반드시 같은 상태를 두 번 방문하게 되고(비둘기집 원리!), 그 시점에서 "0이 몇 개 왔는지" 구분할 수 없게 된다.

### 5.2 펌핑 보조정리

> **정리 (펌핑 보조정리)**:
> L이 **정규 언어**이면, 어떤 양의 정수 p(**펌핑 길이**)가 존재하여, L에 속하는 길이 p 이상의 모든 문자열 s에 대해, s = xyz로 분해할 수 있으되:
> 1. |y| ≥ 1 (y는 빈 문자열이 아님)
> 2. |xy| ≤ p
> 3. 모든 i ≥ 0에 대해 **xy^i z ∈ L** (y를 i번 반복해도 여전히 L에 속함)

> 💡 비유: 정규 언어의 문자열이 충분히 길면, 그 안에 **"펌프질"할 수 있는 부분**(y)이 반드시 존재한다. y를 0번, 1번, 2번, ... 몇 번이든 반복해도 여전히 언어에 속한다.

### 5.3 펌핑 보조정리로 비정규성 증명

**{0ⁿ1ⁿ | n ≥ 0}이 정규 언어가 아님을 증명:**

**반증법**: 정규 언어라고 가정하면 펌핑 보조정리가 성립해야 한다.

1. 펌핑 길이 p가 존재한다고 가정
2. 문자열 s = 0ᵖ1ᵖ를 선택 (길이 = 2p ≥ p)
3. s = xyz로 분해, |xy| ≤ p이므로 **x와 y는 모두 0으로만** 이루어짐
4. y = 0ᵏ (k ≥ 1)
5. xy²z = 0ᵖ⁺ᵏ1ᵖ인데, p+k ≠ p이므로 **L에 속하지 않는다!**
6. 모순! → 가정이 틀렸으므로 {0ⁿ1ⁿ}은 정규 언어가 아니다. ∎

```lean
-- 펌핑 보조정리의 형식적 표현 (증명은 생략)
theorem pumping_lemma (L : Language) (hReg : IsRegular L) :
    ∃ p : Nat, p > 0 ∧
    ∀ s : Word, L s → s.length ≥ p →
    ∃ x y z : Word,
      s = x ++ y ++ z ∧
      y.length ≥ 1 ∧
      (x ++ y).length ≤ p ∧
      ∀ i : Nat, L (x ++ repeatList y i ++ z) := by
  sorry  -- 증명은 비둘기집 원리 기반
```

### 5.4 촘스키 위계와의 관계

| 언어 | 유형 | 인식 기계 | 예시 |
|------|------|----------|------|
| **정규 언어** | 유형 3 | DFA/NFA | {0ⁿ \| n ≥ 0}, "01로 끝남" |
| **문맥자유 언어** | 유형 2 | 푸시다운 오토마톤 | **{0ⁿ1ⁿ \| n ≥ 0}** |
| **문맥의존 언어** | 유형 1 | 선형 유계 오토마톤 | {0ⁿ1ⁿ2ⁿ \| n ≥ 0} |
| **재귀적 가산 언어** | 유형 0 | 튜링 기계 | 정지 문제의 보수 |

---

## 6. 연습문제

### 연습 6.1: NFA 상태 추적 [괄호 채우기]

다음 NFA에서 입력 "001"에 대해 도달 가능한 상태를 추적하라.

f(s₀, 0) = {s₀, s₁}, f(s₀, 1) = {s₂}, f(s₁, 0) = ∅, f(s₁, 1) = {s₂}, f(s₂, 0) = ∅, f(s₂, 1) = ∅
F = {s₂}

```
시작: {s₀}
입력 0: 가능한 상태 = f(s₀, 0) = ⬜
입력 0: 가능한 상태 = f(s₀, 0) ∪ f(s₁, 0) = ⬜
입력 1: 가능한 상태 = f(s₀, 1) ∪ f(s₁, 1) = ⬜
최종 상태 중 F에 속하는 것이 있는가? ⬜ → 수용/거부: ⬜
```

<details>
<summary>📝 답 보기</summary>

```
시작: {s₀}
입력 0: {s₀, s₁}
입력 0: f(s₀, 0) ∪ f(s₁, 0) = {s₀, s₁} ∪ ∅ = {s₀, s₁}
입력 1: f(s₀, 1) ∪ f(s₁, 1) = {s₂} ∪ {s₂} = {s₂}
s₂ ∈ F? → 예! → 수용 ✅
```

</details>

---

### 연습 6.2: 정규 표현식 해석 [괄호 채우기]

다음 정규 표현식이 나타내는 집합을 서술하라.

```
(a) 10*     → ⬜
(b) (10)*   → ⬜
(c) 0(0∪1)* → ⬜
(d) (00∪01∪10∪11)* → ⬜
```

<details>
<summary>📝 답 보기</summary>

```
(a) 10* → 1 다음에 0이 0개 이상: {1, 10, 100, 1000, ...}
(b) (10)* → "10"이 0번 이상 반복: {λ, 10, 1010, 101010, ...}
(c) 0(0∪1)* → 0으로 시작하는 모든 비트열: {0, 00, 01, 000, 001, ...}
(d) (00∪01∪10∪11)* → 짝수 길이의 모든 비트열: {λ, 00, 01, ..., 0000, ...}
```

</details>

---

### 연습 6.3: 정규 표현식 설계 [sorry]

다음 언어를 표현하는 정규 표현식을 구하라.

```lean
-- (a) 1만으로 이루어진 비트열 (공 문자열 포함)
-- 정규 표현식: sorry

-- (b) "00"을 포함하는 모든 비트열
-- 정규 표현식: sorry

-- (c) 정확히 두 개의 1을 포함하는 비트열
-- 정규 표현식: sorry
```

<details>
<summary>📝 답 보기</summary>

```
(a) 1* (1이 0번 이상)

(b) (0∪1)*00(0∪1)* (아무거나 + 00 + 아무거나)

(c) 0*10*10* (0 여러 개, 1, 0 여러 개, 1, 0 여러 개)
```

</details>

---

### 연습 6.4: DFA 설계 — "010"을 포함하는 비트열 [sorry]

```lean
-- 힌트: 상태 4개
-- s₀: 아직 패턴 시작 안 됨
-- s₁: 직전이 0 (010의 첫 번째 0)
-- s₂: 직전 두 개가 01 (010의 01 부분)
-- s₃(수용): 010을 이미 발견함

inductive P010 where | init | saw0 | saw01 | found
  deriving DecidableEq, Repr

def contains010 : DFA P010 Bit := {
  initial := sorry
  transition := sorry
  accepting := sorry
}
```

<details>
<summary>📝 답 보기</summary>

```lean
open P010 Bit

def contains010 : DFA P010 Bit := {
  initial := init
  transition := fun s i => match s, i with
    | found, _ => found     -- 이미 010 발견, 유지
    | init,  b0 => saw0     -- 0 봄
    | init,  b1 => init     -- 리셋
    | saw0,  b0 => saw0     -- 00 → 마지막 0 유지
    | saw0,  b1 => saw01    -- 01 봄
    | saw01, b0 => found    -- 010 완성!
    | saw01, b1 => init     -- 011 → 리셋
  accepting := fun s => match s with
    | found => true | _ => false
}
```

</details>

---

### 연습 6.5: 펌핑 보조정리 적용 [괄호 채우기]

{0ⁿ1ⁿ | n ≥ 0}이 정규 언어가 아님을 펌핑 보조정리로 증명하라.

```
1. 가정: L = {0ⁿ1ⁿ}이 정규 언어이다.
2. 펌핑 길이 p가 존재한다.
3. 문자열 s = ⬜ 를 선택 (길이 ≥ p)
4. s = xyz로 분해, |xy| ≤ p이므로 y = ⬜ (0만으로 구성)
5. xy²z = ⬜ ← 이것이 L에 속하는가? ⬜
6. 결론: ⬜
```

<details>
<summary>📝 답 보기</summary>

```
1. 가정: L = {0ⁿ1ⁿ}이 정규 언어이다.
2. 펌핑 길이 p가 존재한다.
3. 문자열 s = 0ᵖ1ᵖ 를 선택 (길이 2p ≥ p)
4. s = xyz, |xy| ≤ p이므로 y = 0ᵏ (k ≥ 1, 0만으로 구성)
5. xy²z = 0ᵖ⁺ᵏ1ᵖ ← p+k ≠ p이므로 L에 속하지 않는다!
6. 결론: 모순! 따라서 L은 정규 언어가 아니다. ∎
```

</details>

---

### 연습 6.6: NFA를 Lean 4로 구현 [sorry]

0으로 시작하거나 1로 끝나는 비트열을 인식하는 NFA를 구현하라.

```lean
-- L = {0으로 시작하는 비트열} ∪ {1로 끝나는 비트열}
-- 정규 표현식: 0(0∪1)* ∪ (0∪1)*1

-- 힌트: NFA를 사용하면 시작 상태에서 두 갈래로 분기 가능!

def startsWith0orEndsWith1 : NFA Nat Bit := {
  initial := sorry
  transition := sorry
  accepting := sorry
}
```

<details>
<summary>📝 답 보기</summary>

```lean
-- 상태: 0=시작, 1="0으로 시작" 경로 수용, 2="1로 끝남" 추적, 3="마지막이 1"
def startsWith0orEndsWith1 : NFA Nat Bit := {
  initial := 0
  transition := fun s i => match s, i with
    | 0, b0 => [1, 2]    -- 0으로 시작 → 수용 + 끝 추적
    | 0, b1 => [2, 3]    -- 끝 추적
    | 1, _  => [1]        -- 이미 0으로 시작, 계속 수용
    | 2, b0 => [2]        -- 마지막이 0
    | 2, b1 => [3]        -- 마지막이 1
    | 3, b0 => [2]        -- 마지막이 0으로 바뀜
    | 3, b1 => [3]        -- 마지막이 1 유지
    | _, _  => []
  accepting := fun s => s == 1 || s == 3
}
```

사실 이 문제는 DFA로도 풀 수 있지만, NFA가 더 직관적이다.

</details>

---

## 7. 핵심 요약

| 개념 | 정의 | Lean 4 |
|------|------|--------|
| **NFA** | f : S × I → P(S) | `transition : S → I → List S` |
| **NFA 수용** | 가능한 경로 중 하나라도 F 도달 | `states.any accepting` |
| **부분집합 구성** | NFA → DFA 변환 | 상태 = 원래 상태의 부분집합 |
| **정규 표현식** | ∅, λ, a, AB, A∪B, A* | `Regex α` 귀납적 타입 |
| **정규 집합** | 정규 표현으로 표현 가능한 집합 | = DFA/NFA 인식 가능 |
| **클레이니 정리** | 정규표현 ↔ DFA ↔ NFA ↔ 정규문법 | 동치 |
| **펌핑 보조정리** | 정규 언어의 필요 조건 | 비정규성 증명에 사용 |
| **{0ⁿ1ⁿ}** | 정규 언어가 **아님** | 문맥자유 언어 |

---

## 다음 파트 예고

**Part 15-D**에서는:
- **튜링 기계**(Turing machine) — 가장 강력한 계산 모델
- 튜링 기계로 {0ⁿ1ⁿ}을 인식하는 방법
- **처치-튜링 논제**(Church-Turing thesis) — "계산 가능 = 튜링 기계로 가능"
- **P vs NP 문제** 소개
- **정지 문제**(halting problem) — 풀 수 없는 문제
