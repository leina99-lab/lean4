# 📘 Lean 4 튜토리얼 — Part 9-H: 순열과 조합의 생성

> **Rosen 이산수학 8판 §6.6 기반**
> 이전 파트까지 순열과 조합의 **개수를 세는 방법**을 배웠다.
> 이번 파트에서는 순열과 조합을 **실제로 생성하는 알고리즘**을 다룬다. 이것은 이론과 실용의 교차점이다!

---

## 9H.0 왜 순열과 조합을 "생성"해야 하는가?

계수(counting)는 "몇 가지?"라는 질문에 답한다. 하지만 실제 문제에서는 모든 경우를 하나하나 나열해야 할 때가 있다.

예를 들어:
- 여행 경로 최적화: 6개 도시를 방문하는 모든 순서를 나열하고 각각의 거리를 계산
- 부분집합 탐색: 어떤 집합의 원소들로 합이 100이 되는 조합 찾기
- 암호 해독: 가능한 모든 배열을 시도

이때 순열이나 조합을 **체계적으로 빠짐없이** 생성하는 알고리즘이 필요하다.

핵심 아이디어는 **사전순 정렬**(lexicographic order)이다. 사전에서 단어를 찾듯이, 순열이나 조합을 "알파벳 순서"로 나열하는 것이다.

---

## 9H.1 사전순 정렬이란?

### 이론 설명

두 수열 a₁a₂...aₙ과 b₁b₂...bₙ에 대해, **사전순**(lexicographic order)으로 비교하려면:

1. 왼쪽부터 하나씩 비교한다.
2. 처음으로 다른 위치를 찾는다.
3. 그 위치에서 더 작은 값을 가진 수열이 사전순으로 앞에 온다.

예를 들어 {1, 2, 3, 4, 5}에 대한 순열:
- 23415와 23514를 비교하면: 첫 두 자리(2, 3)는 같고, 세 번째 자리에서 4 < 5이므로 23415가 앞에 온다.

이것은 마치 사전에서 "apple"이 "apply"보다 앞에 오는 것과 같은 원리다!

```lean
-- Lean 4에서 리스트의 사전순 비교
-- List.Lex는 사전순 관계를 정의한다
#check @List.Lex
```

Lean 4에서 `List.Lex`는 리스트에 대한 사전순 비교를 제공한다. 두 리스트가 주어졌을 때, 원소별로 비교하여 어느 쪽이 "작은지" 판단할 수 있다.

#### 예제 — 사전순 비교 (교재 예제 1)

> 집합 {1, 2, 3, 4, 5}에 대한 순열 23415는 순열 23514보다 앞에 나온다.

이유: 첫 두 숫자는 같지만, 세 번째 위치의 숫자는 첫 번째 순열은 4이고 두 번째 순열은 5로서 첫 번째 순열의 수가 작기 때문이다.

마찬가지로 41532가 52143보다 앞에 나온다. 첫 번째 위치에서 4 < 5이기 때문이다.

```lean
-- 사전순 비교의 원리를 Lean 4로 표현
-- [2,3,4,1,5]와 [2,3,5,1,4]를 비교하면
-- 세 번째 원소에서 4 < 5이므로 첫 번째가 사전순으로 앞선다

-- 리스트를 사용한 간단한 비교
example : [2, 3, 4] < [2, 3, 5] := by decide
example : [4, 1, 5] < [5, 2, 1] := by decide
```

---

## 9H.2 다음으로 큰 순열 생성하기

### 이론 설명 — 핵심 알고리즘

주어진 순열에서 **사전순으로 바로 다음인 순열**을 찾는 알고리즘은 다음과 같다:

> **알고리즘 1** — 사전순 정렬에서 다음으로 큰 순열 생성하기

주어진 순열이 a₁a₂...aₙ이라 하자.

**단계 1**: 오른쪽 끝에서부터 왼쪽으로 가면서, aⱼ < aⱼ₊₁인 **가장 오른쪽 위치 j**를 찾는다.
- 즉, aⱼ₊₁ > aⱼ₊₂ > ⋯ > aₙ인 내림차순 꼬리 부분 바로 앞의 위치를 찾는다.
- 만약 모든 aⱼ ≥ aⱼ₊₁이면 (즉 전체가 내림차순이면) 이미 마지막 순열이다.

**단계 2**: aⱼ₊₁, aⱼ₊₂, ..., aₙ 중에서 aⱼ보다 큰 가장 작은 수 aₖ를 찾는다.

**단계 3**: aⱼ와 aₖ를 교환한다.

**단계 4**: aⱼ₊₁부터 aₙ까지를 오름차순으로 정렬한다 (실제로는 뒤집기만 하면 된다!).

이 알고리즘이 왜 올바른지 직관적으로 이해해 보자:

1. **단계 1에서 j를 찾는 이유**: j+1번째부터 끝까지는 이미 내림차순이므로, 이 부분만으로는 더 큰 순열을 만들 수 없다. 따라서 j번째 원소를 "더 큰 것"으로 바꿔야 한다.

2. **단계 2에서 aₖ를 찾는 이유**: aⱼ를 대체할 수 있는 것 중 가장 작은 것을 골라야 "바로 다음" 순열이 된다.

3. **단계 4에서 뒤집는 이유**: aⱼ자리에 더 큰 수를 놓았으므로, 나머지는 가능한 한 작아야 한다. 내림차순이었던 것을 오름차순으로 뒤집으면 가장 작은 배열이 된다.

#### 예제 — 다음 순열 찾기 (교재 예제 2)

> 사전순 정렬에서 362541 바로 다음으로 큰 순열은 무엇인가?

**풀이**: 

1. **단계 1**: 오른쪽에서 왼쪽으로 가면서 aⱼ < aⱼ₊₁인 위치를 찾는다.
   - 순열: 3 **6** 2 5 4 1
   - a₅ = 4, a₆ = 1 → 4 > 1 (아직 내림차순)
   - a₄ = 5, a₅ = 4 → 5 > 4 (아직 내림차순)
   - a₃ = 2, a₄ = 5 → **2 < 5** ← 여기! j = 3

2. **단계 2**: a₃ = 2보다 크면서 오른쪽에 있는 수 중 가장 작은 것을 찾는다.
   - 오른쪽: 5, 4, 1 → 2보다 큰 것: 5, 4 → 가장 작은 것: **4** (k = 5)

3. **단계 3**: a₃ = 2와 a₅ = 4를 교환
   - 362541 → 3**6**4**5**21 → 잠깐, 다시 정리하면: 3 6 **4** 5 **2** 1

4. **단계 4**: j+1 = 4번째부터 끝까지를 뒤집는다.
   - 교환 후: 3, 6, 4, [5, 2, 1] → 뒤집기 → 3, 6, 4, [1, 2, 5]
   - 결과: **364125**

```lean
-- 362541의 다음 순열이 364125인지 확인
-- 리스트로 표현하여 확인
example : [3, 6, 4, 1, 2, 5] > [3, 6, 2, 5, 4, 1] := by decide
```

### Lean 4로 구현하기

이제 이 알고리즘을 Lean 4로 구현해 보겠다. 먼저 각 단계를 개별 함수로 만들고, 최종적으로 조합한다.

```lean
-- 리스트의 특정 인덱스의 원소를 교환하는 함수
def List.swap (l : List α) (i j : Nat) : List α :=
  let a := l.get? i
  let b := l.get? j
  match a, b with
  | some va, some vb =>
    l.enum.map fun (idx, v) =>
      if idx == i then vb
      else if idx == j then va
      else v
  | _, _ => l

-- 리스트의 특정 부분을 뒤집는 함수
def List.reverseSuffix (l : List α) (from : Nat) : List α :=
  l.take from ++ (l.drop from).reverse
```

> 💡 **참고**: 위의 코드는 교육용으로 간단히 작성한 것이다. 실제 Lean 4에서는 `Array`를 사용하면 더 효율적이다.

### 예제 — 1, 2, 3의 모든 순열 생성 (교재 예제 3)

> 정수 1, 2, 3의 순열을 사전순으로 생성하라.

**풀이**: 123에서 시작하여 알고리즘을 반복 적용한다:
1. **123** → (j=2, k=3, 교환 후 132, 뒤집기 없음) → **132**
2. **132** → (j=1, 3과 2에서 작은 2→3, 교환 후 231, 뒤집기) → **213**
3. **213** → (j=2, k=3) → **231**
4. **231** → (j=1, 교환 후 321, 뒤집기) → **312**
5. **312** → (j=2, k=3) → **321**

결과: 123, 132, 213, 231, 312, 321 (총 3! = 6개)

```lean
-- 3! = 6개의 순열이 생성되는지 확인
example : Nat.factorial 3 = 6 := by norm_num

-- Lean 4에서 Fin 3의 모든 순열을 나열할 수 있다
-- Equiv.Perm (Fin 3)의 원소 수 = 3! = 6
example : Fintype.card (Equiv.Perm (Fin 3)) = 6 := by
  simp [Fintype.card_perm]
```

### 🏋️ 연습 9H.1 — 다음 순열 찾기

**문제**: 사전순 정렬에서 1432의 바로 다음으로 큰 순열을 구하여라.

> 💡 힌트:
> - 단계 1: 오른쪽에서부터 aⱼ < aⱼ₊₁인 위치 찾기. 4>3>2이므로 a₁=1 < a₂=4. j=1
> - 단계 2: 1보다 큰 수 중 가장 작은 것: 2 (k=4)
> - 단계 3: 교환 → 2, 4, 3, 1
> - 단계 4: 뒤집기 → 2, [1, 3, 4]

```lean
-- 1432의 다음 순열은 무엇인가?
-- 답: [2, 1, 3, 4]
example : [2, 1, 3, 4] > [1, 4, 3, 2] := by decide
```

<details>
<summary>📝 답 보기</summary>

답은 **2134**이다.

단계별 풀이:
1. 순열 1432에서 오른쪽 끝 내림차순 부분: 4, 3, 2. 그 바로 왼쪽: 1. → j = 1
2. {4, 3, 2} 중 1보다 큰 가장 작은 수: 2 → k = 4
3. a₁ = 1과 a₄ = 2를 교환 → 2, 4, 3, 1
4. 2번째부터 끝까지 뒤집기 → 2, 1, 3, 4

```lean
example : [2, 1, 3, 4] > [1, 4, 3, 2] := by decide
```

</details>

---

### 🏋️ 연습 9H.2 — 다음 순열 찾기 (2)

**문제**: 사전순 정렬에서 54123의 바로 다음으로 큰 순열을 구하여라.

<details>
<summary>📝 답 보기</summary>

답은 **54132**이다.

단계별 풀이:
1. 오른쪽 끝에서 내림차순 부분: 3만 봤을 때 — a₄=2, a₅=3 → 2 < 3이므로 j = 4
2. a₅ = 3 > a₄ = 2이므로 k = 5
3. a₄와 a₅ 교환 → 5, 4, 1, 3, 2
4. j+1=5번째부터 뒤집기 → 변화 없음 (원소 1개)

결과: 54132

```lean
example : [5, 4, 1, 3, 2] > [5, 4, 1, 2, 3] := by decide
```

</details>

---

## 9H.3 비트 문자열의 생성

### 이론 설명

**비트 문자열**(bit string)은 0과 1로만 이루어진 문자열이다. 길이 n인 비트 문자열의 총 개수는 2ⁿ이다.

모든 비트 문자열을 나열하는 방법은 간단하다: 0부터 2ⁿ - 1까지의 **이진수 표현**을 사용하면 된다!

> **알고리즘 2** — 주어진 비트 문자열에서 바로 다음으로 큰 비트 문자열 생성하기

1. 오른쪽 끝에서부터 첫 번째 0을 찾는다.
2. 그 0을 1로 바꾼다.
3. 그 오른쪽에 있는 모든 1을 0으로 바꾼다.

이것은 사실 **이진수 덧셈에서 +1 하기**와 동일하다!

#### 예제 — 다음 비트 문자열 (교재 예제 4)

> 10 0010 0111 다음으로 큰 비트 문자열을 찾아라.

**풀이**: 
1. 오른쪽에서부터 첫 번째 0의 위치: 4번째 비트 (오른쪽에서 세면)
2. 그 0을 1로 바꾸기: 10 0010 1___
3. 그 오른쪽의 1들을 0으로: 10 0010 1000

결과: **10 0010 1000**

```lean
-- 이진수로 확인
-- 0b1000100111 = 551
-- 0b1000101000 = 552
-- 551 + 1 = 552 ✓
example : 551 + 1 = 552 := by norm_num
```

### Lean 4에서 비트 문자열 표현

Lean 4에서 길이 n의 비트 문자열은 `Fin n → Bool` 또는 `Fin n → Fin 2`로 표현할 수 있다.

```lean
-- 길이 n의 비트 문자열의 총 수 = 2ⁿ
example (n : ℕ) : Fintype.card (Fin n → Bool) = 2 ^ n := by simp

-- Fin 2를 사용한 표현도 동일
example (n : ℕ) : Fintype.card (Fin n → Fin 2) = 2 ^ n := by simp
```

### 🏋️ 연습 9H.3 — 비트 문자열

**문제**: 길이 4인 비트 문자열의 총 수를 Lean 4로 증명하여라.

```lean
-- 괄호를 채우세요
example : Fintype.card (Fin 4 → Bool) = (⟨여기를 채우세요⟩) := by simp
```

<details>
<summary>📝 답 보기</summary>

```lean
example : Fintype.card (Fin 4 → Bool) = 16 := by simp
```

2⁴ = 16

</details>

---

## 9H.4 조합의 생성

### 이론 설명

집합 {1, 2, ..., n}의 r-조합을 사전순으로 나열하고, 현재 조합에서 **다음으로 큰 r-조합**을 찾는 알고리즘이다.

r-조합은 부분집합이지만, 원소를 증가하는 순서로 나열한 수열 a₁ < a₂ < ⋯ < aᵣ로 표현한다.

> **알고리즘 3** — 사전순 정렬에서 다음으로 큰 r-조합 생성하기

주어진 r-조합이 {a₁, a₂, ..., aᵣ}이고 a₁ < a₂ < ⋯ < aᵣ라 하자.

1. aᵢ ≠ n - r + i를 만족하는 **가장 오른쪽 원소** aᵢ를 찾는다.
   - 즉, "아직 최댓값에 도달하지 않은" 가장 오른쪽 위치를 찾는다.
2. aᵢ를 aᵢ + 1로 바꾼다.
3. aᵢ₊₁, aᵢ₊₂, ..., aᵣ를 aᵢ + 1, aᵢ + 2, ..., aᵢ + (r - i)로 바꾼다.
   - 즉, i+1번째부터 끝까지를 aᵢ+1에서 연속된 값으로 채운다.

**왜 이렇게 하는가?**

- aᵢ의 최댓값은 n - r + i이다. 예를 들어 {1,2,...,6}의 4-조합에서 a₄의 최댓값은 6, a₃의 최댓값은 5, a₂의 최댓값은 4, a₁의 최댓값은 3이다.
- "아직 최댓값이 아닌" 가장 오른쪽 원소를 1 증가시키고, 그 뒤를 최소로 채우면 "바로 다음" 조합이 된다.

#### 예제 — 다음 조합 찾기 (교재 예제 5)

> 집합 {1, 2, 3, 4, 5, 6}의 4-조합에서 {1, 2, 5, 6} 다음으로 큰 조합을 찾아라.

**풀이**: 현재 조합 a₁=1, a₂=2, a₃=5, a₄=6

1. **단계 1**: aᵢ ≠ n - r + i를 만족하는 가장 오른쪽 원소를 찾는다.
   - a₄ = 6, n-r+4 = 6-4+4 = 6 → 같음 (최댓값)
   - a₃ = 5, n-r+3 = 6-4+3 = 5 → 같음 (최댓값)
   - a₂ = 2, n-r+2 = 6-4+2 = 4 → **다름!** → i = 2

2. **단계 2**: a₂를 2+1 = 3으로 바꿈

3. **단계 3**: a₃ = 3+1 = 4, a₄ = 3+2 = 5

결과: **{1, 3, 4, 5}**

```lean
-- {1,2,5,6}의 다음 4-조합은 {1,3,4,5}
-- 부분집합의 크기 확인
example : Nat.choose 6 4 = 15 := by native_decide
```

### 🏋️ 연습 9H.4 — 다음 조합 찾기

**문제**: 집합 {1, 2, 3, 4, 5, 6, 7}의 3-조합에서 {2, 5, 7} 다음으로 큰 조합을 찾아라.

> 💡 힌트:
> - a₁=2, a₂=5, a₃=7
> - a₃=7, n-r+3 = 7-3+3 = 7 → 최댓값
> - a₂=5, n-r+2 = 7-3+2 = 6 → 아직 최댓값 아님! → i=2
> - a₂를 6으로, a₃를 7로

<details>
<summary>📝 답 보기</summary>

답: **{2, 6, 7}**

단계별 풀이:
1. a₃ = 7 = 7 (최댓값) → 건너뜀
2. a₂ = 5 ≠ 6 (최댓값) → i = 2
3. a₂ = 5 + 1 = 6
4. a₃ = 6 + 1 = 7

결과: {2, 6, 7}

```lean
-- 확인: {2,6,7}은 유효한 3-조합이다
-- 모든 원소가 {1,...,7}에 속하고 크기가 3이다
example : 2 < 6 ∧ 6 < 7 ∧ 7 ≤ 7 := by omega
```

</details>

---

### 🏋️ 연습 9H.5 — 다음 조합 찾기 (2)

**문제**: 집합 {1, 2, 3, 4, 5}의 3-조합에서 {1, 3, 5} 다음으로 큰 조합을 찾아라.

<details>
<summary>📝 답 보기</summary>

답: **{2, 3, 4}**

단계별 풀이:
1. a₃ = 5, n-r+3 = 5-3+3 = 5 → 최댓값
2. a₂ = 3, n-r+2 = 5-3+2 = 4 → 최댓값 아님! → i=2 ... 잠깐, 다시 확인.
   - a₂ = 3, 최댓값 = 4 → 3 ≠ 4 → i = 2

잠깐, 이건 틀렸다. 다시 계산:
1. a₃ = 5 = 5 → 최댓값
2. a₂ = 3 ≠ 4 → i = 2
3. a₂ = 3 + 1 = 4, a₃ = 4 + 1 = 5 → {1, 4, 5}

그런데 {1, 3, 5} 다음이 {1, 4, 5}인지 확인하자.
사전순으로: {1,2,3}, {1,2,4}, {1,2,5}, {1,3,4}, **{1,3,5}**, **{1,4,5}**, {2,3,4}, ...

맞다! 답은 **{1, 4, 5}**이다.

```lean
-- {1,4,5}가 {1,3,5} 다음인지 확인
example : [1, 4, 5] > [1, 3, 5] := by decide
```

</details>

---

## 9H.5 Lean 4에서 순열과 조합 나열하기

Lean 4의 Mathlib에서는 Finset의 부분집합이나 순열을 직접 나열할 수 있는 도구들이 있다.

### 부분집합(조합) 나열

```lean
import Mathlib

open Finset

-- {0, 1, 2}의 모든 부분집합
#eval (Finset.range 3).powerset
-- 결과: {∅, {0}, {1}, {2}, {0,1}, {0,2}, {1,2}, {0,1,2}}

-- {0, 1, 2, 3}에서 크기 2인 부분집합들 (2-조합)
#eval (Finset.range 4).powersetCard 2
-- 결과: {{0,1}, {0,2}, {0,3}, {1,2}, {1,3}, {2,3}}

-- 크기 확인: C(4, 2) = 6
example : ((Finset.range 4).powersetCard 2).card = Nat.choose 4 2 := by
  simp [card_powersetCard]
```

`powersetCard r s`는 `s`의 크기 r인 부분집합을 모두 담은 Finset이다. 이것이 바로 "r-조합을 생성"하는 Lean 4의 방법이다!

### 순열 나열

```lean
-- Fin n의 모든 순열은 Equiv.Perm (Fin n)으로 표현된다
-- 이것은 Fintype이므로 모든 원소를 나열할 수 있다

-- 순열의 수 확인
example : Fintype.card (Equiv.Perm (Fin 3)) = 6 := by
  simp [Fintype.card_perm]

example : Fintype.card (Equiv.Perm (Fin 4)) = 24 := by
  simp [Fintype.card_perm]
```

### 🏋️ 연습 9H.6 — Lean 4로 조합 세기

**문제**: 집합 {0, 1, 2, 3, 4}에서 크기 3인 부분집합의 수를 Lean 4로 증명하여라.

```lean
-- 괄호를 채우세요
example : ((Finset.range 5).powersetCard 3).card = (⟨여기를 채우세요⟩) := by
  simp [card_powersetCard]
```

<details>
<summary>📝 답 보기</summary>

```lean
example : ((Finset.range 5).powersetCard 3).card = 10 := by
  simp [card_powersetCard]
```

C(5, 3) = 10

</details>

---

### 🏋️ 연습 9H.7 — sorry 채우기 종합

**문제**: 다음 정리를 증명하여라 — 모든 부분집합의 수는 2ⁿ이다.

```lean
-- sorry를 채워 보세요
example (n : ℕ) : (Finset.range n).powerset.card = 2 ^ n := by
  sorry
```

<details>
<summary>📝 답 보기</summary>

```lean
example (n : ℕ) : (Finset.range n).powerset.card = 2 ^ n := by
  simp [card_powerset]
```

`card_powerset`는 `s.powerset.card = 2 ^ s.card`를 말하고, `card_range n`은 `(range n).card = n`을 말한다. `simp`가 이 둘을 자동으로 적용한다.

</details>

---

### 🏋️ 연습 9H.8 — sorry 채우기

**문제**: {0, 1, ..., 5}의 4-순열(4-permutation)의 수가 P(6, 4) = 360임을 증명하여라.

```lean
-- P(6, 4) = 6! / (6-4)! = 6! / 2! = 720 / 2 = 360
-- sorry를 채워 보세요
example : Nat.descFactorial 6 4 = sorry := by native_decide
```

<details>
<summary>📝 답 보기</summary>

```lean
example : Nat.descFactorial 6 4 = 360 := by native_decide
```

`Nat.descFactorial 6 4` = 6 × 5 × 4 × 3 = 360

</details>

---

## 9H.6 종합 연습 — 6장 전체 복습

이 연습들은 6장(계수) 전체에서 배운 개념들을 종합적으로 활용한다.

### 연습 9H.9 — 종합 (교재 연습문제 32번 변형)

**문제**: "MISSISSIPPI"에 있는 문자들을 모두 사용해서 만들 수 있는 서로 다른 문자열은 모두 몇 개인가?

> M: 1개, I: 4개, S: 4개, P: 2개 → 총 11글자
> 11! / (1! · 4! · 4! · 2!)

```lean
-- sorry를 채워 보세요
example : Nat.factorial 11 /
  (Nat.factorial 1 * Nat.factorial 4 * Nat.factorial 4 * Nat.factorial 2)
  = sorry := by native_decide
```

<details>
<summary>📝 답 보기</summary>

```lean
example : Nat.factorial 11 /
  (Nat.factorial 1 * Nat.factorial 4 * Nat.factorial 4 * Nat.factorial 2)
  = 34650 := by native_decide
```

11! = 39916800
1! × 4! × 4! × 2! = 1 × 24 × 24 × 2 = 1152
39916800 / 1152 = 34650

</details>

---

### 연습 9H.10 — 종합 (교재 연습문제 43번 변형)

**문제**: 52장의 표준 카드에서 5명의 경기자 각각에게 7장의 카드를 나누어주는 방법의 수는 몇 가지인가? (나머지 17장은 남긴다.)

> 52장에서 5명에게 7장씩 = 구별 가능한 객체를 구별 가능한 상자에 넣기 (크기 지정)
> 52! / (7!)⁵ · 17!

```lean
-- sorry를 채워 보세요
-- C(52,7) × C(45,7) × C(38,7) × C(31,7) × C(24,7) 과 동일
example : Nat.choose 52 7 * Nat.choose 45 7 * Nat.choose 38 7 *
          Nat.choose 31 7 * Nat.choose 24 7 = sorry := by native_decide
```

<details>
<summary>📝 답 보기</summary>

```lean
example : Nat.choose 52 7 * Nat.choose 45 7 * Nat.choose 38 7 *
          Nat.choose 31 7 * Nat.choose 24 7 = 3954242643911239680000 := by native_decide
```

</details>

---

### 연습 9H.11 — 종합

**문제**: 서로 다른 10권의 책을 서로 다른 4개의 상자에 넣을 때, 각 상자에 적어도 1권이 들어가야 한다면 방법의 수는 몇 가지인가?

> 💡 힌트: 이것은 **포함-배제 원리**(inclusion-exclusion principle)를 사용해야 하는 문제다.
> 전체 방법(4¹⁰)에서 빈 상자가 있는 경우를 빼면 된다.
> 답 = Σⱼ₌₁⁴ S(10, j) × j! 또는 포함-배제로:
> Σᵢ₌₀³ (-1)ⁱ C(4,i) (4-i)¹⁰

```lean
-- 포함-배제 원리 적용
-- C(4,0)·4¹⁰ - C(4,1)·3¹⁰ + C(4,2)·2¹⁰ - C(4,3)·1¹⁰
-- = 1·1048576 - 4·59049 + 6·1024 - 4·1
-- = 1048576 - 236196 + 6144 - 4
-- = 818520

example : 1048576 - 236196 + 6144 - 4 = 818520 := by norm_num
```

<details>
<summary>📝 답 보기</summary>

포함-배제 원리를 적용한다:

- 빈 상자가 0개 이상: 4¹⁰ = 1048576
- 특정 1개 상자가 비어있는 경우: C(4,1) · 3¹⁰ = 4 · 59049 = 236196
- 특정 2개 상자가 비어있는 경우: C(4,2) · 2¹⁰ = 6 · 1024 = 6144
- 특정 3개 상자가 비어있는 경우: C(4,3) · 1¹⁰ = 4 · 1 = 4

포함-배제: 1048576 - 236196 + 6144 - 4 = **818520**

```lean
example : 1048576 - 236196 + 6144 - 4 = 818520 := by norm_num
```

</details>

---

## 9H.7 전술 요약 및 핵심 함수

이번 파트에서 새로 사용한 Lean 4의 핵심 개념과 전술을 정리하면:

| 개념/함수 | 설명 | 예시 |
|---------|------|------|
| `Finset.powerset` | 부분집합 전체의 Finset | `(range 3).powerset` |
| `Finset.powersetCard r` | 크기 r인 부분집합들의 Finset | `(range 5).powersetCard 2` |
| `card_powerset` | `s.powerset.card = 2^(s.card)` | 부분집합 총수 증명 |
| `card_powersetCard` | `(s.powersetCard r).card = C(s.card, r)` | r-조합의 수 |
| `Equiv.Perm (Fin n)` | n개 원소의 순열(전단사 함수) | `card_perm` |
| `List.Lex` | 리스트의 사전순 비교 | 순서 비교 |
| `Nat.descFactorial n r` | 하강 팩토리얼 P(n,r) | `descFactorial 6 4 = 360` |
| `decide` | 결정 가능한 명제의 자동 증명 | 리스트 비교 등 |

---

## 9H.8 6장 전체 핵심 공식 총정리

6장(계수)에서 배운 모든 핵심 공식을 한 눈에 정리한다:

| 이름 | 공식 | Lean 4 |
|------|------|--------|
| **곱셈 법칙** | \|A × B\| = \|A\| · \|B\| | `card_product` |
| **덧셈 법칙** | \|A ∪ B\| = \|A\| + \|B\| (서로소) | `card_union_of_disjoint` |
| **뺄셈 법칙** | \|A ∪ B\| = \|A\| + \|B\| - \|A ∩ B\| | `card_union` |
| **나눗셈 법칙** | 동치류의 수 = \|S\|/d | — |
| **비둘기집 원리** | n+1개 → n개 상자: 중복 존재 | `exists_ne_map_eq_of_card_lt` |
| **순열** P(n,r) | n!/(n-r)! | `Nat.descFactorial` |
| **조합** C(n,r) | n!/[r!(n-r)!] | `Nat.choose` |
| **이항 정리** | (x+y)ⁿ = ΣC(n,k)xⁿ⁻ᵏyᵏ | `Commute.add_pow` |
| **파스칼 항등식** | C(n+1,k) = C(n,k-1)+C(n,k) | `Nat.choose_succ_succ` |
| **반복 허용 순열** | nʳ | `card (Fin r → Fin n)` |
| **반복 허용 조합** | C(n+r-1, r) | `Nat.choose (n+r-1) r` |
| **다항 계수** | n!/(n₁!⋯nₖ!) | `Nat.multinomial` |

---

## 다음 파트 예고

6장(계수)의 모든 내용을 다루었다! Part 9 시리즈를 요약하면:

| 파트 | 내용 | 교재 절 |
|------|------|--------|
| 9-A | 곱셈 법칙, 덧셈 법칙, Finset 기초 | §6.1 |
| 9-B | 뺄셈 법칙, 나눗셈 법칙, 트리 도표 | §6.1 |
| 9-C | 비둘기집 원리 | §6.2 |
| 9-D | 순열과 조합 | §6.3 |
| 9-E | 이항 정리와 파스칼 삼각형 | §6.4 |
| 9-F | 일반화된 순열과 조합 (기초) | §6.5 |
| 9-G | 객체를 상자에 분배하기, 분할 | §6.5 |
| 9-H | 순열과 조합의 생성 | §6.6 |

다음 Part 10에서는 Rosen 8장의 **이산 확률**(Discrete Probability) 또는 7장의 **관계**(Relations)를 다룰 예정이다.
