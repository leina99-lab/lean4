# Lean4 완전 정복 가이드 — 제6-F편 (1/2)

## **알고리즘 복잡도 심화**(Advanced Algorithm Complexity) — 호너의 방법과 비트 연산 시간

> **교재**: Kenneth H. Rosen, "Discrete Mathematics and Its Applications" 8판  
> **범위**: 3.3절 연습문제 13~21  
> **선수 학습**: 제6-E편(연산 횟수의 Big-O 추정)  
> **참고**: 『Mathematics in Lean』 Chapter 2 (Basics)

---

## 6F.0 이 장의 목표

1. **다항식 계산**의 두 가지 방법 비교: 전통적 방법 vs **호너의 방법**(Horner's method)
2. **비트 연산 시간**을 이용한 복잡도 계산
3. **입력 크기 변화**(2배, +1)에 따른 시간 변화

---

## 6F.1 다항식 계산: 전통적 방법

### 6F.1.1 다항식이란?

**다항식**(polynomial)은 다음과 같은 형태의 수식이다:

$$p(x) = a_n x^n + a_{n-1} x^{n-1} + \cdots + a_1 x + a_0$$

여기서 `aₙ, aₙ₋₁, ..., a₁, a₀`는 **계수**(coefficient)이고, `x`는 변수, `n`은 **차수**(degree)이다.

예: `p(x) = 3x² + x + 1`은 차수 2의 다항식이며, 계수는 `a₂ = 3, a₁ = 1, a₀ = 1`이다.

### 6F.1.2 전통적 방법의 알고리즘

x = c에서 n차 다항식의 값을 구하는 전통적인 알고리즘은 다음과 같다:

```
-- 전통적 다항식 계산
power := 1
y := a₀
for i := 1 to n
    power := power * c     -- c^i를 계산
    y := y + aᵢ * power    -- aᵢ * c^i를 더함
```

각 반복에서 어떤 연산이 일어나는지 자세히 보자:

| 줄 | 연산 | 종류 |
|---|------|------|
| `power := power * c` | power에 c를 곱함 | 곱셈 1번 |
| `aᵢ * power` | 계수와 거듭제곱을 곱함 | 곱셈 1번 |
| `y := y + ...` | 누적 합에 더함 | 덧셈 1번 |

루프가 n번 반복하므로:
- 곱셈: n + n = **2n번**
- 덧셈: **n번**

### 교재 연습문제 13(a): 추적하기

> x = 2일 때 `3x² + x + 1`을 구하는 데, 알고리즘의 각 단계를 수행하면서 변수 값을 추적하라.

```lean
-- x = 2, 다항식: 3x² + x + 1
-- 계수: a₀ = 1, a₁ = 1, a₂ = 3

-- 초기: power = 1, y = a₀ = 1

-- i = 1:
--   power = 1 * 2 = 2        (곱셈 1번)
--   y = 1 + 1 * 2 = 3        (곱셈 1번, 덧셈 1번)

-- i = 2:
--   power = 2 * 2 = 4        (곱셈 1번)
--   y = 3 + 3 * 4 = 15       (곱셈 1번, 덧셈 1번)

-- 결과: y = 15
-- 검산: 3(2²) + 2 + 1 = 12 + 2 + 1 = 15 ✓

#eval 3 * 2 ^ 2 + 2 + 1  -- 15
```

### 교재 연습문제 13(b): 연산 횟수

> x = c일 때 n차 다항식의 값을 구하기 위해서 곱셈과 덧셈을 정확히 몇 번 하는가?

```lean
-- 전통적 방법:
-- 곱셈: 2n번 (power * c가 n번, aᵢ * power가 n번)
-- 덧셈: n번

def traditional_muls (n : Nat) : Nat := 2 * n
def traditional_adds (n : Nat) : Nat := n

#eval traditional_muls 10   -- 20
#eval traditional_adds 10   -- 10
```

---

## 6F.2 호너의 방법: 더 효율적인 다항식 계산

### 6F.2.1 핵심 아이디어

**호너의 방법**(Horner's method)은 다항식을 **중첩된 곱셈**으로 변환하는 것이다.

원래 형태:

$$a_n x^n + a_{n-1} x^{n-1} + \cdots + a_1 x + a_0$$

호너의 형태:

$$(\cdots((a_n x + a_{n-1}) x + a_{n-2}) x + \cdots + a_1) x + a_0$$

예를 들어, `3x² + x + 1`을 호너의 방법으로 다시 쓰면:

$$3x^2 + x + 1 = (3x + 1)x + 1$$

왜 이렇게 되는지 역추적해보자:

```
(3x + 1)x + 1
= 3x · x + 1 · x + 1     -- 분배법칙
= 3x² + x + 1             -- 정리
```

즉, 괄호를 풀면 원래 다항식이 된다!

### 6F.2.2 호너의 알고리즘

```
-- 호너의 방법
procedure Horner(c, a₀, a₁, a₂, ..., aₙ)
y := aₙ
for i := 1 to n
    y := y * c + aₙ₋ᵢ
return y
```

각 반복에서:
- `y * c` → 곱셈 **1번**
- `+ aₙ₋ᵢ` → 덧셈 **1번**

루프가 n번 반복하므로:
- 곱셈: **n번**
- 덧셈: **n번**

전통적 방법의 곱셈 2n번에 비해 **절반**이다!

### 6F.2.3 Lean4로 호너의 방법 구현

```lean
-- List.foldl을 이용한 호너의 방법 구현
-- coeffs: [aₙ, aₙ₋₁, ..., a₁, a₀] (최고차부터 나열)
def horner (coeffs : List Nat) (c : Nat) : Nat :=
  coeffs.foldl (fun acc a => acc * c + a) 0
```

> **`List.foldl`이란?**  
> `foldl f init [a, b, c]`는 `f (f (f init a) b) c`를 계산한다.  
> 리스트를 왼쪽부터 순서대로 접어가며(fold) 누적 계산하는 함수이다.  
> 호너의 방법에서 `f = fun acc a => acc * c + a`이다.

단계별로 풀어보면:
```
horner [3, 1, 1] 2
= foldl f 0 [3, 1, 1]
= foldl f (f 0 3) [1, 1]     -- f 0 3 = 0 * 2 + 3 = 3
= foldl f (f 3 1) [1]         -- f 3 1 = 3 * 2 + 1 = 7
= foldl f (f 7 1) []           -- f 7 1 = 7 * 2 + 1 = 15
= 15
```

```lean
#eval horner [3, 1, 1] 2   -- 15 ✓
```

### 교재 연습문제 14(a): 호너의 방법 추적

> x = 2일 때 `3x² + x + 1`을 호너의 방법으로 구하라.

```lean
-- 계수: a₂ = 3, a₁ = 1, a₀ = 1
-- 호너 순서: y = a₂ → y*c + a₁ → y*c + a₀

-- 초기: y = 3

-- i = 1: y = 3 * 2 + 1 = 7    (곱셈 1번, 덧셈 1번)
-- i = 2: y = 7 * 2 + 1 = 15   (곱셈 1번, 덧셈 1번)

-- 결과: y = 15 ✓
-- 곱셈 2번, 덧셈 2번 (전통적 방법: 곱셈 4번, 덧셈 2번)
```

### 두 방법의 비교 요약

| | 전통적 방법 | 호너의 방법 |
|---|----------|-----------|
| 곱셈 횟수 | 2n | n |
| 덧셈 횟수 | n | n |
| 총 연산 | 3n | 2n |
| Big-O | O(n) | O(n) |

Big-O 차수는 같지만, 호너의 방법이 **상수 배만큼 더 빠르다**. 실제 프로그래밍에서는 이 차이가 중요할 수 있다.

### 연습 6F.1: 호너의 방법 추적 (괄호 채우기)

**문제**: `2x³ + 3x² + 5x + 7`, x = 3을 호너의 방법으로 계산하시오.

```
계수를 최고차부터: a₃ = 2, a₂ = 3, a₁ = 5, a₀ = 7

초기: y = ▢

i = 1: y = ▢ * 3 + ▢ = ▢
i = 2: y = ▢ * 3 + ▢ = ▢
i = 3: y = ▢ * 3 + ▢ = ▢
```

<details>
<summary>💡 답 보기</summary>

```
초기: y = 2

i = 1: y = 2 * 3 + 3 = 9
i = 2: y = 9 * 3 + 5 = 32
i = 3: y = 32 * 3 + 7 = 103

검산: 2(27) + 3(9) + 5(3) + 7 = 54 + 27 + 15 + 7 = 103 ✓
```

```lean
#eval horner [2, 3, 5, 7] 3         -- 103
#eval 2 * 3^3 + 3 * 3^2 + 5 * 3 + 7  -- 103
```

</details>

### 연습 6F.2: 연산 횟수 비교 증명 (sorry)

**문제**: 차수 n인 다항식에서 호너의 방법이 전통적 방법보다 곱셈이 적음을 Lean4로 증명하시오.

```lean
-- 호너: n번 곱셈, 전통적: 2n번 곱셈
-- n ≥ 1이면 n < 2n

theorem horner_fewer_muls :
    ∀ n : Nat, n ≥ 1 → n < 2 * n := by
  sorry
```

<details>
<summary>💡 답 보기</summary>

```lean
theorem horner_fewer_muls :
    ∀ n : Nat, n ≥ 1 → n < 2 * n := by
  intro n hn
  omega
```

`omega`가 `n ≥ 1 → n < 2 * n`을 자동으로 증명한다. 이것은 선형 산술의 영역이다.

</details>

### 연습 6F.3: 호너의 방법 직접 구현 (sorry)

**문제**: 다음 Lean4 함수를 완성하시오. `horner_manual`은 호너의 방법을 재귀적으로 구현한다.

```lean
-- 호너의 방법: 재귀 버전
-- coeffs: [aₙ, aₙ₋₁, ..., a₁, a₀]
def horner_manual : List Nat → Nat → Nat
  | [], _ => 0
  | [a], _ => a
  | a :: rest, c => sorry  -- 여기를 채우시오
```

<details>
<summary>💡 답 보기</summary>

```lean
def horner_manual : List Nat → Nat → Nat
  | [], _ => 0
  | [a], _ => a
  | a :: rest, c => horner_manual (rest.head! + a * c :: rest.tail) c
  -- 사실 foldl 버전이 더 깔끔하다:
  -- horner_manual coeffs c = coeffs.foldl (fun acc a => acc * c + a) 0
```

실용적으로는 `foldl` 버전이 더 깔끔하고 효율적이다. 재귀 버전은 개념 이해용이다.

</details>

---

## 6F.3 비트 연산 시간과 복잡도

### 6F.3.1 비트 연산이란?

지금까지 우리는 "비교 1번", "덧셈 1번"을 **기본 연산** 1번으로 세었다. 하지만 실제 컴퓨터에서는 큰 수의 덧셈이 작은 수의 덧셈보다 시간이 더 걸린다.

**비트 연산**(bit operation)은 가장 낮은 수준의 연산으로, 0과 1에 대한 AND, OR, NOT 등이다.

**핵심**: n비트 정수 두 개를 더하려면 약 **n번의 비트 연산**이 필요하다.

### 6F.3.2 교재 연습문제 15

> 한 비트 연산을 수행하는 데 10⁻⁹초가 걸릴 때, f(n) 비트 연산이 필요한 알고리즘이 **1초에** 풀 수 있는 문제 중 가장 큰 n값은?

기본 원리: 1초 = 10⁹ 비트 연산이므로, f(n) ≤ 10⁹를 만족하는 가장 큰 n을 구한다.

| f(n) | f(n) ≤ 10⁹의 해 | 최대 n |
|------|---------------|-------|
| log n | n ≤ 2^(10⁹) | 천문학적으로 큼 |
| n | n ≤ 10⁹ | 10⁹ |
| n log n | ≈ 10⁹ / 30 | ≈ 3.3 × 10⁷ |
| n² | n ≤ √(10⁹) | ≈ 31,623 |
| 2ⁿ | n ≤ log₂(10⁹) | ≈ 30 |
| n! | n! ≤ 10⁹ | 12 |

```lean
-- Lean4로 확인
#eval Nat.log 2 1000000000            -- 29
#eval Nat.sqrt 1000000000              -- 31622
#eval Nat.factorial 12                  -- 479001600
#eval Nat.factorial 13                  -- 6227020800
-- 12! < 10⁹ < 13! 이므로 최대 n = 12
```

> **교훈**: f(n)의 **증가 속도**에 따라 풀 수 있는 문제의 크기가 극적으로 달라진다!  
> - f(n) = n이면 10억 크기까지 풀 수 있다  
> - f(n) = 2ⁿ이면 겨우 30 크기까지밖에 못 푼다  
> - f(n) = n!이면 12 크기가 한계이다

### 연습 6F.4: 비트 연산 시간 계산 (괄호 채우기)

**문제**: 한 비트 연산에 10⁻¹¹초가 걸릴 때 (연습문제 16), **1시간**(= 3600초)에 풀 수 있는 문제의 최대 크기 n을 구하시오.

```
1시간 = 3600 × 10¹¹ = 3.6 × 10¹⁴ 비트 연산

(a) f(n) = n → n ≤ ▢
(b) f(n) = n² → n ≤ √(3.6 × 10¹⁴) ≈ ▢
(c) f(n) = 2ⁿ → n ≤ log₂(3.6 × 10¹⁴) ≈ ▢
```

<details>
<summary>💡 답 보기</summary>

```
(a) f(n) = n → n ≤ 3.6 × 10¹⁴ (= 360,000,000,000,000)
(b) f(n) = n² → n ≤ √(3.6 × 10¹⁴) ≈ 18,973,666
(c) f(n) = 2ⁿ → n ≤ log₂(3.6 × 10¹⁴) ≈ 48
```

```lean
#eval Nat.sqrt 360000000000000   -- 18973665
#eval Nat.log 2 360000000000000  -- 48
```

**교훈**: 1시간이라는 긴 시간이 주어져도, 지수적 복잡도(2ⁿ)에서는 n = 48이 한계이다!

</details>

---

## 6F.4 교재 연습문제 17: 1분에 풀 수 있는 최대 n

> 한 비트 연산을 수행하는 데 10⁻¹²초가 걸릴 때, f(n) 비트 연산이 필요한 알고리즘이 **1분에** 풀 수 있는 문제 중 가장 큰 n값은?

```lean
-- 1분 = 60 × 10¹² = 6 × 10¹³ 비트 연산

-- (a) f(n) = log₂ n
-- log₂ n ≤ 6 × 10¹³ → n ≤ 2^(6 × 10¹³)
-- 이 값은 너무 커서 계산할 수 없다!

-- (b) f(n) = log n
#eval Nat.sqrt 60000000000000        -- (d) n²: n ≈ 7745966

-- (c) f(n) = (log n)²
-- (log₂ n)² ≤ 6 × 10¹³
-- log₂ n ≤ √(6 × 10¹³) ≈ 7745966
-- n ≤ 2^7745966 (천문학적!)

-- (e) f(n) = n²
#eval Nat.sqrt 60000000000000        -- 7745966

-- (f) f(n) = 2ⁿ
#eval Nat.log 2 60000000000000       -- 45

-- (g) f(n) = 2^(n²)
-- 2^(n²) ≤ 6 × 10¹³ → n² ≤ log₂(6 × 10¹³) ≈ 45
-- n ≤ √45 ≈ 6
#eval Nat.sqrt 45                     -- 6
```

### 연습 6F.5: 결과 정리 (괄호 채우기)

**문제**: 위 계산 결과를 정리하시오.

```
f(n)       | 1분에 풀 수 있는 최대 n
-----------|------------------------
log₂ n     | 2^(6 × 10¹³) (사실상 무한)
n          | ▢
n²         | ▢
2ⁿ         | ▢
2^(n²)     | ▢
```

<details>
<summary>💡 답 보기</summary>

```
f(n)       | 1분에 풀 수 있는 최대 n
-----------|------------------------
log₂ n     | 2^(6 × 10¹³) (사실상 무한)
n          | 6 × 10¹³ (= 60조)
n²         | ≈ 7,745,966 (약 775만)
2ⁿ         | 45
2^(n²)     | 6
```

f(n)이 빠르게 증가할수록, 풀 수 있는 문제의 크기가 급격히 작아진다.

</details>

---

## 6F.5 입력 크기 2배 변화에 따른 시간 변화

### 교재 연습문제 20

> 입력의 크기가 n일 때 알고리즘이 사용한 시간의 밀리세컨드 수가 f(n)과 같다면, 입력의 크기를 n에서 **2n으로 두 배** 늘리면 시간이 어떻게 바뀌는가?

핵심 원리: f(2n) / f(n)의 비율을 구한다.

| f(n) | f(2n) | f(2n)/f(n) | 해석 |
|------|-------|-----------|------|
| log n | log(2n) = log 2 + log n | ≈ 1 + 상수/log n | 약간 증가 |
| n | 2n | 2 | 정확히 2배 |
| n log n | 2n · log(2n) | ≈ 2 + 2/log n | 약 2배 + α |
| n² | 4n² | 4 | 정확히 4배 |
| n³ | 8n³ | 8 | 정확히 8배 |
| 2ⁿ | 2²ⁿ = (2ⁿ)² | 2ⁿ | **제곱배!** |

```lean
-- Lean4로 검증
-- f(n) = n²
#eval 100 ^ 2           -- 10000
#eval 200 ^ 2           -- 40000
-- 비율: 40000 / 10000 = 4 ✓

-- f(n) = n³
#eval 100 ^ 3           -- 1000000
#eval 200 ^ 3           -- 8000000
-- 비율: 8000000 / 1000000 = 8 ✓

-- f(n) = 2ⁿ (작은 n으로)
#eval (2 : Nat) ^ 10    -- 1024
#eval (2 : Nat) ^ 20    -- 1048576
-- 비율: 1048576 / 1024 = 1024 = 2¹⁰ ✓
```

### Lean4 증명: n²에서 2배 → 4배

```lean
-- Big-O 정의 (6-C편에서 가져옴)
def IsBigO (f g : Nat → Nat) : Prop :=
  ∃ C : Nat, ∃ k : Nat, ∀ n : Nat, n > k → f n ≤ C * g n

-- (2n)² = 4n² 임을 증명
theorem double_sq (n : Nat) : (2 * n) ^ 2 = 4 * n ^ 2 := by
  ring

-- (2n)³ = 8n³ 임을 증명
theorem double_cube (n : Nat) : (2 * n) ^ 3 = 8 * n ^ 3 := by
  ring
```

### 연습 6F.6: 시간 변화 증명 (sorry)

**문제**: 다음을 증명하시오.

```lean
-- 2^(2n) = (2^n)² 임을 증명
theorem exp_double_sq (n : Nat) :
    (2 : Nat) ^ (2 * n) = ((2 : Nat) ^ n) ^ 2 := by
  sorry
```

<details>
<summary>💡 답 보기</summary>

```lean
theorem exp_double_sq (n : Nat) :
    (2 : Nat) ^ (2 * n) = ((2 : Nat) ^ n) ^ 2 := by
  rw [pow_mul]
  ring
```

또는 더 간단하게:

```lean
theorem exp_double_sq (n : Nat) :
    (2 : Nat) ^ (2 * n) = ((2 : Nat) ^ n) ^ 2 := by
  ring
```

**의미**: 입력이 2배가 되면 2ⁿ 알고리즘의 시간은 **제곱**이 된다. 즉, 원래 100초 걸렸다면 10000초가 걸린다!

</details>

---

## 6F.6 입력 크기 +1에 따른 시간 변화

### 교재 연습문제 21

> 입력의 크기를 n에서 **n+1**로 증가시키면 시간이 어떻게 바뀌는가?

| f(n) | f(n+1) - f(n) | 의미 |
|------|--------------|------|
| log n | log(n+1) - log n | 매우 작음 (≈ 0) |
| 100n | 100 | 상수 100 증가 |
| n² | 2n + 1 | 약 2n 증가 |
| n³ | 3n² + 3n + 1 | 약 3n² 증가 |
| 2ⁿ | 2ⁿ | **현재 시간만큼** 추가 |
| n! | n · n! | **n배** 증가 |

### 핵심 증명들

```lean
-- (n+1)² - n² = 2n + 1
theorem sq_diff (n : Nat) :
    (n + 1) ^ 2 = n ^ 2 + 2 * n + 1 := by
  ring

-- 2^(n+1) = 2 * 2^n
theorem exp_step (n : Nat) :
    (2 : Nat) ^ (n + 1) = 2 * (2 : Nat) ^ n := by
  ring

-- (n+1)! = (n+1) * n!
theorem factorial_step (n : Nat) :
    Nat.factorial (n + 1) = (n + 1) * Nat.factorial n := by
  rfl  -- Lean4에서 factorial의 정의에 의해 자명
```

> **`rfl` 전술이란?**  
> `rfl`은 "reflexivity"의 약자로, 양변이 **정의에 의해 동일**할 때 사용한다. `(n+1)!`이 `(n+1) * n!`으로 **정의**되어 있으므로, Lean4는 이를 즉시 인정한다.  
> 반면 `ring`은 **대수적 변환**을 통해 등식을 증명한다. `(n+1)² = n² + 2n + 1`은 정의가 아니라 **계산 결과**이므로 `ring`이 필요하다.

### 연습 6F.7: 시간 변화 증명 (sorry)

**문제**: (n+1)³ = n³ + 3n² + 3n + 1임을 증명하시오.

```lean
theorem cube_diff (n : Nat) :
    (n + 1) ^ 3 = n ^ 3 + 3 * n ^ 2 + 3 * n + 1 := by
  sorry
```

<details>
<summary>💡 답 보기</summary>

```lean
theorem cube_diff (n : Nat) :
    (n + 1) ^ 3 = n ^ 3 + 3 * n ^ 2 + 3 * n + 1 := by
  ring
```

이것은 **이항 정리**(binomial theorem)의 n = 3인 경우이다:

$$(a + b)^3 = a^3 + 3a^2b + 3ab^2 + b^3$$

a = n, b = 1을 대입하면 된다.

</details>

---

## 6F.7 종합 비교표: 복잡도별 시간 변화

| 복잡도 | n→2n (2배) | n→n+1 (+1) | n=100만일 때 (10⁹/초) |
|-------|-----------|-----------|-------------------|
| O(log n) | +상수 | ≈ 0 | 0.00002초 |
| O(n) | 2배 | +상수 | 0.001초 |
| O(n log n) | ≈ 2배 | ≈ log n | 0.02초 |
| O(n²) | 4배 | +2n | 17분 |
| O(n³) | 8배 | +3n² | 31.7년 |
| O(2ⁿ) | 제곱배 | 2배 | 우주보다 오래 |
| O(n!) | 엄청남 | n배 | 우주보다 훨씬 오래 |

```lean
-- 실감을 위한 #eval 모음
-- n = 100일 때 각 복잡도의 연산 횟수

#eval Nat.log 2 100                  -- 6
#eval (100 : Nat)                     -- 100
#eval 100 * Nat.log 2 100            -- 600
#eval 100 ^ 2                         -- 10000
#eval 100 ^ 3                         -- 1000000
-- 2^100은 너무 커서 표시가 어렵다
-- #eval (2 : Nat) ^ 100  -- 매우 큰 수
```

---

## 6F.8 교재 연습문제 18~19: 혼합 복잡도

### 연습문제 18

> 어떤 알고리즘이 **2n² + 2ⁿ**개의 연산을 사용하고 각 연산에 10⁻⁹초가 걸린다면?

```lean
def ops_ex18 (n : Nat) : Nat := 2 * n ^ 2 + 2 ^ n

#eval ops_ex18 10    -- 200 + 1024 = 1224
#eval ops_ex18 20    -- 800 + 1048576 = 1049376
#eval ops_ex18 50    -- 5000 + 2^50 ≈ 1.13 × 10¹⁵
```

n이 커지면 `2ⁿ`이 `2n²`보다 **압도적으로** 커진다.

- n = 10: 1224 연산 → 약 0.000001초
- n = 20: 약 100만 연산 → 약 0.001초
- n = 50: 약 10¹⁵ 연산 → 약 100만 초 ≈ **12일**
- n = 100: 약 10³⁰ 연산 → 우주의 나이보다 오래

> **교훈**: 복잡도가 `2n² + 2ⁿ`이면, Big-O는 **O(2ⁿ)**이다. 다항식 항(2n²)은 지수 항(2ⁿ)에 비해 무시할 수 있다.

### 연습 6F.8: Big-O 증명 (sorry)

**문제**: `2n² + 2ⁿ`은 `O(2ⁿ)`임을 증명하시오.

```lean
-- 2n² + 2ⁿ 은 O(2ⁿ)
theorem ex18_O_exp :
    IsBigO (fun n => 2 * n ^ 2 + 2 ^ n) (fun n => 2 ^ n) := by
  sorry
```

<details>
<summary>💡 답 보기</summary>

```lean
theorem ex18_O_exp :
    IsBigO (fun n => 2 * n ^ 2 + 2 ^ n) (fun n => 2 ^ n) := by
  use 2, 5
  intro n hn
  -- n > 5이면 2n² ≤ 2ⁿ이므로
  -- 2n² + 2ⁿ ≤ 2ⁿ + 2ⁿ = 2 · 2ⁿ
  -- 이 증명은 n > 5에서 2n² ≤ 2ⁿ을 보여야 하므로 기술적이다
  -- nlinarith와 Nat.pow 관련 보조 정리가 필요할 수 있다
  sorry  -- 실제 증명은 꽤 기술적이다
```

**참고**: 이 증명은 `2n² ≤ 2ⁿ` (n ≥ 6)을 요구하는데, Lean4에서 지수 함수와 다항 함수의 비교는 상당히 기술적이다. 중학생 수준에서는 "n이 충분히 크면 2ⁿ이 2n²보다 훨씬 빠르게 증가한다"는 직관적 이해로 충분하다.

```lean
-- 작은 값으로 확인
#eval (2 * 6^2, (2:Nat)^6)    -- (72, 64)  아직 2n² > 2ⁿ
#eval (2 * 7^2, (2:Nat)^7)    -- (98, 128) 여기서 역전!
#eval (2 * 10^2, (2:Nat)^10)  -- (200, 1024)
```

</details>

### 연습문제 19: 2⁵⁰ 비트 연산의 소요 시간

```lean
#eval (2 : Nat) ^ 50   -- 1125899906842624

-- (a) 10⁻⁶초/연산: 2⁵⁰ × 10⁻⁶ ≈ 1.13 × 10⁹초 ≈ 35.7년
-- (b) 10⁻⁹초/연산: 2⁵⁰ × 10⁻⁹ ≈ 1.13 × 10⁶초 ≈ 13일
-- (c) 10⁻¹²초/연산: 2⁵⁰ × 10⁻¹² ≈ 1130초 ≈ 19분
```

컴퓨터가 1000배 빨라져도(10⁻⁹ → 10⁻¹²), 시간은 35.7년 → 19분으로 줄어든다. 하지만 n을 50에서 60으로 10만 늘리면 2⁶⁰/2⁵⁰ = 1024배, 즉 다시 19분 → 약 **13일**이 된다.

> **교훈**: 지수적 복잡도에서는 하드웨어를 아무리 개선해도 문제 크기를 약간만 늘리면 금방 한계에 도달한다.

---

## 6F.9 전술 요약

### 이 장에서 사용한 전술

| 전술 | 용도 | 예 |
|------|------|-----|
| `ring` | 대수적 등식 증명 | `(n+1)² = n² + 2n + 1` |
| `rfl` | 정의에 의한 동치 | `(n+1)! = (n+1) * n!` |
| `omega` | 선형 산술 | `n < 2 * n` |
| `#eval` | 값 계산 | `#eval Nat.factorial 12` |

### 핵심 라이브러리 함수

| 함수 | 의미 | 예 |
|------|------|-----|
| `Nat.log b n` | ⌊logᵦ n⌋ | `Nat.log 2 1024 = 10` |
| `Nat.sqrt n` | ⌊√n⌋ | `Nat.sqrt 100 = 10` |
| `Nat.factorial n` | n! | `Nat.factorial 5 = 120` |
| `List.foldl` | 리스트 왼쪽 접기 | 호너의 방법 구현 |

---

## 다음 편(6-F편 2/2)에서는:

- **행렬 곱의 복잡도**와 행렬 체인 곱
- **알고리즘 패러다임**: 역지, 분할정복, 탐욕
- **복잡도 클래스**: P, NP, NP-완전
- **교재 연습문제 22**: 최선의 경우 분석

를 다룬다.

---

**(끝)**
