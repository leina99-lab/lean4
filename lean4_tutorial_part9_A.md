# 📘 Lean4 이산수학 튜토리얼 Part 9-A: 계수의 기본 원리 — 곱셈 법칙과 덧셈 법칙

> **Rosen 이산수학 8판 6.1절 기반**
> **『Mathematics in Lean』 Chapter 6: Discrete Mathematics 참고**

---

## 9A.0 들어가며: **계수**(Counting)란 무엇인가?

수학에서 **계수**(Counting)란, 어떤 조건을 만족하는 대상의 **개수**를 정확히 세는 것이다. "몇 가지인가?"라는 질문에 답하는 학문이라고 볼 수 있다.

예를 들어보자:
- 비밀번호가 6자리 숫자로 이루어져 있다면, 가능한 비밀번호는 몇 개인가?
- 5명 중 반장과 부반장을 뽑는 방법은 몇 가지인가?
- 52장의 카드에서 3장을 뽑는 방법은 몇 가지인가?

이런 질문에 답하기 위해 우리는 **곱셈 법칙**(Product Rule), **덧셈 법칙**(Sum Rule), **뺄셈 법칙**(Subtraction Rule), **나눗셈 법칙**(Division Rule) 같은 기본 도구들을 사용한다.

### 왜 Lean4로 계수를 배우는가?

Lean4에서는 **유한집합**(Finset)과 **유한형**(Fintype)이라는 도구가 있다. 이를 통해 "원소의 개수"를 수학적으로 엄밀하게 정의하고, 계수에 관한 공식들을 **정리**(theorem)로 증명할 수 있다.

예컨대:

```
-- Finset의 카디널리티(원소 수) 표기
#s    -- s의 원소 수

-- Fintype의 카디널리티 표기
Fintype.card α    -- 타입 α의 원소 수
```

이번 파트에서는 Rosen 교재 6.1절의 **곱셈 법칙**과 **덧셈 법칙**을 배우고, Lean4로 이를 형식화하는 방법을 익힌다.

---

## 9A.1 사전 지식: Lean4의 **정리**(Theorem)와 **작은 정리**(Lemma)

> 💡 **"정리가 뭔지도 모르는 중학생 눈높이"에서 시작한다.**

### 정리란 무엇인가?

수학에서 **정리**(theorem)란, "참이라고 **증명된** 사실"이다. 우리가 일상에서 하는 주장과 다른 점은, 정리는 반드시 **논리적 근거**가 있어야 한다는 것이다.

| 일상의 주장 | 수학의 정리 |
|-----------|---------|
| "비가 올 것 같다" (추측) | "모든 짝수는 2로 나누어진다" (증명된 사실) |
| 근거가 없어도 됨 | 반드시 증명이 필요함 |

Lean4에서 정리는 이렇게 쓴다:

```lean
-- 정리 선언: "이름 : 주장 := 증명"
theorem my_first_theorem : 1 + 1 = 2 := by norm_num
```

여기서:
- `theorem` — "지금부터 정리를 선언하겠다"는 키워드
- `my_first_theorem` — 이 정리의 이름 (자유롭게 지을 수 있다)
- `: 1 + 1 = 2` — 증명하고 싶은 **명제**(주장)
- `:= by norm_num` — 증명 방법 (`norm_num`은 숫자 계산을 자동으로 해주는 전술)

### **작은 정리**(Lemma)와 **큰 정리**(Theorem)의 관계

실제 수학에서는 복잡한 정리를 한 번에 증명하기 어렵다. 그래서 **작은 단계들**로 나누어 먼저 증명하고, 그 결과를 조합해서 큰 정리를 완성한다.

- **작은 정리**(lemma) = "큰 정리를 증명하기 위한 **디딤돌** 역할을 하는 보조 정리"
- **큰 정리**(theorem) = "우리가 최종적으로 증명하고 싶은 **목표** 정리"

비유하자면:

```
🧱 lemma (작은 정리) = 벽돌 하나하나
🏠 theorem (큰 정리) = 벽돌로 지은 완성된 집
```

Lean4에서 `lemma`와 `theorem`은 기술적으로 **완전히 동일**하다. 단지 "이건 보조 역할이야"라고 **표시**하기 위해 `lemma`를 쓸 뿐이다.

```lean
-- 작은 정리 (보조 정리)
lemma add_zero_right (n : Nat) : n + 0 = n := by omega

-- 큰 정리 (위의 lemma를 활용)
theorem sum_example : 5 + 0 = 5 := add_zero_right 5
```

위 예에서 `sum_example`은 `add_zero_right`라는 작은 정리를 **가져다 쓰고** 있다. 이것이 lemma와 theorem의 관계다. 작은 벽돌(lemma)로 큰 집(theorem)을 짓는 것!

### **치환/대입**(Substitution, 슈퍼포지션)이란?

**치환**(substitution)은 "이미 알고 있는 사실을 **끼워 넣는** 것"이다. 예를 들어:

> "a = 3"이라는 것을 알고 있다면, "a + 2"에서 a 자리에 3을 넣어 "3 + 2 = 5"를 얻는다.

Lean4에서 치환은 `rw` (rewrite, 다시 쓰기) 전술로 한다:

```lean
example (a : Nat) (h : a = 3) : a + 2 = 5 := by
  rw [h]       -- h : a = 3 을 이용해, 목표의 a를 3으로 치환
  -- 이제 목표: 3 + 2 = 5
  norm_num     -- 숫자 계산으로 마무리
```

**슈퍼포지션**(superposition)이라는 용어는 논리학에서 유래한 것으로, 본질적으로 "알려진 등식을 적용하여 식을 변환하는 것"이다. Lean4에서는 `rw`, `simp`, `subst` 같은 전술이 이 역할을 한다.

---

## 9A.2 **if**(→)와 **if and only if**(↔)의 차이

이것은 매우 중요한 논리적 구분이다. 중학생도 이해할 수 있게 설명하겠다.

### **if ~ then ~** (→, 함의)

"만약 A이면 B이다"라는 뜻이다. 기호로는 `A → B`로 쓴다.

> 🌧️ "만약 **비가 오면**(A), **땅이 젖는다**(B)."

이것은 **한 방향**이다:
- 비가 오면 → 땅이 젖음 ✅
- 땅이 젖었다고 → 반드시 비가 온 건 아님 ❌ (스프링클러일 수도 있으니까!)

Lean4에서:

```lean
-- A → B: "A가 참이면, B도 참이다"
example (h : n > 5) : n > 3 := by omega
-- n > 5 → n > 3 (한 방향만 성립)
```

### **if and only if** (↔, 동치)

"A이면 B이고, **동시에** B이면 A이다"라는 뜻이다. 기호로는 `A ↔ B`로 쓴다.

> 🔄 "삼각형의 세 변의 길이가 모두 같다 ↔ 세 각의 크기가 모두 같다."

이것은 **양 방향**이다:
- 세 변이 같으면 → 세 각이 같다 ✅
- 세 각이 같으면 → 세 변이 같다 ✅

Lean4에서:

```lean
-- A ↔ B: "A이면 B이고, B이면 A이다"
-- ↔ 는 두 개의 → 를 합친 것!
example : n = 0 ↔ n + 1 = 1 := by omega
```

### 한눈에 비교

| 기호 | 이름 | 뜻 | 방향 |
|------|------|-----|------|
| `→` | **함의**(implication) | "A이면 B" | 한 방향 (→) |
| `↔` | **동치**(equivalence, iff) | "A이면 B이고, B이면 A" | 양 방향 (↔) |

Lean4에서 `↔`를 증명하려면 **두 방향** 모두 증명해야 한다:

```lean
example (n : Nat) : n = 0 ↔ n * 2 = 0 := by
  constructor            -- 두 방향으로 나눈다
  · intro h              -- 방향 1: n = 0 → n * 2 = 0
    rw [h]               -- n을 0으로 치환
  · intro h              -- 방향 2: n * 2 = 0 → n = 0
    omega                -- 자동 산술 증명
```

`constructor` 전술은 `↔`를 **두 개의 →** 로 분해해 준다. 이것이 핵심이다!

---

## 9A.3 Lean4의 **유한집합**(Finset)과 **카디널리티**(Cardinality)

계수 문제를 Lean4로 다루려면 **유한집합**(Finset)을 알아야 한다.

### Finset이란?

**Finset α**는 "타입 α의 원소들로 이루어진 **유한 집합**"이다. 일반적인 집합(Set)은 무한할 수도 있지만, Finset은 항상 유한하다.

```lean
import Mathlib

open Finset

-- 예시: {0, 1, 2, 3, 4} = range 5
#eval (range 5 : Finset Nat)        -- {0, 1, 2, 3, 4}

-- 원소 수 세기
#eval (range 5).card                -- 5
#eval #(range 5)                    -- 5  (같은 표기)
```

### 핵심 Finset 연산들

| Lean4 표현 | 의미 | 예시 |
|-----------|------|------|
| `range n` | {0, 1, ..., n-1} | `range 3 = {0, 1, 2}` |
| `s ∪ t` | **합집합**(union) | `{1,2} ∪ {2,3} = {1,2,3}` |
| `s ∩ t` | **교집합**(intersection) | `{1,2} ∩ {2,3} = {2}` |
| `s ×ˢ t` | **곱집합**(cartesian product) | `{1,2} ×ˢ {a,b}` |
| `#s` | **카디널리티**(cardinality, 원소 수) | `#(range 5) = 5` |

### Fintype이란?

**Fintype α**는 "타입 α 자체가 유한하다"는 것을 나타내는 구조다. 예를 들어:
- `Fin 5` — 원소가 5개인 타입 {0, 1, 2, 3, 4}
- `Bool` — 원소가 2개인 타입 {true, false}

```lean
-- Fin n: 0부터 n-1까지의 자연수 타입
#eval Fintype.card (Fin 5)          -- 5
#eval Fintype.card Bool             -- 2
```

---

## 9A.4 **곱셈 법칙**(Product Rule)

### 직관적 이해

> 📐 **곱셈 법칙**: 하나의 과정이 두 개의 **연속된 작업**으로 나뉠 때,
> 첫 번째 작업을 수행하는 방법이 n₁가지이고,
> 첫 번째 작업을 수행한 후 두 번째 작업을 수행하는 방법이 n₂가지이면,
> 전체 과정을 완료하는 방법은 **n₁ × n₂** 가지이다.

이것을 비유하면:

```
👕 셔츠 3벌 × 👖 바지 4벌 = 총 12가지 조합
```

셔츠를 먼저 고르고(3가지), 그 후 바지를 고르는(4가지) 것이니까, 3 × 4 = 12가지!

### 수학적 정의

두 유한집합 A와 B가 있을 때, **카티션 곱**(Cartesian product) A × B의 원소 수는:

> |A × B| = |A| × |B|

### Lean4에서의 곱셈 법칙

Lean4의 Mathlib에서 곱셈 법칙은 다음과 같이 표현된다:

```lean
import Mathlib
open Finset

-- Finset의 곱셈 법칙
-- s ×ˢ t 는 s와 t의 카티션 곱
example (s t : Finset Nat) : #(s ×ˢ t) = #s * #t := by
  rw [card_product]    -- Mathlib의 정리를 적용

-- 더 간단하게: simp가 자동으로 처리
example (s t : Finset Nat) : #(s ×ˢ t) = #s * #t := by simp
```

**Fintype**(유한형)에서도 곱셈 법칙이 성립한다:

```lean
open Fintype

-- 타입 수준의 곱셈 법칙
-- α × β의 원소 수 = α의 원소 수 × β의 원소 수
example : Fintype.card (Fin 3 × Fin 4) = 3 * 4 := by simp
-- 결과: 12 = 12 ✅
```

---

## 9A.5 **교재 예제 1**: 사무실 배정 (곱셈 법칙)

> **문제**: 산체스와 파텔 두 명의 종업원을 가진 새로운 회사가 12개의 사무실을 가진 건물을 빌렸다. 이 두 명의 종업원에게 서로 다른 사무실을 할당해 줄 수 있는 경우의 수는 몇 가지인가?

### 풀이

- 첫 번째 작업: 산체스에게 사무실을 할당 → **12가지**
- 두 번째 작업: 파텔에게 나머지 사무실 중 하나를 할당 → **11가지**
- 곱셈 법칙에 의해: 12 × 11 = **132가지**

### Lean4 구현

```lean
-- 사무실 배정 문제: 12개 사무실에서 2명에게 서로 다른 사무실 배정
-- 첫 번째 사람: 12가지 선택, 두 번째 사람: 11가지 선택
theorem office_assignment : 12 * 11 = 132 := by norm_num
```

좀 더 형식적으로, **순서쌍**(ordered pair)으로 모델링할 수 있다:

```lean
-- Fin 12에서 서로 다른 두 원소를 순서대로 뽑기
-- 이것은 1대1 함수의 수와 관련 (Rosen 예제 7)
-- n개에서 서로 다른 2개를 순서대로: n * (n - 1)
theorem ordered_pair_count (n : Nat) (h : n ≥ 2) :
    n * (n - 1) ≥ 2 := by omega
```

---

## 9A.6 **교재 예제 2**: 의자 번호 (곱셈 법칙)

> **문제**: 한 개의 영문 대문자와 그 뒤에 100 이하의 양의 정수를 사용하여 강당에 있는 의자들에 번호를 붙이려 한다. 서로 다르게 번호를 붙일 수 있는 의자의 개수는 최대 몇 개인가?

### 풀이

- 첫 번째 작업: 영문 대문자 선택 → **26가지** (A~Z)
- 두 번째 작업: 1~100의 정수 선택 → **100가지**
- 곱셈 법칙: 26 × 100 = **2600가지**

### Lean4 구현

```lean
-- 의자 번호: 영문 대문자(26) × 양의 정수(100)
theorem chair_labels : 26 * 100 = 2600 := by norm_num

-- Fintype으로 표현: 26개 문자 × 100개 정수
example : Fintype.card (Fin 26 × Fin 100) = 2600 := by simp
```

---

## 9A.7 **교재 예제 4**: 비트 문자열 (곱셈 법칙의 확장)

> **문제**: 길이가 7인 서로 다른 비트 문자열은 모두 몇 개인가?

### 풀이

비트 문자열의 각 자리는 0 또는 1, 즉 **2가지** 선택이 있다. 7개의 자리가 **독립적으로** 선택되므로:

> 2 × 2 × 2 × 2 × 2 × 2 × 2 = 2⁷ = **128개**

이것은 곱셈 법칙의 **확장**이다: 작업이 m개일 때, 각 작업 Tᵢ를 수행하는 방법이 nᵢ가지이면, 전체 방법은 n₁ × n₂ × ... × nₘ 가지이다.

### Lean4 구현

```lean
-- 길이 7 비트 문자열의 수: 2^7
-- 각 자리에 Bool(0 또는 1), 7자리 → Bool^7
-- 즉 Fin 7 → Bool 타입의 함수의 수

-- 기본 계산
theorem bit_strings_7 : 2 ^ 7 = 128 := by norm_num

-- Fintype 버전: (Fin 7 → Bool)의 원소 수
-- card (α → β) = (card β) ^ (card α)
example : Fintype.card (Fin 7 → Bool) = 2 ^ 7 := by simp

-- 최종
example : Fintype.card (Fin 7 → Bool) = 128 := by simp
```

> 💡 **핵심 통찰**: "길이 n인 비트 문자열"은 Lean4에서 `Fin n → Bool` 타입, 즉 "n개의 위치 각각에 참/거짓을 배정하는 함수"로 모델링된다. 이 함수의 총 개수가 `2^n`이라는 것이 곱셈 법칙의 확장인 것이다!

---

## 9A.8 **교재 예제 6**: 함수의 개수 (곱셈 법칙)

> **문제**: 원소가 m개인 집합으로부터 원소가 n개인 집합으로의 함수는 모두 몇 가지가 있을 수 있는가?

### 풀이

함수란 정의역에 있는 m개의 원소 **각각에 대해** 공역에 있는 n개의 원소 중 하나를 선택하는 것이다.
- 첫 번째 원소: **n가지** 선택
- 두 번째 원소: **n가지** 선택
- ...
- m번째 원소: **n가지** 선택

곱셈 법칙에 의해: n × n × ... × n (m번) = **n^m** 가지

### Lean4 구현

```lean
-- 함수의 수: |α → β| = |β|^|α|
-- Fin m → Fin n 의 원소 수 = n^m

-- 예시: 3개에서 5개로의 함수 수 = 5³ = 125
example : Fintype.card (Fin 3 → Fin 5) = 5 ^ 3 := by simp
example : Fintype.card (Fin 3 → Fin 5) = 125 := by simp

-- 일반 공식
example (n m : Nat) : Fintype.card (Fin m → Fin n) = n ^ m := by simp
```

> 📌 이 결과는 **매우 중요**하다! "함수의 수 = n^m"이라는 공식은 계수론의 기본 도구다.

---

## 9A.9 연습 세트 1: 곱셈 법칙

### 연습 1-1: 자동차 번호판 (교재 예제 5)

> **문제**: 자동차 번호판이 3개의 영문 대문자와 3개의 숫자로 구성되어 있다면 서로 다른 번호판은 모두 몇 개인가? 단, 3개의 영문 대문자가 먼저 앞에 위치하고 그 뒤 3개의 숫자가 나타나며 금지된 단어는 없다고 가정하자.

**[괄호 채우기]**

```lean
-- 번호판: 대문자 3개 × 숫자 3개
-- 대문자: 각 26가지, 숫자: 각 10가지
-- 곱셈 법칙: 26 × 26 × 26 × 10 × 10 × 10

theorem license_plate :
    26 * 26 * 26 * 10 * 10 * 10 = (______) := by norm_num
```

<details>
<summary>📝 답 보기</summary>

```lean
theorem license_plate :
    26 * 26 * 26 * 10 * 10 * 10 = 17576000 := by norm_num
```

풀이: 26³ = 17,576 그리고 10³ = 1,000이므로, 17,576 × 1,000 = **17,576,000** 가지이다.
</details>

### 연습 1-2: 유한집합의 부분집합 개수 (교재 예제 10)

> **문제**: 유한집합 S의 서로 다른 부분집합의 개수는 2^|S| 임을 곱셈 법칙을 이용하여 증명하여라.

**[괄호 채우기]**

```lean
-- S의 부분집합 ↔ S의 각 원소에 대해 "포함/불포함" 선택
-- 즉 S → Bool 의 함수와 1대1 대응
-- 따라서 부분집합의 수 = 2^|S|

-- Fin n의 부분집합 수 = 2^n
-- 이것은 Fin n → Bool 의 함수 수와 같다
example (n : Nat) :
    Fintype.card (Fin n → Bool) = (______) := by simp
```

<details>
<summary>📝 답 보기</summary>

```lean
example (n : Nat) :
    Fintype.card (Fin n → Bool) = 2 ^ n := by simp
```

풀이: 각 원소에 대해 "포함(true)" 또는 "불포함(false)"을 선택하므로, 2 × 2 × ... × 2 (n번) = **2^n** 이다. 이것이 **부분집합의 수**가 2^n인 이유다!
</details>

### 연습 1-3: 곱집합의 크기 (sorry 문제)

```lean
-- 두 유한형의 곱의 크기가 각 크기의 곱임을 증명하라
example : Fintype.card (Fin 7 × Fin 8) = 56 := by
  sorry
```

<details>
<summary>📝 답 보기</summary>

```lean
example : Fintype.card (Fin 7 × Fin 8) = 56 := by simp
```
</details>

### 연습 1-4: 함수의 수 (sorry 문제)

```lean
-- 4개의 원소에서 3개의 원소로의 함수 수 = 3^4 = 81
example : Fintype.card (Fin 4 → Fin 3) = 81 := by
  sorry
```

<details>
<summary>📝 답 보기</summary>

```lean
example : Fintype.card (Fin 4 → Fin 3) = 81 := by simp
```
</details>

---

## 9A.10 **덧셈 법칙**(Sum Rule)

### 직관적 이해

> 📐 **덧셈 법칙**: 어떤 작업을 n₁가지 중의 **한 방법**이나 n₂가지의 **한 방법**으로 수행할 수 있다.
> 여기서 n₁ 방법 중의 어느 것도 n₂ 방법이랑 같지 않다.
> 그러면 그 작업을 수행하는 방법은 **n₁ + n₂** 가지가 있다.

핵심은 "**또는**(or)"이다!

```
🍎 사과 3종류 또는 🍊 오렌지 4종류 = 과일 선택: 3 + 4 = 7가지
```

곱셈 법칙이 "**그리고**(and, 연속 작업)"에 해당한다면, 덧셈 법칙은 "**또는**(or, 대안 선택)"에 해당한다.

### 수학적 정의

두 **서로소 집합**(disjoint sets) A와 B에 대해:

> |A ∪ B| = |A| + |B|  (단, A ∩ B = ∅)

서로소란 "두 집합에 공통 원소가 없다"는 뜻이다.

### 곱셈 법칙 vs 덧셈 법칙 비교

| | **곱셈 법칙**(Product Rule) | **덧셈 법칙**(Sum Rule) |
|---|---|---|
| 상황 | 두 작업을 **연속으로** 수행 | 두 방법 중 **하나를** 선택 |
| 키워드 | "**그리고**"(and) | "**또는**"(or) |
| 연산 | × (곱) | + (합) |
| 집합 | 카티션 곱 A × B | 서로소 합집합 A ∪ B |

### Lean4에서의 덧셈 법칙

```lean
import Mathlib
open Finset

-- Finset의 덧셈 법칙: 서로소(Disjoint) 집합의 합집합
-- Disjoint s t일 때: |s ∪ t| = |s| + |t|
example (s t : Finset Nat) (h : Disjoint s t) :
    #(s ∪ t) = #s + #t := by
  rw [card_union_of_disjoint h]

-- simp도 가능
example (s t : Finset Nat) (h : Disjoint s t) :
    #(s ∪ t) = #s + #t := by simp [h]
```

**Fintype** 수준에서는 **합 타입**(Sum type, `⊕`)으로 표현한다:

```lean
open Fintype

-- 타입 수준의 덧셈 법칙
-- α ⊕ β의 원소 수 = α의 원소 수 + β의 원소 수
example : Fintype.card (Fin 3 ⊕ Fin 4) = 3 + 4 := by simp
-- 결과: 7 = 7 ✅
```

> 💡 **핵심**: 곱셈 법칙은 `×`(곱 타입), 덧셈 법칙은 `⊕`(합 타입)!

---

## 9A.11 **교재 예제 12**: 위원회 대표 선발 (덧셈 법칙)

> **문제**: 대학교에서 어떤 위원회의 대표자로 수학과 교수나 수학 전공 학생 한 명을 선발한다고 하자. 수학과 교수의 수가 37명이고 수학 전공 학생의 수가 83명일 때, 대표자를 선발하는 서로 다른 방법의 수는 모두 몇 개인가?

### 풀이

- 수학과 교수 중에서 선택: **37가지**
- 수학 전공 학생 중에서 선택: **83가지**
- 교수와 학생은 서로 다른 그룹(서로소)이므로, 덧셈 법칙에 의해: 37 + 83 = **120가지**

### Lean4 구현

```lean
-- 위원회 대표: 교수 37명 또는 학생 83명 중 1명
theorem committee_rep : 37 + 83 = 120 := by norm_num

-- Fintype 버전
example : Fintype.card (Fin 37 ⊕ Fin 83) = 120 := by simp
```

---

## 9A.12 **교재 예제 13**: 과제 선택 (덧셈 법칙의 확장)

> **문제**: 한 학생이 컴퓨터 과제를 수행하는데, 세 개의 리스트 중에서 하나를 선택할 수 있다. 세 개의 리스트는 각각 23, 15, 19가지의 과제를 포함하고 모든 프로젝트는 1개의 리스트에만 나열되어 있을 때, 과제를 선택하는 방법은 모두 몇 가지나 가능한가?

### 풀이

세 리스트는 서로소(각 과제는 1개 리스트에만 있음)이므로, 확장된 덧셈 법칙에 의해:

> 23 + 15 + 19 = **57가지**

### Lean4 구현

```lean
-- 과제 선택: 3개 리스트에서 각각 23, 15, 19가지
theorem assignment_choice : 23 + 15 + 19 = 57 := by norm_num
```

---

## 9A.13 곱셈 법칙과 덧셈 법칙의 **집합론적 관점**

이 두 법칙을 집합의 언어로 정리하면 매우 깔끔하다.

### 곱셈 법칙 (집합 관점)

A₁, A₂, ..., Aₘ이 유한집합일 때:

> |A₁ × A₂ × ... × Aₘ| = |A₁| · |A₂| · ... · |Aₘ|

Lean4에서:

```lean
-- 여러 유한형의 곱의 크기 = 각 크기의 곱
-- Π 타입으로 일반화
example (n : Nat) :
    Fintype.card (Fin n → Fin 2) = 2 ^ n := by simp
```

### 덧셈 법칙 (집합 관점)

A₁, A₂, ..., Aₘ이 **서로소 집합**(pairwise disjoint)일 때:

> |A₁ ∪ A₂ ∪ ... ∪ Aₘ| = |A₁| + |A₂| + ... + |Aₘ|

Lean4에서:

```lean
-- Σ 타입(의존 합)으로 일반화
-- (i : Fin n) → γ i 의 원소 수 = Σ i, card (γ i)

-- 예시: Fin 3 ⊕ Fin 4 ⊕ Fin 5
-- 이것은 Σ i : Fin 3, Fin [3,4,5][i] 와 유사
```

---

## 9A.14 연습 세트 2: 덧셈 법칙

### 연습 2-1: 교재 연습문제 1(a) — 대표자 선발

> **문제**: 어떤 대학에 수학 전공 학생 18명과 컴퓨터 전공 학생 325명이 있다. 수학 전공 학생 한 명과 컴퓨터 전공 학생 한 명을 대표자로 선발하는 방법의 수는 모두 몇인가?

**[괄호 채우기]**

```lean
-- 수학 1명 AND 컴퓨터 1명 → 곱셈 법칙!
-- (주의: "한 명과 한 명" = 두 명을 모두 뽑는 것)
theorem representatives_a :
    18 * 325 = (______) := by norm_num
```

<details>
<summary>📝 답 보기</summary>

```lean
theorem representatives_a :
    18 * 325 = 5850 := by norm_num
```

풀이: 이 문제는 "수학 전공 한 명 **그리고** 컴퓨터 전공 한 명"을 선발하므로, **곱셈 법칙**이다!
</details>

### 연습 2-2: 교재 연습문제 1(b) — 대표자 선발 (OR)

> **문제**: 수학 전공 학생 **또는** 컴퓨터 전공 학생 중에서 한 명을 대표자로 선발하는 방법의 수는 모두 몇인가?

**[괄호 채우기]**

```lean
-- 수학 1명 OR 컴퓨터 1명 → 덧셈 법칙!
theorem representatives_b :
    18 + 325 = (______) := by norm_num
```

<details>
<summary>📝 답 보기</summary>

```lean
theorem representatives_b :
    18 + 325 = 343 := by norm_num
```

풀이: 이 문제는 "수학 전공 한 명 **또는** 컴퓨터 전공 한 명"을 선발하므로, **덧셈 법칙**이다!
</details>

### 연습 2-3: 교재 연습문제 2 — 사무실 수

> **문제**: 사무실 빌딩이 27층으로 되어 있는데, 각 층에는 37개의 사무실이 있다. 이 빌딩에는 몇 개의 사무실이 있는가?

**[sorry 문제]**

```lean
-- 각 층 37개 × 27개 층
theorem offices : 27 * 37 = 999 := by
  sorry
```

<details>
<summary>📝 답 보기</summary>

```lean
theorem offices : 27 * 37 = 999 := by norm_num
```
</details>

### 연습 2-4: 교재 연습문제 3(a) — 4지선다 시험

> **문제**: 4지선다형 문제 10개로 구성된 시험이 있다. 모든 문제에 대해서 답할 경우 학생이 답안을 작성하는 방법의 수는?

**[sorry 문제]**

```lean
-- 각 문제: 4가지 선택, 10문제 → 4^10
theorem multiple_choice_a : 4 ^ 10 = 1048576 := by
  sorry
```

<details>
<summary>📝 답 보기</summary>

```lean
theorem multiple_choice_a : 4 ^ 10 = 1048576 := by norm_num
```

풀이: 각 문제마다 4가지 선택지가 있고, 10개 문제가 독립이므로 곱셈 법칙에 의해 4¹⁰ = **1,048,576** 가지.
</details>

### 연습 2-5: 교재 연습문제 3(b) — 공란 허용 시험

> **문제**: 답안을 공란으로 두어도 괜찮을 경우 학생이 답안을 작성하는 방법의 수는?

**[sorry 문제]**

```lean
-- 각 문제: 4가지 선택 + 공란 = 5가지, 10문제 → 5^10
theorem multiple_choice_b : 5 ^ 10 = 9765625 := by
  sorry
```

<details>
<summary>📝 답 보기</summary>

```lean
theorem multiple_choice_b : 5 ^ 10 = 9765625 := by norm_num
```

풀이: 공란이 허용되면 각 문제에 5가지 선택(4개 답 + 공란)이 있으므로, 5¹⁰ = **9,765,625** 가지.
</details>

---

## 9A.15 **교재 예제 9**: 중첩 루프와 곱셈 법칙

다음 코드가 실행된 후 k의 값은 얼마인가? 단, n₁, n₂, ..., nₘ은 모두 양의 정수이다.

```
k := 0
for i₁ := 1 to n₁
  for i₂ := 1 to n₂
    ...
    for iₘ := 1 to nₘ
      k := k + 1
```

### 풀이

k의 초깃값은 0이다. 루프를 수행할 때마다 k값은 1씩 증가된다. i번째 루프를 수행하는 작업을 Tᵢ라 하자. 루프가 수행되는 횟수는 작업 T₁, T₂, ..., Tₘ을 수행하는 방법의 개수이다. 곱셈 법칙에 의해 중첩된 루프는 **n₁ × n₂ × ... × nₘ** 번 수행되며, 따라서 k의 최종값은 **n₁n₂...nₘ** 이다.

### Lean4 구현

```lean
-- 중첩 루프의 반복 횟수 = 곱
-- 간단한 예시: 3중 루프 (n₁=2, n₂=3, n₃=4)
-- 총 반복: 2 * 3 * 4 = 24

def nestedLoopCount (n1 n2 n3 : Nat) : Nat :=
  let mut k := 0
  for _ in List.range n1 do
    for _ in List.range n2 do
      for _ in List.range n3 do
        k := k + 1
  k

-- 실행 확인
#eval nestedLoopCount 2 3 4   -- 24

-- 정리: 중첩 루프 횟수 = 곱
theorem nested_loop_product : nestedLoopCount 2 3 4 = 2 * 3 * 4 := by native_decide
```

---

## 9A.16 **교재 예제 14**: 병렬 루프와 덧셈 법칙

다음 코드를 수행한 후 k의 값은 무엇인가?

```
k := 0
for i₁ := 1 to n₁
  k := k + 1
for i₂ := 1 to n₂
  k := k + 1
...
for iₘ := 1 to nₘ
  k := k + 1
```

### 풀이

코드는 m개의 **서로 다른** 루프로 구성되어 있는데, 루프를 방문할 때마다 k값은 1씩 증가된다. 두 가지 작업이 동시에 수행될 수는 없으므로, 덧셈 법칙에 의해 k의 최종값은 **n₁ + n₂ + ... + nₘ** 이다.

### Lean4 구현

```lean
-- 병렬 루프의 반복 횟수 = 합
def parallelLoopCount (n1 n2 n3 : Nat) : Nat :=
  let mut k := 0
  for _ in List.range n1 do
    k := k + 1
  for _ in List.range n2 do
    k := k + 1
  for _ in List.range n3 do
    k := k + 1
  k

#eval parallelLoopCount 23 15 19   -- 57

theorem parallel_loop_sum :
    parallelLoopCount 23 15 19 = 23 + 15 + 19 := by native_decide
```

---

## 9A.17 연습 세트 3: 곱셈 vs 덧셈 법칙 판별

다음 각 문제에서 곱셈 법칙과 덧셈 법칙 중 어느 것을 사용해야 하는지 판별하고, 답을 구하여라.

### 연습 3-1: 교재 연습문제 4

> **문제**: 어떤 상표의 셔츠가 12가지 색깔로 나오는데 남성용과 여성용이 있고 각 성별로 3가지 사이즈가 있다. 모두 몇 가지의 서로 다른 셔츠가 만들어지는가?

**[괄호 채우기]**

```lean
-- 색깔(12) × 성별(2) × 사이즈(3) → (____) 법칙
theorem shirts : 12 * 2 * 3 = (______) := by norm_num
```

<details>
<summary>📝 답 보기</summary>

```lean
-- 색깔 AND 성별 AND 사이즈 → 곱셈 법칙!
theorem shirts : 12 * 2 * 3 = 72 := by norm_num
```
</details>

### 연습 3-2: 교재 연습문제 5

> **문제**: 뉴욕에서 덴버로 가는 항공사가 6개 있고, 덴버에서 샌프란시스코로 가는 항공사가 7개 있다. 뉴욕에서 덴버를 경유하여 샌프란시스코로 가는 항공편을 구성하는 방법은 모두 몇 가지인가?

**[sorry 문제]**

```lean
-- 뉴욕→덴버(6) AND 덴버→샌프란(7) → 어떤 법칙?
theorem flights : 6 * 7 = 42 := by
  sorry
```

<details>
<summary>📝 답 보기</summary>

```lean
-- 경유: 두 구간을 연속 수행 → 곱셈 법칙
theorem flights : 6 * 7 = 42 := by norm_num
```
</details>

### 연습 3-3: 교재 연습문제 6

> **문제**: 보스턴에서 디트로이트로 가는 자동차 길이 4개 있고, 디트로이트에서 로스앤젤레스로 가는 자동차 길이 7개 있다. 보스턴에서 디트로이트를 거쳐 로스앤젤레스로 가는 자동차 길은 모두 몇 개인가?

**[sorry 문제]**

```lean
theorem car_routes : 4 * 7 = 28 := by
  sorry
```

<details>
<summary>📝 답 보기</summary>

```lean
theorem car_routes : 4 * 7 = 28 := by norm_num
```
</details>

### 연습 3-4: 교재 연습문제 10

> **문제**: 길이 8의 비트 문자열은 모두 몇 가지인가?

**[sorry 문제]**

```lean
theorem bit_strings_8 : 2 ^ 8 = (______) := by
  sorry
```

<details>
<summary>📝 답 보기</summary>

```lean
theorem bit_strings_8 : 2 ^ 8 = 256 := by norm_num
```
</details>

---

## 9A.18 전술 및 함수 종합 요약

이번 파트에서 사용한 핵심 도구들을 정리한다.

### Lean4 전술(Tactic)

| 전술 | 역할 | 예시 |
|------|------|------|
| `norm_num` | 숫자 계산을 자동 처리 | `2^7 = 128` |
| `simp` | 단순화 규칙 적용 | `Fintype.card (Fin 5) = 5` |
| `rw [h]` | 등식 h를 이용한 치환 | `rw [card_product]` |
| `constructor` | ↔를 두 방향으로 분해 | `A ↔ B`를 `A → B`와 `B → A`로 |
| `omega` | 선형 산술 자동 증명 | 자연수/정수 부등식 |
| `native_decide` | 계산으로 결정 가능한 명제 검증 | 유한한 경우의 확인 |

### Lean4 타입과 함수

| 표현 | 의미 |
|------|------|
| `Fin n` | {0, 1, ..., n-1} 타입 |
| `Fin m × Fin n` | m개 × n개의 곱 타입 (곱셈 법칙) |
| `Fin m ⊕ Fin n` | m개 + n개의 합 타입 (덧셈 법칙) |
| `Fin m → Fin n` | m개에서 n개로의 함수 타입 (n^m개) |
| `Fintype.card α` | 유한형 α의 원소 수 |
| `Finset.card s` 또는 `#s` | 유한집합 s의 원소 수 |
| `s ×ˢ t` | Finset의 카티션 곱 |
| `card_product` | `#(s ×ˢ t) = #s * #t` |
| `card_union_of_disjoint` | `Disjoint s t → #(s ∪ t) = #s + #t` |

### 핵심 공식 요약

| 공식 | 설명 | Lean4 표현 |
|------|------|----------|
| n₁ × n₂ | 곱셈 법칙 | `card (α × β) = card α * card β` |
| n₁ + n₂ | 덧셈 법칙 | `card (α ⊕ β) = card α + card β` |
| nᵐ | 함수의 수 | `card (Fin m → Fin n) = n ^ m` |
| 2ⁿ | 부분집합의 수 | `card (Fin n → Bool) = 2 ^ n` |

---

## 9A.19 핵심 요약

1. **정리**(theorem)는 "증명된 사실"이고, **작은 정리**(lemma)는 "큰 정리를 위한 디딤돌"이다. Lean4에서 둘은 기술적으로 동일하다.

2. **치환**(substitution)은 알려진 등식을 끼워 넣는 것으로, Lean4에서 `rw` 전술로 수행한다.

3. **→**(함의)는 "A이면 B" (한 방향), **↔**(동치)는 "A이면 B이고, B이면 A" (양 방향)이다.

4. **곱셈 법칙**: 연속 작업 → n₁ × n₂, Lean4에서 `α × β` 또는 `s ×ˢ t`

5. **덧셈 법칙**: 대안 선택 → n₁ + n₂, Lean4에서 `α ⊕ β` 또는 서로소 `s ∪ t`

6. **함수의 수**: |α → β| = |β|^|α|, Lean4에서 `card (Fin m → Fin n) = n ^ m`

---

## 다음 편 예고

**Part 9-B**에서는 Rosen 6.1절의 나머지 내용을 다룬다:
- **뺄셈 법칙**(Subtraction Rule, 포함-배제 원리)
- **나눗셈 법칙**(Division Rule)
- **트리 도표**(Tree Diagrams)
- 더 복잡한 계수 문제 (교재 예제 15~24)
