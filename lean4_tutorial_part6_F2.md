# Lean4 완전 정복 가이드 — 제6-F편 (2/2)

## **알고리즘 복잡도 심화**(Advanced Algorithm Complexity) — 행렬 곱, 알고리즘 패러다임, P vs NP

> **교재**: Kenneth H. Rosen, "Discrete Mathematics and Its Applications" 8판  
> **범위**: 3.3.3~3.3.5절, 연습문제 22~49 (선별)  
> **선수 학습**: 제6-F편 (1/2)  
> **참고**: 『Mathematics in Lean』 Chapter 6 (Counting)

---

## 6F.10 행렬 곱의 복잡도

### 6F.10.1 행렬이란?

**행렬**(matrix)은 수를 직사각형 모양으로 배열한 것이다. 예를 들어 2 × 3 행렬은 2행 3열의 수 배열이다.

$$A = \begin{pmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \end{pmatrix}$$

이것은 "2행 3열"이므로 **2 × 3 행렬**이라 한다.

### 6F.10.2 행렬 곱의 정의

m × k 행렬 **A**와 k × n 행렬 **B**를 곱하면 m × n 행렬 **C** = **AB**를 얻는다.

**C**의 (i, j) 원소는:

$$c_{ij} = \sum_{q=1}^{k} a_{iq} \cdot b_{qj}$$

> **중요**: **A**의 열(column) 수와 **B**의 행(row) 수가 같아야(**k**) 곱할 수 있다.

쉽게 말하면, **A**의 i번째 **행**(가로줄)과 **B**의 j번째 **열**(세로줄)의 원소들을 하나씩 곱해서 모두 더한 것이다.

### 6F.10.3 행렬 곱 알고리즘

```
procedure matrix_multiplication(A, B)
for i := 1 to m
    for j := 1 to n
        c_ij := 0
        for q := 1 to k
            c_ij := c_ij + a_iq * b_qj
return C
```

이 알고리즘의 구조를 분석하자:
- 바깥 루프 `i`: m번
- 중간 루프 `j`: n번
- 안쪽 루프 `q`: k번
- 각 반복에서: 곱셈 1번 + 덧셈 1번

### 교재 예제 7: 두 n × n 행렬의 곱셈 횟수

m = k = n인 경우(정사각 행렬):
- **곱셈 횟수**: n × n × n = **n³**번
- **덧셈 횟수**: n × n × (n - 1) = **n²(n - 1)**번

```lean
-- Big-O 정의 (6-C편에서 가져옴)
def IsBigO (f g : Nat → Nat) : Prop :=
  ∃ C : Nat, ∃ k : Nat, ∀ n : Nat, n > k → f n ≤ C * g n

-- 두 n × n 행렬의 곱: 곱셈 n³번
def matrix_mul_ops (n : Nat) : Nat := n ^ 3

-- n³은 O(n³) (자명)
theorem matrix_O_n3 :
    IsBigO matrix_mul_ops (fun n => n ^ 3) := by
  use 1, 0
  intro n _hn
  unfold matrix_mul_ops
  omega
```

### 6F.10.4 행렬 체인 곱 — 순서가 중요하다!

세 개의 행렬을 곱할 때, **곱하는 순서**에 따라 연산 횟수가 크게 달라질 수 있다. 이것을 **행렬 체인 곱**(matrix-chain multiplication) 문제라 한다.

p × q 행렬과 q × r 행렬을 곱하면 **곱셈이 p·q·r번** 필요하다. (p × r 행렬의 각 원소를 구하는 데 q번의 곱셈이 필요하고, 그런 원소가 p·r개이다.)

### 교재 예제 9: 세 행렬의 곱

A₁은 30 × 20, A₂는 20 × 40, A₃은 40 × 10 행렬이다.

**방법 1**: A₁(A₂A₃) — 안쪽부터 먼저 곱한다
- A₂A₃: 20 × 40 행렬 × 40 × 10 행렬 → 곱셈 20 · 40 · 10 = **8,000**번
- A₁(A₂A₃): 30 × 20 행렬 × 20 × 10 행렬 → 곱셈 30 · 20 · 10 = **6,000**번
- 총: **14,000**번

**방법 2**: (A₁A₂)A₃ — 바깥부터 먼저 곱한다
- A₁A₂: 30 × 20 행렬 × 20 × 40 행렬 → 곱셈 30 · 20 · 40 = **24,000**번
- (A₁A₂)A₃: 30 × 40 행렬 × 40 × 10 행렬 → 곱셈 30 · 40 · 10 = **12,000**번
- 총: **36,000**번

```lean
-- 방법 1: A₁(A₂A₃)
def method1_ops : Nat := 20 * 40 * 10 + 30 * 20 * 10

-- 방법 2: (A₁A₂)A₃
def method2_ops : Nat := 30 * 20 * 40 + 30 * 40 * 10

#eval method1_ops   -- 14000
#eval method2_ops   -- 36000

-- 방법 1이 훨씬 효율적!
#eval method2_ops - method1_ops  -- 22000 (2.57배 차이)
```

**결론**: 같은 결과를 주는 계산이라도 순서에 따라 효율이 2.5배 이상 차이 날 수 있다!

### 연습 6F.9: 행렬 체인 곱 계산 (괄호 채우기)

**문제**: A(3×9), B(9×4), C(4×2) 세 행렬의 곱 ABC를 만드는 두 가지 방법의 곱셈 횟수를 계산하시오.

```lean
-- 방법 1: A(BC)
-- BC: 9 × 4 행렬 × 4 × 2 행렬 → 곱셈 ▢번
-- A(BC): 3 × 9 행렬 × 9 × 2 행렬 → 곱셈 ▢번
-- 총: ▢번

-- 방법 2: (AB)C
-- AB: 3 × 9 행렬 × 9 × 4 행렬 → 곱셈 ▢번
-- (AB)C: 3 × 4 행렬 × 4 × 2 행렬 → 곱셈 ▢번
-- 총: ▢번
```

<details>
<summary>💡 답 보기</summary>

```lean
-- 방법 1: A(BC)
-- BC: 9 * 4 * 2 = 72번
-- A(BC): 3 * 9 * 2 = 54번
-- 총: 126번

-- 방법 2: (AB)C
-- AB: 3 * 9 * 4 = 108번
-- (AB)C: 3 * 4 * 2 = 24번
-- 총: 132번

#eval 9 * 4 * 2 + 3 * 9 * 2    -- 126 (방법 1)
#eval 3 * 9 * 4 + 3 * 4 * 2    -- 132 (방법 2)
```

방법 1이 약간 더 효율적이다 (126 < 132).

</details>

### 연습 6F.10: 행렬 체인 곱 — 4개 행렬 (교재 연습문제 49)

**문제**: A(30×10), B(10×40), C(40×50), D(50×30) 네 행렬의 곱 ABCD를 만드는 최선의 순서는?

가능한 괄호 배치(5가지):
1. A(B(CD))
2. A((BC)D)
3. (AB)(CD)
4. ((AB)C)D
5. (A(BC))D

```lean
-- 각 방법의 곱셈 횟수를 계산하라
-- 예: (AB)(CD)
-- AB: 30 * 10 * 40 = 12000
-- CD: 40 * 50 * 30 = 60000
-- (AB)(CD): 30 * 40 * 30 = 36000
-- 총: 12000 + 60000 + 36000 = 108000

#eval 30 * 10 * 40 + 40 * 50 * 30 + 30 * 40 * 30  -- 108000
```

<details>
<summary>💡 답 보기</summary>

```lean
-- 1. A(B(CD)): CD→B(CD)→A(B(CD))
#eval 40*50*30 + 10*40*30 + 30*10*30   -- 60000+12000+9000 = 81000

-- 2. A((BC)D): BC→(BC)D→A((BC)D)
#eval 10*40*50 + 10*50*30 + 30*10*30   -- 20000+15000+9000 = 44000

-- 3. (AB)(CD): AB→CD→(AB)(CD)
#eval 30*10*40 + 40*50*30 + 30*40*30   -- 12000+60000+36000 = 108000

-- 4. ((AB)C)D: AB→(AB)C→((AB)C)D
#eval 30*10*40 + 30*40*50 + 30*50*30   -- 12000+60000+45000 = 117000

-- 5. (A(BC))D: BC→A(BC)→(A(BC))D
#eval 10*40*50 + 30*10*50 + 30*50*30   -- 20000+15000+45000 = 80000
```

최선: **방법 2** — A((BC)D) = **44,000**번  
최악: **방법 4** — ((AB)C)D = **117,000**번

차이: 약 2.66배! 순서 선택이 매우 중요하다.

</details>

---

## 6F.11 알고리즘 패러다임

**알고리즘 패러다임**(algorithm paradigm)이란, 다양한 문제를 풀 수 있는 알고리즘을 구하는 데 사용할 수 있는 일반적인 접근법이다.

### 6F.11.1 역지 알고리즘 (Brute-Force Algorithm)

**역지 알고리즘**(brute-force algorithm)은 문제의 설명과 용어의 정의를 바탕으로 **가장 직접적인 방법**으로 문제를 푸는 것이다. 특별한 구조나 기발한 생각을 이용하지 않고, 단순히 모든 가능한 해를 조사한다.

| 문제 | 역지 방법 | 복잡도 |
|------|---------|-------|
| 최댓값 찾기 | 모든 원소 비교 | O(n) |
| 가장 가까운 점 쌍 | 모든 쌍의 거리 계산 | O(n²) |
| 진리표 만족성 검사 | 모든 할당 시도 | O(2ⁿ) |
| 외판원 문제 | 모든 순서 시도 | O(n!) |

```lean
-- 가장 가까운 점 쌍 찾기 (역지 알고리즘)
-- n개의 점에서 모든 쌍의 수: n(n-1)/2

def closest_pair_ops (n : Nat) : Nat := n * (n - 1) / 2

-- O(n²)임을 증명
theorem closest_pair_O_n2 :
    IsBigO closest_pair_ops (fun n => n ^ 2) := by
  use 1, 0
  intro n _hn
  unfold closest_pair_ops
  have h1 : n * (n - 1) / 2 ≤ n * (n - 1) := Nat.div_le_self _ 2
  have h2 : n * (n - 1) ≤ n * n := by
    apply Nat.mul_le_mul_left
    omega
  calc n * (n - 1) / 2
      ≤ n * (n - 1) := h1
    _ ≤ n * n := h2
    _ = n ^ 2 := by ring
```

> **역지 알고리즘의 장단점**  
> - **장점**: 구현이 간단하고, 반드시 정답을 찾는다  
> - **단점**: 보통 비효율적이다 (특히 입력이 클 때)  
> - **용도**: 입력이 작을 때, 또는 더 좋은 알고리즘을 설계하기 전 기준선(baseline)으로

### 교재 예제 10: 가장 가까운 점 쌍 — 역지 알고리즘

```
procedure closest_pair((x₁,y₁), (x₂,y₂), ..., (xₙ,yₙ))
min := ∞
for i := 2 to n
    for j := 1 to i - 1
        if (xⱼ - xᵢ)² + (yⱼ - yᵢ)² < min then
            min := (xⱼ - xᵢ)² + (yⱼ - yᵢ)²
            closest_pair := ((xᵢ, yᵢ), (xⱼ, yⱼ))
return closest_pair
```

루프를 통해 점검할 쌍의 수: **n(n-1)/2**개. 각 쌍마다 거리의 제곱을 계산(산술 연산 O(1))하고 비교(O(1))하므로, 총 연산의 개수는 **Θ(n²)**이다.

> 참고로, 8장에서 **분할정복** 방법을 사용하면 O(n log n)에 가장 가까운 점 쌍을 찾을 수 있다. 역지 알고리즘보다 훨씬 효율적이다!

### 6F.11.2 분할정복 (Divide and Conquer)

**분할정복**(divide and conquer)은 문제를 더 작은 부분 문제로 **나누고**(divide), 각 부분을 **해결한**(conquer) 뒤, 결과를 **합치는**(combine) 방법이다.

| 문제 | 나누기 | 해결 | 합치기 | 복잡도 |
|------|-------|------|-------|-------|
| 병합 정렬 | 리스트 반으로 | 각각 정렬 | 합병 | O(n log n) |
| 이진 탐색 | 범위 반으로 | 한쪽만 탐색 | - | O(log n) |
| 가까운 점 쌍 | 점 반으로 | 각각 풀기 | 경계 확인 | O(n log n) |

```lean
-- 병합 정렬: O(n log n)
def merge_sort_ops (n : Nat) : Nat := n * (Nat.log 2 n + 1)

-- 이진 탐색: O(log n)
def binary_search_ops (n : Nat) : Nat := Nat.log 2 n + 1

-- 병합 정렬이 버블 정렬보다 빠름: n ≥ 2일 때
-- n log n < n² (n이 충분히 클 때)

-- 구체적 비교
#eval merge_sort_ops 1000     -- 1000 * 10 = 10000
#eval 1000 ^ 2                 -- 1000000
-- 100배 차이!

#eval merge_sort_ops 1000000   -- 1000000 * 20 = 20000000
#eval 1000000 ^ 2              -- 1000000000000
-- 5만 배 차이!
```

### 6F.11.3 탐욕 알고리즘 (Greedy Algorithm)

**탐욕 알고리즘**(greedy algorithm)은 각 단계에서 **그 순간에 가장 좋은 선택**을 한다.

| 문제 | 탐욕 전략 | 최적? |
|------|---------|------|
| 거스름돈 (25, 10, 5, 1센트) | 가장 큰 동전부터 | ✓ |
| 강연 스케줄링 | 가장 빨리 끝나는 것 | ✓ |
| 외판원 문제 | 가장 가까운 도시 | ✗ |

탐욕 알고리즘이 항상 **최적 해**(optimal solution)를 보장하지는 않는다. 그러나 최적 해를 보장하는 문제에서는 매우 효율적이다.

### 연습 6F.11: 알고리즘 패러다임 매칭 (괄호 채우기)

**문제**: 각 알고리즘이 어떤 패러다임에 해당하는지 고르시오.

```
(a) 수열의 최댓값 찾기            → ▢ (역지 / 분할정복 / 탐욕)
(b) 병합 정렬                     → ▢
(c) 거스름돈 만들기 (큰 동전 우선) → ▢
(d) 모든 순열 나열               → ▢
(e) 이진 탐색                     → ▢
```

<details>
<summary>💡 답 보기</summary>

```
(a) 최댓값 찾기 → 역지 (모든 원소를 하나씩 비교)
(b) 병합 정렬 → 분할정복 (반으로 나누고 합병)
(c) 거스름돈 → 탐욕 (매 단계에서 최대 동전 선택)
(d) 모든 순열 나열 → 역지 (모든 가능성 조사)
(e) 이진 탐색 → 분할정복 (범위를 반으로 줄임)
```

</details>

---

## 6F.12 복잡도 클래스: P, NP, NP-완전

### 6F.12.1 풀기 쉬운 문제

**풀기 쉬운**(tractable) 문제란, 최악의 경우에도 **다항식 시간**(polynomial time)에 풀 수 있는 문제이다. 즉, O(nᵏ) 시간 알고리즘이 존재하는 문제이다 (k는 상수).

이런 문제들의 모임을 **클래스 P**(class P)라 한다.

```lean
-- "다항식 시간" = ∃ k, 알고리즘이 O(n^k)
def is_polynomial_time (f : Nat → Nat) : Prop :=
  ∃ k : Nat, IsBigO f (fun n => n ^ k)

-- 예: 선형 탐색 O(n) = O(n¹) → P에 속함
theorem linear_search_in_P :
    is_polynomial_time (fun n => n) := by
  use 1
  use 1, 0
  intro n _hn
  omega

-- 예: 버블 정렬 O(n²) → P에 속함
theorem bubble_sort_in_P :
    is_polynomial_time (fun n => n ^ 2) := by
  use 2
  use 1, 0
  intro n _hn
  omega

-- 예: 행렬 곱 O(n³) → P에 속함
theorem matrix_mul_in_P :
    is_polynomial_time (fun n => n ^ 3) := by
  use 3
  use 1, 0
  intro n _hn
  omega
```

### 6F.12.2 풀기 어려운 문제

**풀기 어려운**(intractable) 문제란, 최악의 경우에 다항식 시간에 동작하는 알고리즘이 **존재하지 않는** 문제이다. 예를 들어, 지수적 복잡도 Θ(2ⁿ)만 알려진 문제가 이에 해당할 수 있다.

### 6F.12.3 클래스 NP

**클래스 NP**(nondeterministic polynomial)는 "답이 주어지면 다항식 시간에 **검증**(verify)할 수 있는" 문제의 모임이다.

예를 들어, **만족성 문제**(satisfiability problem, SAT):
- 주어진 논리식을 **참으로 만드는 변수 할당**이 존재하는가?
- 할당이 **주어지면** 참인지 검사하는 것은 쉽다 (O(n))
- 그러나 할당을 **찾는** 것은 알려진 가장 빠른 방법이 O(2ⁿ)이다

> **P ⊆ NP**: P에 속하는 모든 문제는 NP에도 속한다. 문제를 풀 수 있으면, 당연히 답을 검증할 수도 있기 때문이다.

### 6F.12.4 NP-완전 문제

**NP-완전**(NP-complete) 문제란, NP에 속하면서, **다른 모든 NP 문제를 다항식 시간에 변환할 수 있는** 문제이다.

NP-완전 문제의 중요한 성질: **하나라도** 다항식 시간에 풀리면, **모든 NP 문제가** 다항식 시간에 풀린다. 즉, P = NP가 된다!

대표적 NP-완전 문제:
- **3-SAT**: 각 절이 3개의 리터럴로 이루어진 만족성 문제
- **해밀턴 경로**: 모든 정점을 정확히 한 번 방문하는 경로
- **부분합 문제**: 주어진 수들 중 일부의 합이 목표값과 같은지

### 6F.12.5 P vs NP 문제

> **P = NP인가?**

이것은 수학과 컴퓨터과학에서 **가장 유명한 미해결 문제** 중 하나이다.

- **클레이 수학 연구소**(Clay Mathematics Institute)가 선정한 7대 **밀레니엄 상금 문제** 중 하나
- 해결 시 **100만 달러**($1,000,000)의 상금
- 대부분의 컴퓨터과학자들은 **P ≠ NP**라고 믿지만, 아직 증명하지 못했다

**만약 P = NP라면**:
- 답을 검증할 수 있는 문제는 답을 찾을 수도 있다
- 현재의 많은 암호 체계가 무너질 수 있다
- 인공지능, 최적화 등 많은 분야에 혁명적 변화

**만약 P ≠ NP라면**:
- 어떤 문제들은 본질적으로 풀기 어렵다
- 현재의 암호 체계가 안전하다
- 이것이 현재 대다수의 믿음이다

```lean
-- P vs NP를 Lean4로 형식화하려면
-- 튜링 머신, 비결정적 계산 등의 정의가 필요하다
-- 여기서는 직관적 이해에 집중한다

-- 핵심 포인트: P ⊆ NP는 확실하다
-- P = NP인지 P ≠ NP인지가 미해결
```

### 연습 6F.12: 복잡도 클래스 판별 (괄호 채우기)

**문제**: 다음 문제가 P에 속하는지, NP에 속하는지 고르시오.

```
(a) n개의 수 정렬하기             → ▢ (P / NP만 / 미확정)
(b) n개의 변수 논리식의 만족성    → ▢
(c) 최단 경로 찾기 (Dijkstra)    → ▢
(d) 외판원 문제                   → ▢
(e) 두 수의 곱 계산              → ▢
```

<details>
<summary>💡 답 보기</summary>

```
(a) 정렬 → P (O(n log n) 알고리즘 존재)
(b) SAT → NP (검증은 쉽지만 풀기는 O(2ⁿ)이 최선으로 알려짐)
      NP-완전 문제이기도 하다
(c) 최단 경로 → P (Dijkstra: O(n² log n))
(d) 외판원 → NP-완전 (알려진 최선: O(n² · 2ⁿ))
(e) 두 수의 곱 → P (O(n log n log log n))
```

</details>

---

## 6F.13 교재 연습문제 22: 최선의 경우 분석

### 문제 원문

> 비교를 가장 적게 할 때의 횟수, 즉 **최선의 경우**(best case) 성능을 보여라.

### (a) 최댓값 찾기 알고리즘

최댓값 찾기 알고리즘은 **항상** n - 1번 비교한다. 입력이 어떻든 모든 원소를 한 번씩 확인해야 한다.

따라서: **최선의 경우 = 최악의 경우 = n - 1 = Θ(n)**

### (b) 선형 탐색

**최선의 경우**: 찾는 원소가 **첫 번째**에 있을 때 → **1번** 비교 → **O(1)**

**최악의 경우**: 찾는 원소가 마지막이거나 없을 때 → **n번** 비교 → **O(n)**

```lean
-- 선형 탐색: 최선의 경우 1번
-- 최악의 경우 n번

-- 최선의 경우가 O(1)임을 보이기
theorem linear_search_best :
    IsBigO (fun _ => 1) (fun _ => 1) := by
  use 1, 0
  intro n _hn
  omega
```

### (c) 이진 탐색

**최선의 경우**: 찾는 원소가 **정확히 중간**에 있을 때 → **1번** 비교 → **O(1)**

**최악의 경우**: ⌊log₂ n⌋ + 1번 비교 → **O(log n)**

```lean
-- 이진 탐색: 최선 = 1번, 최악 = log n + 1번
#eval Nat.log 2 1024 + 1   -- 11 (최악)
-- 최선은 항상 1번
```

### 연습 6F.13: 최선/최악 비교 (괄호 채우기)

**문제**: 각 알고리즘의 최선/최악의 경우 비교 횟수를 채우시오.

```
알고리즘        | 최선의 경우 | 최악의 경우
----------------|-----------|----------
최댓값 찾기      | ▢         | ▢
선형 탐색       | ▢         | ▢
이진 탐색       | ▢         | ▢
버블 정렬       | ▢         | ▢
삽입 정렬       | ▢         | ▢
```

<details>
<summary>💡 답 보기</summary>

```
알고리즘        | 최선의 경우    | 최악의 경우
----------------|-------------|------------
최댓값 찾기      | n - 1       | n - 1
선형 탐색       | 1           | n
이진 탐색       | 1           | ⌊log₂ n⌋ + 1
버블 정렬       | n(n-1)/2    | n(n-1)/2
삽입 정렬       | n - 1       | n(n-1)/2
```

**주목할 점**:
- 최댓값 찾기와 버블 정렬은 최선 = 최악이다 (입력에 무관)
- 삽입 정렬은 이미 정렬된 입력에서 최선(n-1), 역순 입력에서 최악(n(n-1)/2)
- 이진 탐색은 최선과 최악의 차이가 매우 크다 (1 vs log n)

</details>

---

## 6F.14 도전 문제

### 도전 6F.1: 복잡도 순서 배열

**문제**: 다음 복잡도를 증가 속도가 느린 순서에서 빠른 순서로 배열하시오.

```
O(n²), O(1), O(n!), O(log n), O(n log n), O(2ⁿ), O(n), O(n³)
```

<details>
<summary>💡 답 보기</summary>

```
O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(n³) < O(2ⁿ) < O(n!)
```

Lean4로 확인 (n = 20):
```lean
#eval (1 : Nat)                     -- 1
#eval Nat.log 2 20                   -- 4
#eval (20 : Nat)                     -- 20
#eval 20 * Nat.log 2 20             -- 80
#eval 20 ^ 2                         -- 400
#eval 20 ^ 3                         -- 8000
#eval (2 : Nat) ^ 20                 -- 1048576
#eval Nat.factorial 20               -- 2432902008176640000
```

n = 20에서도 차이가 극명하다:
- O(n³) = 8천
- O(2ⁿ) = 100만
- O(n!) = 24경(2.4 × 10¹⁸)

</details>

### 도전 6F.2: 거스름돈 알고리즘의 시간복잡도

**문제**: 25센트, 10센트, 5센트, 1센트 동전으로 n센트의 거스름돈을 만드는 탐욕 알고리즘이 O(n)임을 설명하고, Lean4로 간단한 버전을 구현하시오.

```lean
-- 거스름돈 알고리즘
def makeChange (n : Nat) : Nat × Nat × Nat × Nat :=
  let q25 := n / 25
  let r25 := n % 25
  let q10 := r25 / 10
  let r10 := r25 % 10
  let q5 := r10 / 5
  let r5 := r10 % 5
  (q25, q10, q5, r5)

-- 예: 67센트
#eval makeChange 67   -- (2, 1, 1, 2) = 25+25+10+5+1+1

-- 사용 동전 수 계산
def totalCoins (n : Nat) : Nat :=
  let (a, b, c, d) := makeChange n
  a + b + c + d

#eval totalCoins 67   -- 6
```

<details>
<summary>💡 답 보기</summary>

이 알고리즘은 **상수 시간** O(1)에 실행된다! 나눗셈과 나머지 연산이 각각 4번씩, 총 8번의 산술 연산만 필요하기 때문이다. 입력 n이 아무리 커도 연산 횟수는 변하지 않는다.

```lean
-- 알고리즘이 O(1)임을 증명
theorem makeChange_O_1 :
    IsBigO (fun _ => 8) (fun _ => 1) := by
  use 8, 0
  intro n _hn
  omega
```

단, 이것은 "동전의 종류가 4가지로 **고정**"이라는 가정 하에서이다. 만약 동전 종류가 k가지라면 O(k)이고, 동전의 금액이 1센트를 포함하지 않는다면 (예: 3센트, 7센트) 탐욕 알고리즘이 **최적 해를 보장하지 않을 수 있다**.

</details>

---

## 6F.15 전술 및 함수 종합 요약

### 이 편(6-F)에서 사용한 핵심 개념

| 개념 | 설명 |
|------|------|
| **호너의 방법** | 다항식을 중첩 곱셈으로 변환 → 곱셈 절반 |
| **비트 연산 시간** | 가장 낮은 수준의 연산으로 복잡도 측정 |
| **행렬 체인 곱** | 곱하는 순서에 따라 효율이 크게 달라짐 |
| **역지 알고리즘** | 모든 가능성을 직접 조사 |
| **분할정복** | 나누고 → 해결하고 → 합치기 |
| **탐욕 알고리즘** | 매 순간 최선의 선택 |
| **P** | 다항식 시간에 풀 수 있는 문제 |
| **NP** | 다항식 시간에 검증할 수 있는 문제 |
| **NP-완전** | NP의 가장 어려운 문제; P=NP의 열쇠 |

### Lean4 전술 요약

| 전술 | 용도 | 이 장의 예 |
|------|------|---------|
| `ring` | 대수적 등식 | `(2n)² = 4n²` |
| `rfl` | 정의에 의한 동치 | `(n+1)! = (n+1) · n!` |
| `omega` | 선형 산술 | `n < 2n` |
| `nlinarith` | 비선형 산술 | 부등식 증명 |
| `use` | 존재 증인 | `use 1, 0` |
| `intro` | 전칭/함축 도입 | `intro n hn` |
| `calc` | 계산 체인 | 부등식 연쇄 |
| `unfold` | 정의 펼치기 | `unfold closest_pair_ops` |
| `#eval` | 값 계산 | `#eval Nat.factorial 20` |

### Lean4 라이브러리 함수 요약

| 함수 | 의미 | 예 |
|------|------|-----|
| `Nat.log b n` | ⌊logᵦ n⌋ | `Nat.log 2 1024 = 10` |
| `Nat.sqrt n` | ⌊√n⌋ | `Nat.sqrt 100 = 10` |
| `Nat.factorial n` | n! | `Nat.factorial 5 = 120` |
| `List.foldl` | 리스트 접기 | 호너의 방법 |
| `Nat.div_le_self` | a/b ≤ a | 나눗셈 상한 |

---

## 6F.16 핵심 요약

1. **호너의 방법**은 n차 다항식을 곱셈 n번 + 덧셈 n번으로 계산한다 (전통적 방법은 곱셈 2n번).

2. **비트 연산 시간**으로 측정하면, f(n) = 2ⁿ인 알고리즘은 n이 조금만 커져도 현실적으로 풀 수 없다.

3. **행렬 체인 곱**에서 순서 선택이 연산 횟수를 수배 이상 절약할 수 있다.

4. **알고리즘 패러다임**: 역지(모든 가능성), 분할정복(나누고 합치기), 탐욕(매 순간 최선).

5. **P vs NP**는 컴퓨터과학의 가장 중요한 미해결 문제이다. P ≠ NP라면 어떤 문제들은 본질적으로 풀기 어렵다.

6. **복잡도 순서**: O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(n³) < O(2ⁿ) < O(n!)

---

## 다음 편 예고

다음 편(제7편)에서는:
- **수학적 귀납법**(Mathematical Induction)과 Lean4의 `induction` 전술
- **강한 귀납법**(Strong Induction)
- **재귀적 정의**(Recursive Definitions)와 그 정확성 증명

을 다룬다.

---

**(끝)**
