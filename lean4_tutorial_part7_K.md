# Lean4 완전 정복 가이드 — 제7-K편

## **RSA 암호**(RSA Cryptosystem)와 **암호 프로토콜**(Cryptographic Protocols) 완전 정복

> **교재**: Kenneth H. Rosen, "Discrete Mathematics and Its Applications" 8판, 4.6.3~4.6.9절  
> **참고**: 『Mathematics in Lean』 Chapter 5 Elementary Number Theory  
> **선수 학습**: 제7-A~7-J편 (특히 7-E: GCD/역원, 7-H: 페르마 정리, 7-J: 고전 암호)

---

## 7K.0 이 장의 목표

이 장에서 배울 내용은 다음과 같다:

1. **공개키 암호**(public key cryptography)의 핵심 아이디어
2. **RSA 암호방식**: 현대 인터넷 보안의 근간
3. **RSA 암호화와 해독**의 수학적 원리 — 페르마의 작은 정리 활용
4. **키 교환 프로토콜**: **디피-헬만**(Diffie-Hellman) 키 합의
5. **디지털 서명**(digital signature): RSA를 이용한 인증
6. **동형화 암호**(homomorphic encryption): 암호화된 데이터에 직접 연산
7. Lean4로 RSA 시스템을 구현하고 검증하기

이 장은 지금까지 배운 **소수**(prime), **최대공약수**(GCD), **모듈러 역원**(modular inverse), **페르마의 작은 정리**(Fermat's Little Theorem), **나머지 지수승**(modular exponentiation) 등의 모든 개념이 결합되어 실제 세계의 보안 시스템을 만든다는 것을 보여주는 장이다.

---

## 7K.1 **공개키 암호**(Public Key Cryptography)

### 7K.1.1 비밀키 암호의 한계

7-J편에서 배운 **비밀키 암호시스템**(private key cryptosystem)에서는 암호키를 알면 해독키도 빠르게 찾을 수 있다. 따라서 두 사람이 안전하게 통신하려면 **비밀키를 공유**해야 한다. 그런데 키를 안전하게 교환하려면 이미 안전한 통신 수단이 필요한데... 이것은 **닭과 달걀 문제**이다!

### 7K.1.2 핵심 아이디어

1970년대에 암호학자들은 이 문제를 해결하는 혁명적인 아이디어를 냈다:

> **암호화할 수 있다고 해서 해독할 수 있는 것은 아니다!**

비유로 설명하면:
- 자물쇠가 열려 있는 상자를 생각하자.
- 누구나 상자에 물건을 넣고 자물쇠를 잠글 수 있다. (= **암호화**)
- 하지만 자물쇠의 **열쇠**를 가진 사람만 열 수 있다. (= **해독**)
- 자물쇠를 잠글 수 있다고 해서 열 수 있는 것은 아니다!

이것이 **공개키 암호**(public key cryptography)의 핵심이다.

### 7K.1.3 공개키와 비밀키

| 키 종류 | 누가 아는가 | 용도 |
|---------|-----------|------|
| **공개키**(public key) | **모든 사람** | 메시지를 **암호화**하는 데 사용 |
| **비밀키**(private key) | **수신자만** | 메시지를 **해독**하는 데 사용 |

---

## 7K.2 **RSA 암호방식**(RSA Cryptosystem)

### 7K.2.1 역사

1976년 MIT의 세 연구자 **로널드 라이베스트**(Ronald Rivest), **아디 샤미르**(Adi Shamir), **레너드 애들먼**(Leonard Adleman)은 자신들의 이름 첫 글자를 따서 **RSA 시스템**으로 알려진 공개키 암호를 소개했다.

재미있는 사실: 영국 정보기관 GCHQ의 클리포드 콕스(Clifford Cocks)가 1973년에 같은 시스템을 비밀리에 먼저 발견했지만, 1997년에야 공개되었다.

### 7K.2.2 RSA의 수학적 구조

각 사용자는 **암호화키** (n, e)를 갖는다. 여기서:

1. **n = pq**: 두 개의 큰 **소수**(prime) p와 q의 곱
2. **e**: (p-1)(q-1)과 **서로소**(coprime)인 양의 정수

실용적으로:
- p와 q는 대략 300자리 정도의 큰 소수
- n = pq는 대략 600자리
- e는 (p-1)(q-1)과 서로소여야 한다

```lean
-- RSA 키 생성 (교육용 작은 소수)
-- p = 43, q = 59 → n = 43 × 59 = 2537
-- (p-1)(q-1) = 42 × 58 = 2436
-- e = 13 (gcd(13, 2436) = 1이어야 함)

#eval 43 * 59           -- 2537
#eval 42 * 58           -- 2436
#eval Nat.gcd 13 2436   -- 1 ✓ (e = 13은 유효)
```

### 7K.2.3 왜 소인수분해가 중요한가?

RSA의 보안은 다음 사실에 기반한다:

> **큰 수의 소인수분해는 매우 어렵다!**

n = pq를 공개해도, p와 q를 빠르게 찾아내는 알고리즘이 현재까지 알려져 있지 않다.
- 큰 소수를 **찾는** 것은 쉽다 (확률적 소수 테스트)
- 두 수를 **곱하는** 것도 쉽다
- 하지만 그 곱을 다시 **소인수분해**하는 것은 매우 어렵다

이것을 **일방향 함수**(one-way function)라 한다.

---

## 7K.3 **RSA 암호화**(RSA Encryption)

### 7K.3.1 평문을 숫자로 변환

RSA에서는 자리이동 암호처럼 한 글자씩 바꾸는 것이 아니라, **블록 단위**로 암호화한다.

평문을 숫자로 바꾸는 과정:
1. 각 글자를 **두 자리 숫자**로 변환: A=00, B=01, ..., Z=25
2. 이 두 자리 숫자들을 이어붙여 하나의 긴 숫자 문자열을 만든다
3. 이 문자열을 길이 2N의 블록으로 나눈다 (2N은 2525...25가 n을 초과하지 않는 가장 큰 짝수)

### 7K.3.2 암호화 함수

각 블록 m을 암호문 블록 c로 변환:

> **c = mᵉ mod n**

이것이 **RSA 암호화**의 핵심 공식이다!

### 7K.3.3 Lean4 구현

```lean
-- 나머지 지수승 (7-C편에서 배운 것)
def modPow (base exp modulus : Nat) : Nat :=
  if modulus ≤ 1 then 0
  else go base exp modulus 1
where
  go (base exp modulus acc : Nat) : Nat :=
    if exp = 0 then acc
    else
      let acc' := if exp % 2 = 1 then (acc * base) % modulus else acc
      go ((base * base) % modulus) (exp / 2) modulus acc'
  termination_by exp

-- RSA 암호화
def rsaEncrypt (n e m : Nat) : Nat := modPow m e n

-- RSA 해독
def rsaDecrypt (n d c : Nat) : Nat := modPow c d n
```

### 7K.3.4 교재 예제 8: RSA 암호화

> 키 (2537, 13)을 갖는 RSA 암호시스템을 사용하여 메세지 STOP을 암호화하라.
> 2537 = 43 · 59이고 p = 43과 q = 59는 소수이며,
> gcd(e, (p-1)(q-1)) = gcd(13, 42 · 58) = 1임에 유의하라.

**풀이**:

1. 먼저 STOP의 문자들을 해당되는 수로 바꾼다:
   - S=18, T=19, O=14, P=15
   
2. 이 숫자들을 숫자 4개의 블록으로 나눈다 (2525 < 2537 < 252525이므로):
   - **1819** | **1415**

3. 각 블록을 함수 c = m^13 mod 2537을 사용하여 암호화한다:
   - 1819^13 mod 2537 = **2081**
   - 1415^13 mod 2537 = **2182**

```lean
-- Lean4로 확인
#eval rsaEncrypt 2537 13 1819   -- 2081
#eval rsaEncrypt 2537 13 1415   -- 2182
```

암호화된 메시지는 **2081 2182**이다.

### 7K.3.5 중간 괄호 채우기: RSA 암호화

```lean
-- 빈칸을 채워라: 같은 RSA 시스템으로 'HI'를 암호화
-- H=07, I=08 → 블록: 0708
-- 0708^13 mod 2537 = ?
#eval rsaEncrypt 2537 13 708   -- 결과: 🔲

-- 'NO'를 암호화: N=13, O=14 → 블록: 1314
#eval rsaEncrypt 2537 13 1314  -- 결과: 🔲
```

<details>
<summary>💡 답 보기</summary>

```lean
#eval rsaEncrypt 2537 13 708    -- (값은 실행해서 확인)
#eval rsaEncrypt 2537 13 1314   -- (값은 실행해서 확인)

-- Lean4 환경에서 직접 #eval을 실행하면 정확한 값을 얻을 수 있다
-- 수동 계산 시에는 빠른 나머지 지수승 알고리즘을 사용해야 한다
```

</details>

---

## 7K.4 **RSA 해독**(RSA Decryption)

### 7K.4.1 해독키 d 구하기

암호문에서 원문을 얻는 것은 **해독키** d를 알면 빠르게 할 수 있다.

> **d는 e 모듈로 (p-1)(q-1)의 역**(inverse)이다.

즉, d × e ≡ 1 (mod (p-1)(q-1))

gcd(e, (p-1)(q-1)) = 1이기 때문에 이런 역이 **반드시 존재**한다. 이를 확인하려면:

de ≡ 1 (mod (p-1)(q-1))이면 de = 1 + k(p-1)(q-1)인 정수 k가 존재한다는 데 유의하자.

### 7K.4.2 해독 공식

> **m = cᵈ mod n**

### 7K.4.3 왜 해독이 작동하는가? — 페르마의 작은 정리

cᵈ ≡ (mᵉ)ᵈ = m^(de) = m^(1+k(p-1)(q-1)) (mod n)

**페르마의 작은 정리**에 의해 [gcd(m, p) = 1이라고 가정하자]:
- m^(p-1) ≡ 1 (mod p)

따라서:
- cᵈ ≡ m · (m^(p-1))^(k(q-1)) ≡ m · 1 = m (mod p)

마찬가지로:
- cᵈ ≡ m (mod q)

gcd(p, q) = 1이므로, **중국인의 나머지 정리**(Chinese Remainder Theorem)에 의해:

> **cᵈ ≡ m (mod pq) = m (mod n)**

이것이 RSA 해독이 작동하는 수학적 이유이다!

### 7K.4.4 교재 예제 8 계속: 해독키 구하기

p = 43, q = 59, e = 13일 때:
- (p-1)(q-1) = 42 × 58 = 2436
- d는 13 모듈로 2436의 역이다
- 확장 유클리드 알고리즘(7-E편)으로 구하면: d = 937

```lean
-- d 구하기
-- d는 e=13의 mod 2436 역원
-- 확인: 13 * 937 mod 2436 = ?
#eval (13 * 937) % 2436    -- 1 ✓ (12181 % 2436 = 1)

-- 또는 modInverse 사용
-- (이전 편의 modInverse 함수가 필요)
```

### 7K.4.5 교재 예제 9: RSA 해독

> 암호화된 메시지 0981 0461을 받았다. 만약 이 암호문이 예제 8의 RSA로 암호화되었다면 이를 해독하면 무엇이 되는가?

**풀이**: n = 2537, d = 937을 사용한다.

m = c^937 mod 2537

```lean
-- 각 블록을 해독
#eval rsaDecrypt 2537 937 981     -- 0704
#eval rsaDecrypt 2537 937 461     -- 1115

-- 숫자를 문자로: 07=H, 04=E, 11=L, 15=P
-- 원래 메시지: HELP
```

### 7K.4.6 중간 괄호 채우기: RSA 해독

```lean
-- 예제 8의 암호문 2081 2182를 해독하라
-- d = 937, n = 2537
#eval rsaDecrypt 2537 937 2081   -- 결과: 🔲 (1819가 나와야 함)
#eval rsaDecrypt 2537 937 2182   -- 결과: 🔲 (1415가 나와야 함)
```

<details>
<summary>💡 답 보기</summary>

```lean
#eval rsaDecrypt 2537 937 2081   -- 1819 → S(18) T(19) = ST
#eval rsaDecrypt 2537 937 2182   -- 1415 → O(14) P(15) = OP
-- 원래 메시지: STOP ✓
```

</details>

### 7K.4.7 sorry 연습: RSA 왕복 검증

```lean
-- sorry를 채워라: 암호화 → 해독 = 원문
-- n = 2537, e = 13, d = 937
example : rsaDecrypt 2537 937 (rsaEncrypt 2537 13 1819) = 1819 := by sorry
example : rsaDecrypt 2537 937 (rsaEncrypt 2537 13 1415) = 1415 := by sorry

-- e * d ≡ 1 (mod (p-1)(q-1)) 확인
example : (13 * 937) % 2436 = 1 := by sorry
```

<details>
<summary>💡 답 보기</summary>

```lean
example : rsaDecrypt 2537 937 (rsaEncrypt 2537 13 1819) = 1819 := by native_decide
example : rsaDecrypt 2537 937 (rsaEncrypt 2537 13 1415) = 1415 := by native_decide
example : (13 * 937) % 2436 = 1 := by native_decide
```

</details>

---

## 7K.5 RSA의 보안성

### 7K.5.1 왜 안전한가?

해독키 d를 구하려면 (p-1)(q-1)을 알아야 한다. 이를 알려면 p와 q를 알아야 한다. 즉, **n을 소인수분해**해야 한다.

현재까지 알려진 가장 효율적인 소인수분해 알고리즘도 600자리 정도의 수를 소인수분해하는 데 **수십 억 년**이 걸린다!

### 7K.5.2 양자 컴퓨터의 위협

**주의**: 양자 컴퓨터가 실용화되면, **쇼어 알고리즘**(Shor's algorithm)을 사용하여 큰 수를 다항식 시간에 소인수분해할 수 있다. 따라서 양자 컴퓨터가 앞으로 20~30년 이내에 현실화된다면, RSA 암호시스템의 보안이 위협해진다.

---

## 7K.6 **키 교환 프로토콜** — **디피-헬만**(Diffie-Hellman)

### 7K.6.1 문제: 안전하지 않은 채널에서 키 공유하기

앨리스와 밥이 비밀키를 공유하고 싶지만, 통신 채널이 안전하지 않다. 어떻게 비밀키를 안전하게 만들 수 있을까?

### 7K.6.2 디피-헬만 프로토콜

1976년 **휘트필드 디피**(Whitfield Diffie)와 **마틴 헬만**(Martin Hellman)이 고안한 프로토콜이다.

**프로토콜 과정** (계산은 ℤ_p 위에서):

1. 앨리스와 밥은 소수 p와 p의 **기본루트**(primitive root) a를 사용하기로 합의한다. (이 정보는 공개)
2. 앨리스는 비밀정수 k₁을 선택하고, a^k₁ mod p를 밥에게 보낸다.
3. 밥은 비밀정수 k₂를 선택하고 a^k₂ mod p를 앨리스에게 보낸다.
4. 앨리스는 (a^k₂)^k₁ mod p를 계산한다.
5. 밥은 (a^k₁)^k₂ mod p를 계산한다.

핵심: **(a^k₂)^k₁ mod p = (a^k₁)^k₂ mod p** (지수법칙!)

이것이 **공유 비밀키**가 된다.

### 7K.6.3 왜 안전한가?

도청자는 p, a, a^k₁ mod p, a^k₂ mod p를 알 수 있다. 하지만 이 정보만으로 공유키 (a^k₁)^k₂ mod p를 계산하려면, 적어도 a^k₁ mod p에서 k₁을 찾아내야 한다. 이것은 **이산 로그 문제**(discrete logarithm problem)이며, 현재 알려진 방법으로는 p가 충분히 크면 현실적으로 계산할 수 없다.

### 7K.6.4 교재 예제: 디피-헬만 (교재 연습문제 29)

> 앨리스와 밥이 디피-헬만 키 교환 프로토콜을 사용하여 공유키를 만드는 과정을 설명하라.
> 양쪽은 소수 p = 23과 기본 루트인 a = 5를 사용하며, 앨리스는 k₁ = 8을 선택했고 밥은 k₂ = 5를 선택했다고 가정하자.

**풀이**:

```lean
-- 1단계: 공개 값 교환
-- 앨리스 → 밥: a^k₁ mod p = 5^8 mod 23
#eval modPow 5 8 23    -- 16

-- 밥 → 앨리스: a^k₂ mod p = 5^5 mod 23
#eval modPow 5 5 23    -- 20

-- 2단계: 공유 키 계산
-- 앨리스: (a^k₂)^k₁ mod p = 20^8 mod 23
#eval modPow 20 8 23   -- 결과: ?

-- 밥: (a^k₁)^k₂ mod p = 16^5 mod 23
#eval modPow 16 5 23   -- 결과: ? (같은 값이 나와야!)

-- 또는 직접: 5^(8*5) mod 23 = 5^40 mod 23
#eval modPow 5 40 23   -- 결과: 같은 값!
```

### 7K.6.5 괄호 채우기: 디피-헬만 검증

```lean
-- 빈칸을 채워라: 두 결과가 같은지 확인
example : modPow 20 8 23 = modPow 16 5 23 := by native_decide

-- 공유 키의 값은?
-- #eval modPow 20 8 23 → 🔲
```

<details>
<summary>💡 답 보기</summary>

```lean
-- 두 경우 모두 같은 값이 나온다
-- 이것이 앨리스와 밥의 공유 비밀키이다
-- #eval modPow 20 8 23 → (실행해서 확인)
-- #eval modPow 16 5 23 → (같은 값)
example : modPow 20 8 23 = modPow 16 5 23 := by native_decide
```

</details>

---

## 7K.7 **디지털 서명**(Digital Signatures)

### 7K.7.1 문제: 메시지의 진위 확인

암호학은 메시지의 비밀을 유지하는 데 쓸 뿐 아니라, 메시지의 수신자가 "이 메시지가 정말 특정한 사람이 쓴 게 맞는지"를 확인하는 데도 쓰인다.

### 7K.7.2 RSA 디지털 서명의 원리

앨리스의 RSA 공개키가 (n, e)이고 비밀키가 d라고 하자.

- **암호화 함수**: E(x) = x^e mod n
- **해독 함수**: D(x) = x^d mod n

**핵심 관찰**: RSA에서는 **암호화와 해독의 순서를 바꿀 수 있다!**

E(D(x)) = (x^d)^e mod n = x^(de) mod n = x

이것은 D(E(x)) = x와 같은 원리이다.

**서명 과정**:
1. 앨리스는 메시지 M을 **자신의 해독 함수 D**로 먼저 처리한다: D(M) — 이것이 **서명**이다.
2. 서명된 메시지 D(M)을 보낸다.
3. 수신자는 앨리스의 **공개키 E**로 처리한다: E(D(M)) = M
4. 원래 메시지가 복원되면, 앨리스가 보낸 것이 확실하다!

왜? D를 적용할 수 있는 사람은 비밀키 d를 아는 앨리스뿐이기 때문이다.

### 7K.7.3 교재 예제 10: 디지털 서명

> 앨리스의 RSA 암호시스템 공개키가 예제 8과 같다고 하자. 즉, n = 43 · 59 = 2537이고 e = 13이다.
> 해독키는 d = 937로 예제 9와 같다. 그녀는 메시지 "MEET AT NOON"을 친구들에게 보내는데,
> 받는 사람이 이 메시지가 그녀가 보낸 게 확실하다는 것을 알게 하고 싶다.
> 무엇을 보내면 될까?

**풀이**: 
1. 먼저 메시지를 숫자들의 블록으로 바꾼다: 1204 0419 0019 1314 1413
2. 각 블록에 해독함수 D(x) = x^937 mod 2537을 적용한다:

```lean
-- 서명 생성 (해독함수를 먼저 적용)
#eval rsaDecrypt 2537 937 1204   -- 서명1
#eval rsaDecrypt 2537 937 419    -- 서명2
#eval rsaDecrypt 2537 937 19     -- 서명3
#eval rsaDecrypt 2537 937 1314   -- 서명4
#eval rsaDecrypt 2537 937 1413   -- 서명5
```

3. 수신자는 공개키로 확인: 각 블록에 E(x) = x^13 mod 2537을 적용하면 원래 메시지 블록이 복원된다.

### 7K.7.4 sorry 연습: 서명 검증

```lean
-- sorry를 채워라: 서명된 값을 공개키로 복호화하면 원래 메시지가 나온다
-- 블록 1819 (= ST)
-- 서명 = 1819^937 mod 2537
-- 검증 = (서명)^13 mod 2537 = 1819

example : rsaEncrypt 2537 13 (rsaDecrypt 2537 937 1819) = 1819 := by sorry
```

<details>
<summary>💡 답 보기</summary>

```lean
example : rsaEncrypt 2537 13 (rsaDecrypt 2537 937 1819) = 1819 := by native_decide
```

</details>

---

## 7K.8 **동형화 암호**(Homomorphic Encryption)

### 7K.8.1 문제: 암호화된 데이터에 연산하기

RSA와 같은 암호시스템은 파일을 안전하게 암호화하여 **클라우드**(cloud)에 저장할 수 있다. 하지만 때때로, 클라우드에 저장된 파일에 있는 데이터를 가지고 프로그램을 돌릴 때가 있다.

만약 암호화된 데이터 자체에 프로그램을 돌릴 수 있다면 어떨까? 데이터를 해독하지 않고도!

### 7K.8.2 정의

**동형화 암호시스템**(homomorphic cryptosystem)은 암호화된 데이터에 어떤 연산을 해도 그 결과가 암호화하지 않은 데이터에 같은 연산을 하고 다시 암호화한 결과와 **같은** 암호시스템이다.

### 7K.8.3 교재 예제 11: RSA는 부분 동형

(n, e)가 RSA 암호시스템의 공개키이고 M₁과 M₂가 평문 메시지라고 하자. 0 ≤ M₁ < n이고 0 ≤ M₂ < n이다. 그러면 다음이 성립한다:

> E(M₁) · E(M₂) mod n = (M₁^e mod n · M₂^e mod n) mod n = (M₁M₂)^e mod n = E(M₁M₂)

```lean
-- RSA의 곱셈 동형성 확인
-- E(M₁) = M₁^e mod n, E(M₂) = M₂^e mod n
-- E(M₁) * E(M₂) mod n = E(M₁ * M₂ mod n)

-- 구체적 예: n=2537, e=13, M₁=5, M₂=7
#eval rsaEncrypt 2537 13 5    -- E(5)
#eval rsaEncrypt 2537 13 7    -- E(7)
#eval (rsaEncrypt 2537 13 5 * rsaEncrypt 2537 13 7) % 2537  -- E(5)*E(7) mod n
#eval rsaEncrypt 2537 13 (5 * 7 % 2537)                     -- E(35)
-- 두 값이 같아야 한다!
```

즉, RSA는 **곱셈에 대해 동형**(multiplicatively homomorphic)이다. 암호화된 데이터를 해독하지 않고 곱셈을 해도, 두 평문의 곱을 암호화한 것과 같은 결과를 얻는다!

그러나 RSA는 **덧셈에 대해서는 동형이 아니다**:

> E(M₁) + E(M₂) ≠ E(M₁ + M₂) (일반적으로)

따라서 RSA는 **부분 동형**(partially homomorphic)이라고 한다.

### 7K.8.4 완전 동형화 암호

2009년, **크레이크 젠트리**(Craig B. Gentry)는 최초의 **완전 동형 암호시스템**(fully homomorphic cryptosystem)을 제안하였는데, **격자 기반 암호**(lattice-based cryptography)를 이용하였다. 이 시스템에서는 덧셈과 곱셈 **모두** 동형성을 갖는다.

### 7K.8.5 sorry 연습: RSA 곱셈 동형성

```lean
-- sorry를 채워라: RSA의 곱셈 동형성을 구체적 값으로 확인
-- n = 2537, e = 13, M₁ = 10, M₂ = 20
example :
    (rsaEncrypt 2537 13 10 * rsaEncrypt 2537 13 20) % 2537 =
    rsaEncrypt 2537 13 ((10 * 20) % 2537) := by sorry
```

<details>
<summary>💡 답 보기</summary>

```lean
example :
    (rsaEncrypt 2537 13 10 * rsaEncrypt 2537 13 20) % 2537 =
    rsaEncrypt 2537 13 ((10 * 20) % 2537) := by native_decide
```

</details>

---

## 7K.9 연습 세트: RSA와 암호 프로토콜

### 연습 7K.1: RSA 키 생성 (중간 괄호)

```lean
-- 교재 연습문제 24: n = 43 · 59와 e = 13인 RSA 시스템으로
-- 메시지 ATTACK을 암호화하라
-- 먼저 각 글자를 숫자로: A=00, T=19, A=00, C=02, K=10
-- 블록: 0019 1900 0210
-- (마지막 블록이 4자리 미만이면 X(=23) 패딩)

-- 블록 19를 암호화
#eval rsaEncrypt 2537 13 19     -- 🔲
-- 블록 1900을 암호화
#eval rsaEncrypt 2537 13 1900   -- 🔲
-- 블록 210을 암호화
#eval rsaEncrypt 2537 13 210    -- 🔲
```

<details>
<summary>💡 답 보기</summary>

```lean
-- #eval로 실행하면 값을 얻을 수 있다
-- 교재의 방식: 각 글자를 2자리로, 블록 크기 4자리
-- A=00, T=19, T=19, A=00, C=02, K=10
-- 블록: 0019 | 1900 | 0210
#eval rsaEncrypt 2537 13 19     -- (실행하여 확인)
#eval rsaEncrypt 2537 13 1900   -- (실행하여 확인)
#eval rsaEncrypt 2537 13 210    -- (실행하여 확인)
```

</details>

### 연습 7K.2: RSA 해독키 구하기 (sorry)

```lean
-- 교재 연습문제 25: n = 53 · 61 = 3233, e = 17
-- (p-1)(q-1) = 52 × 60 = 3120
-- d를 구하라: d × 17 ≡ 1 (mod 3120)

-- gcd(17, 3120)을 먼저 확인
example : Nat.gcd 17 3120 = 1 := by sorry

-- d를 찾아라 (17의 mod 3120 역원)
-- 힌트: 확장 유클리드 알고리즘 또는 brute force
```

<details>
<summary>💡 답 보기</summary>

```lean
example : Nat.gcd 17 3120 = 1 := by native_decide

-- d = 17의 mod 3120 역원
-- 17 × d ≡ 1 (mod 3120)
-- 확장 유클리드: 17 × 2753 = 46801 = 15 × 3120 + 1
-- 따라서 d = 2753

-- 확인:
-- #eval (17 * 2753) % 3120  → 1
example : (17 * 2753) % 3120 = 1 := by native_decide
```

</details>

### 연습 7K.3: RSA 해독 (sorry)

```lean
-- 교재 연습문제 26: 암호화된 메시지가 3185 2038 2460 2550일 때
-- n = 53 · 61 = 3233, e = 17인 RSA 시스템을 사용하여 암호화한 원래 메시지는?
-- (먼저 해독지수 d를 구하라)

-- 해독: c^d mod n
-- d는 e=17의 mod 52*60=3120 역원
-- d = ?

-- 힌트: 연습 7K.2에서 d를 구했다면:
-- #eval rsaDecrypt 3233 d 3185
-- #eval rsaDecrypt 3233 d 2038
-- #eval rsaDecrypt 3233 d 2460
-- #eval rsaDecrypt 3233 d 2550
```

<details>
<summary>💡 답 보기</summary>

```lean
-- d = 2753 (연습 7K.2에서 구함)
-- 각 블록 해독:
#eval rsaDecrypt 3233 2753 3185   -- (실행하여 확인, 숫자→글자 변환)
#eval rsaDecrypt 3233 2753 2038
#eval rsaDecrypt 3233 2753 2460
#eval rsaDecrypt 3233 2753 2550
-- 결과를 2자리 숫자로 나누어 글자로 변환
```

</details>

### 연습 7K.4: 디피-헬만 키 교환 (중간 괄호)

```lean
-- 교재 연습문제 30: p = 101, a = 2
-- 앨리스는 k₁ = 7, 밥은 k₂ = 9

-- 앨리스가 밥에게 보내는 값: 2^7 mod 101 = ?
#eval modPow 2 7 101    -- 🔲

-- 밥이 앨리스에게 보내는 값: 2^9 mod 101 = ?
#eval modPow 2 9 101    -- 🔲

-- 공유키: 양쪽이 계산한 값이 같은지 확인
-- (2^9 mod 101)^7 mod 101 = (2^7 mod 101)^9 mod 101 ?
```

<details>
<summary>💡 답 보기</summary>

```lean
#eval modPow 2 7 101    -- 128 % 101 = 27
#eval modPow 2 9 101    -- 512 % 101 = 7

-- 공유키 계산
#eval modPow 7 7 101    -- 앨리스: (밥의 값)^k₁ mod p
#eval modPow 27 9 101   -- 밥: (앨리스의 값)^k₂ mod p
-- 두 값이 같아야 한다!

-- 또는 직접: 2^(7*9) mod 101 = 2^63 mod 101
#eval modPow 2 63 101
```

</details>

### 연습 7K.5: 소인수분해의 어려움 (서술 문제)

> n이 두 소수 p와 q의 곱이라는 것을 알고 (p-1)(q-1)을 아는 것만으로 n을 쉽게 소인수분해할 수 있음을 보여라.

<details>
<summary>💡 답 보기</summary>

(p-1)(q-1) = pq - p - q + 1 = n - p - q + 1

따라서 p + q = n - (p-1)(q-1) + 1

p + q를 알면, p - q = √((p+q)² - 4n)을 구할 수 있다.

그러면 p = ((p+q) + (p-q)) / 2, q = ((p+q) - (p-q)) / 2

예: n = 2537, (p-1)(q-1) = 2436
- p + q = 2537 - 2436 + 1 = 102
- p - q = √(102² - 4×2537) = √(10404 - 10148) = √256 = 16
- p = (102 + 16)/2 = 59, q = (102 - 16)/2 = 43

```lean
-- Lean4로 확인
#eval 2537 - 2436 + 1   -- 102 (= p + q)
-- p = 59, q = 43
#eval 59 + 43           -- 102 ✓
#eval 59 * 43           -- 2537 ✓
```

</details>

### 도전 7K.1: RSA 완전 시스템 구현

```lean
-- RSA 시스템을 처음부터 끝까지 구현하라
-- 1. 소수 p = 61, q = 53을 선택
-- 2. n = p * q를 계산
-- 3. (p-1)(q-1)을 계산
-- 4. gcd(e, (p-1)(q-1)) = 1인 e를 선택
-- 5. d = e의 mod (p-1)(q-1) 역원을 계산
-- 6. "LEAN"을 암호화하고 해독하라

-- 여기에 코드를 작성하라:
-- sorry
```

<details>
<summary>💡 답 보기</summary>

```lean
-- 1. 소수 선택
def my_p := 61
def my_q := 53

-- 2. n 계산
def my_n := my_p * my_q   -- 3233
#eval my_n                 -- 3233

-- 3. φ(n) = (p-1)(q-1) 계산
def my_phi := (my_p - 1) * (my_q - 1)   -- 3120
#eval my_phi               -- 3120

-- 4. e 선택 (gcd(e, 3120) = 1)
def my_e := 17
#eval Nat.gcd my_e my_phi  -- 1 ✓

-- 5. d 계산 (e의 mod φ 역원)
-- 17d ≡ 1 (mod 3120)
-- d를 brute force로 찾거나 확장 유클리드 사용
def my_d := 2753   -- 17 × 2753 = 46801 = 15×3120 + 1
#eval (my_e * my_d) % my_phi  -- 1 ✓

-- 6. "LEAN" 암호화
-- L=11, E=04, A=00, N=13
-- 블록: 1104, 0013
#eval rsaEncrypt my_n my_e 1104   -- 암호문 블록 1
#eval rsaEncrypt my_n my_e 13     -- 암호문 블록 2

-- 해독
-- #eval rsaDecrypt my_n my_d (위의 암호문 블록 1)   → 1104
-- #eval rsaDecrypt my_n my_d (위의 암호문 블록 2)   → 13
```

</details>

---

## 7K.10 전술 요약

### 새로운 전술 & 개념

| 전술/개념 | 용도 | 예시 |
|---------|------|------|
| `rsaEncrypt` | m^e mod n | RSA 암호화 |
| `rsaDecrypt` | c^d mod n | RSA 해독 |
| `modPow` | 나머지 지수승 | 모든 RSA 연산의 핵심 |
| `native_decide` | 큰 수의 계산 검증 | RSA 등식 확인 |
| `Nat.totient` | 오일러 파이 함수 | φ(n) = (p-1)(q-1) |

### 이전 장 전술 (복습)

| 전술 | 최초 등장 |
|------|---------|
| `Nat.gcd`, `modInverse` | Part 7-E |
| `Nat.Prime` | Part 7-D |
| `%`, `Nat.add_mod`, `Nat.mul_mod` | Part 7-B |
| `norm_num`, `omega`, `ring` | Part 4-5 |

---

## 7K.11 핵심 정리 요약

1. **공개키 암호**: 암호키(공개)와 해독키(비밀)가 다르다

2. **RSA**: n = pq (큰 소수), 암호화: c = m^e mod n, 해독: m = c^d mod n
   - de ≡ 1 (mod (p-1)(q-1))
   - 보안: n의 소인수분해가 어렵다

3. **RSA 해독의 원리**: 페르마의 작은 정리 + 중국인의 나머지 정리
   - c^d = m^(ed) = m^(1+k(p-1)(q-1)) ≡ m (mod n)

4. **디피-헬만 키 교환**: (a^k₁)^k₂ = (a^k₂)^k₁ mod p
   - 보안: 이산 로그 문제의 어려움

5. **디지털 서명**: D(M)을 보내면, E(D(M)) = M으로 검증
   - RSA에서 암호화와 해독 순서를 바꿀 수 있는 성질 이용

6. **동형화 암호**: E(M₁) · E(M₂) = E(M₁ · M₂) (RSA는 곱셈에 대해 동형)
   - 완전 동형: 덧셈+곱셈 모두 동형 (2009년 젠트리)

---

## 7K.12 4.6절 연습문제 안내 (교재 연습문제 번호)

교재 연습문제 중 이 편에서 다룬 것들:

| 교재 번호 | 이 편의 위치 | 내용 |
|---------|-----------|------|
| 1~3 | 7J.10 연습 | 자리이동/아핀 암호화 |
| 4 | 7J.10 연습 | 카이사르 해독 |
| 5~6 | 7J.4, 7J.10 | 자리이동 해독, 빈도분석 |
| 7~9 | 7J.10 연습 | 암호해독 |
| 14~15 | 7J.8 | 전치암호 |
| 24~27 | 7K.9 연습 | RSA 암호화/해독 |
| 28 | 7K.4 (해독 원리) | RSA 일반 증명 |
| 29~30 | 7K.6, 7K.9 | 디피-헬만 |
| 31~32 | 7K.7, 7K.9 | 디지털 서명 |

---

## 제7편 시리즈 완성! 🎉

이로써 Rosen 교재 4장(정수론과 암호) 전체를 Lean4로 다룬 제7편 시리즈가 완성되었다:

| 파트 | 교재 절 | 핵심 내용 |
|------|--------|---------|
| **7-A** | 4.1 전반 | **가분성**(divisibility), 정리/보조정리, →/↔ |
| **7-B** | 4.1 후반 | **합동**(congruence), 나머지 산술 |
| **7-C** | 4.2 | **진법 전환**, 나머지 지수승 |
| **7-D** | 4.3 전반 | **소수**(primes), 소인수분해 |
| **7-E** | 4.3 후반 | **GCD**, 유클리드 알고리즘, **배주 정리** |
| **7-F** | 4.4 | **선형 합동**, 모듈러 역원 |
| **7-G** | 4.4 후반 | **중국인의 나머지 정리** |
| **7-H** | 4.4 | **페르마 정리**, 원시근, 이산로그 |
| **7-I** | 4.5 | **해시**, 난수, **검사숫자** |
| **7-J** | 4.6 전반 | **고전 암호**: 카이사르, 아핀, 전치 |
| **7-K** | 4.6 후반 | **RSA**, 디피-헬만, 디지털 서명, 동형화 암호 |

---

**(끝)**
