# Lean4 완전 정복 가이드 — 제1편

## 정리 증명 시스템

---

# 제1편: Lean4란 무엇인가?

---

## 1.1 Lean4의 정체: 수학 증명 검사기

### Lean4가 뭐야?

**Lean4**는 **컴퓨터가 수학 증명을 검사해주는 프로그램**이다.

일상생활에서 비유하면:

| 도구 | 하는 일 |
|------|---------|
| 맞춤법 검사기 | 글자가 맞는지 검사 |
| 계산기 | 숫자 계산이 맞는지 검사 |
| **Lean4** | **수학 증명이 논리적으로 맞는지 검사** |

### 왜 필요해?

수학 증명을 할 때 사람은 실수할 수 있다:
- "이건 당연하잖아" 하고 넘어갔는데 사실 틀린 경우
- 경우의 수를 빠뜨린 경우
- 논리가 비약된 경우

**Lean4는 이런 실수를 절대 허용하지 않는다.** 한 줄 한 줄 모두 검사한다!

---

## 1.2 수학에서 하는 일 3가지

수학에서 우리가 하는 일을 생각해보자:

### (1) 정의 (Definition) — 개념을 설명한다

```
"짝수란 2로 나누어떨어지는 수다"
"소수란 1과 자기 자신으로만 나누어떨어지는 수다"
```

### (2) 주장 (Statement) — 참이라고 믿는 것을 적는다

```
"4는 짝수다"
"모든 짝수의 제곱은 짝수다"
```

### (3) 증명 (Proof) — 왜 참인지 근거를 댄다

```
"4 = 2 × 2이므로 2로 나누어떨어진다. 따라서 4는 짝수다."
```

---

## 1.3 Lean4로 위의 3가지를 해보자

### 예제: "4는 짝수다"를 Lean4로 증명하기

```lean
-- (1) 정의: 짝수가 뭔지 정의한다
def Even (n : Nat) : Prop := ∃ k, n = 2 * k
```

**한 줄씩 뜯어보자:**

```
def Even (n : Nat) : Prop := ∃ k, n = 2 * k
 ↑    ↑      ↑        ↑           ↑
 │    │      │        │           └── "n = 2 × k인 k가 존재한다"
 │    │      │        └── 이건 명제(Prop)다 (참/거짓 주장)
 │    │      └── n은 자연수(Nat)다
 │    └── "Even"이라는 이름
 └── 새로운 것을 정의한다
```

**한글 번역:**
```
Even(n)의 정의:
  "n이 짝수다" = "n = 2 × k인 자연수 k가 존재한다"
```

---

```lean
-- (2) 주장 + (3) 증명: 4가 짝수임을 증명한다
theorem four_is_even : Even 4 := by
  use 2
  rfl
```

**이게 무슨 말이야? 한 줄씩 뜯어보자:**

#### 첫 줄: `theorem four_is_even : Even 4 := by`

```
theorem four_is_even : Even 4 := by
   ↑          ↑           ↑       ↑
   │          │           │       └── "by" = 전술(tactic)로 증명하겠다
   │          │           └── 증명할 것: "4는 짝수다"
   │          └── 이 정리의 이름
   └── 정리를 선언한다
```

**한글 번역:**
```
정리 four_is_even:
  "Even 4" (4는 짝수다)를 증명하겠다.
  증명 방법: 전술(tactic)을 사용한다.
```

#### 둘째 줄: `use 2`

**`use`가 뭐야?**

`Even 4`의 정의를 다시 보자:
```
Even 4 = "4 = 2 × k인 k가 존재한다"
```

여기서 **"존재한다(∃)"**를 증명하려면, **구체적인 예시**를 보여줘야 한다!

```
use 2의 의미:
  "k = 2를 쓰겠다"
  "4 = 2 × 2임을 보여주면 증명 끝!"
```

`use 2` 실행 후 목표가 바뀐다:
```
실행 전 목표: ∃ k, 4 = 2 * k   (그런 k가 존재한다)
실행 후 목표: 4 = 2 * 2        (k=2를 대입한 구체적 식)
```

#### 셋째 줄: `rfl`

**`rfl`이 뭐야?**

`rfl`은 **"reflexivity"(반사성)**의 약자다.

**의미: "같은 건 같다"**

```
목표: 4 = 2 * 2

Lean이 하는 일:
  1. 오른쪽 "2 * 2"를 계산한다 → 4
  2. 이제 "4 = 4"가 되었다
  3. 같은 건 같으니까 (rfl) 증명 끝!
```

**일상 비유:**
```
문제: "2 + 2 = 4"를 증명하라

rfl의 생각:
  "2 + 2를 계산하면 4잖아"
  "4 = 4는 당연히 참이지"
  "끝!"
```

---

### 전체 흐름 시각화

```
┌────────────────────────────────────────────────────┐
│ 목표: Even 4                                       │
│       = ∃ k, 4 = 2 * k                             │
│       = "4 = 2×k인 k가 존재한다"                    │
└────────────────────────────────────────────────────┘
                      │
                      │ use 2  ("k = 2를 쓰겠다")
                      ▼
┌────────────────────────────────────────────────────┐
│ 목표: 4 = 2 * 2                                    │
│       = "4 = 4"  (계산하면)                         │
└────────────────────────────────────────────────────┘
                      │
                      │ rfl  ("같은 건 같다")
                      ▼
┌────────────────────────────────────────────────────┐
│                 증명 완료! ✓                        │
└────────────────────────────────────────────────────┘
```

---

## 1.4 `rfl` 완전 정복

### `rfl`이 통하는 경우

**원리: Lean이 양쪽을 계산해서 같은 값이 나오면 `rfl`로 증명된다**

```lean
-- 예시 1: 덧셈
theorem ex1 : 2 + 3 = 5 := rfl
```
```
Lean의 생각:
  왼쪽: 2 + 3 → 계산 → 5
  오른쪽: 5
  결과: 5 = 5 ✓
```

```lean
-- 예시 2: 곱셈
theorem ex2 : 3 * 4 = 12 := rfl
```
```
Lean의 생각:
  왼쪽: 3 * 4 → 계산 → 12
  오른쪽: 12
  결과: 12 = 12 ✓
```

```lean
-- 예시 3: 리스트 길이
theorem ex3 : [1, 2, 3].length = 3 := rfl
```
```
Lean의 생각:
  왼쪽: [1, 2, 3].length → 계산 → 3
  오른쪽: 3
  결과: 3 = 3 ✓
```

```lean
-- 예시 4: 함수 적용
def double (n : Nat) : Nat := 2 * n

theorem ex4 : double 5 = 10 := rfl
```
```
Lean의 생각:
  왼쪽: double 5 → 정의에 의해 2 * 5 → 계산 → 10
  오른쪽: 10
  결과: 10 = 10 ✓
```

### `rfl`이 안 통하는 경우

```lean
-- 이건 오류가 난다!
-- theorem ex5 (a b : Nat) : a + b = b + a := rfl
```
```
왜 안 될까?

Lean의 생각:
  왼쪽: a + b → a가 뭔지 모름, 계산 불가!
  오른쪽: b + a → b가 뭔지 모름, 계산 불가!
  
  a = 3, b = 5일 수도 있고
  a = 100, b = 0일 수도 있고...
  
  구체적인 값을 모르니까 계산할 수 없다!
```

**해결책: 다른 방법(전술)을 써야 한다**
```lean
theorem ex5 (a b : Nat) : a + b = b + a := Nat.add_comm a b
-- 또는
theorem ex5' (a b : Nat) : a + b = b + a := by ring
```

---

## 1.5 정의(def)와 정리(theorem)의 차이

### `def` — 값이나 함수를 정의

```lean
def myNumber : Nat := 42
```
```
번역: "myNumber라는 이름을 42에 붙인다"

myNumber의 타입: Nat (자연수)
myNumber의 값: 42
```

```lean
def double (n : Nat) : Nat := 2 * n
```
```
번역: "double이라는 함수를 정의한다"

입력: n (자연수)
출력: 2 * n (자연수)
```

### `theorem` — 참인 명제를 증명

```lean
theorem two_plus_two : 2 + 2 = 4 := rfl
```
```
번역: "2 + 2 = 4가 참임을 증명한다"

명제: 2 + 2 = 4
증명: rfl (계산하면 같으니까)
```

### 핵심 차이

| 구분 | def | theorem |
|------|-----|---------|
| **목적** | 값/함수 정의 | 명제 증명 |
| **결과** | 계산에 사용 가능 | 다른 증명에 사용 가능 |
| **`:=` 오른쪽** | 값 | 증명 |

---

## 1.6 #check와 #eval — Lean에게 물어보기

### `#check` — "이게 무슨 타입이야?"

```lean
#check Nat
```
**결과:** `Nat : Type`
```
번역: "Nat은 Type(타입)이다"
의미: Nat은 데이터의 종류를 나타낸다
```

```lean
#check 42
```
**결과:** `42 : Nat`
```
번역: "42는 Nat(자연수) 타입이다"
의미: 42는 자연수다
```

```lean
#check "hello"
```
**결과:** `"hello" : String`
```
번역: "hello"는 String(문자열) 타입이다
```

```lean
#check 2 + 2 = 4
```
**결과:** `2 + 2 = 4 : Prop`
```
번역: "2 + 2 = 4"는 Prop(명제) 타입이다
의미: 이건 참/거짓을 따질 수 있는 주장이다
```

```lean
#check fun x => x + 1
```
**결과:** `fun x => x + 1 : Nat → Nat`
```
번역: 이 함수는 "Nat → Nat" 타입이다
의미: 자연수를 받아서 자연수를 돌려주는 함수
```

### `#eval` — "계산해봐!"

```lean
#eval 2 + 3
```
**결과:** `5`
```
Lean이 2 + 3을 계산해서 5를 보여준다
```

```lean
#eval 10 * 20
```
**결과:** `200`

```lean
#eval "Hello, " ++ "World!"
```
**결과:** `"Hello, World!"`
```
++ 는 문자열을 이어붙이는 연산자
```

```lean
#eval [1, 2, 3].length
```
**결과:** `3`
```
리스트 [1, 2, 3]의 길이를 계산
```

```lean
#eval [1, 2, 3].reverse
```
**결과:** `[3, 2, 1]`
```
리스트를 뒤집는다
```

```lean
#eval (fun x => x * x) 7
```
**결과:** `49`
```
"x를 받아서 x * x를 돌려주는 함수"에 7을 넣음
7 * 7 = 49
```

### `#check` vs `#eval` 비교

| 명령 | 물어보는 것 | 예시 | 결과 |
|------|-------------|------|------|
| `#check` | 타입이 뭐야? | `#check 42` | `42 : Nat` |
| `#eval` | 값이 뭐야? | `#eval 2+3` | `5` |

**주의: `#eval`은 Prop에는 쓸 수 없다!**

```lean
-- 이건 오류!
-- #eval 2 + 2 = 4
```
```
왜? 
"2 + 2 = 4"는 명제(Prop)다.
명제는 "계산"하는 게 아니라 "증명"해야 한다!
```

---

## 1.7 Type과 Prop — Lean의 두 세계

Lean에는 크게 **두 가지 세계**가 있다:

### Type의 세계 — 데이터

```lean
#check Nat          -- Nat : Type
#check Bool         -- Bool : Type  
#check String       -- String : Type
#check List Nat     -- List Nat : Type
```

Type의 세계에 있는 것들:
- 자연수: `0, 1, 2, 3, ...`
- 참/거짓: `true, false`
- 문자열: `"hello", "world", ...`
- 리스트: `[1, 2, 3], [], ...`

**Type의 세계에서 하는 일: 계산**

```lean
#eval 2 + 3          -- 5
#eval true && false  -- false
#eval [1,2] ++ [3]   -- [1, 2, 3]
```

### Prop의 세계 — 명제

```lean
#check 2 + 2 = 4           -- Prop
#check 1 = 2               -- Prop (거짓이지만 명제는 맞음)
#check ∀ n : Nat, n = n    -- Prop
```

Prop의 세계에 있는 것들:
- `2 + 2 = 4` (참인 명제)
- `1 = 2` (거짓인 명제)
- `모든 n에 대해 n = n` (참인 명제)

**Prop의 세계에서 하는 일: 증명**

```lean
theorem t1 : 2 + 2 = 4 := rfl
-- theorem t2 : 1 = 2 := ???  -- 증명 불가능! (거짓이니까)
theorem t3 : ∀ n : Nat, n = n := fun n => rfl
```

### 두 세계 비교표

| 특성 | Type (데이터) | Prop (명제) |
|------|---------------|-------------|
| **예시** | `Nat`, `Bool`, `String` | `2+2=4`, `∀n, n=n` |
| **값** | 구체적 데이터 | 증명(proof) |
| **확인** | `#eval` (계산) | `theorem` (증명) |
| **비유** | 상자 안의 물건 | 판사의 판결문 |

---

## 1.8 이 장의 핵심 요약

### 배운 것들

1. **Lean4란?** — 수학 증명을 검사하는 프로그램

2. **수학의 3단계** — 정의 → 주장 → 증명

3. **Lean 명령어**
   - `def`: 값/함수 정의
   - `theorem`: 명제 증명
   - `#check`: 타입 확인
   - `#eval`: 값 계산

4. **`rfl`** — "같은 건 같다" (계산해서 같으면 OK)

5. **Type vs Prop**
   - Type: 데이터의 세계 (계산)
   - Prop: 명제의 세계 (증명)

### 기억할 코드 패턴

```lean
-- 값 정의
def 이름 : 타입 := 값

-- 함수 정의  
def 함수이름 (인자 : 타입) : 반환타입 := 본문

-- 정리 증명
theorem 정리이름 : 명제 := 증명

-- 타입 확인
#check 표현식

-- 값 계산
#eval 표현식
```

---

## 1.9 연습 문제

### 문제 1: `#check` 예측하기

다음 각각에 대해 `#check`의 결과를 예측해보라:

```lean
#check 100
#check true
#check "Lean"
#check [1, 2, 3]
#check 3 + 4 = 7
```

<details>
<summary>정답 보기</summary>

```
100 : Nat
true : Bool
"Lean" : String
[1, 2, 3] : List Nat
3 + 4 = 7 : Prop
```
</details>

### 문제 2: `#eval` 예측하기

다음 각각에 대해 `#eval`의 결과를 예측해보라:

```lean
#eval 5 * 6
#eval "Hello" ++ "!"
#eval [1, 2, 3, 4].length
#eval (fun x => x + 10) 5
```

<details>
<summary>정답 보기</summary>

```
30
"Hello!"
4
15
```
</details>

### 문제 3: `rfl`로 증명하기

다음 정리들을 `rfl`로 증명해보라:

```lean
theorem p1 : 3 + 5 = 8 := sorry
theorem p2 : 2 * 6 = 12 := sorry
theorem p3 : [1, 2].length = 2 := sorry
```

<details>
<summary>정답 보기</summary>

```lean
theorem p1 : 3 + 5 = 8 := rfl
theorem p2 : 2 * 6 = 12 := rfl
theorem p3 : [1, 2].length = 2 := rfl
```

모두 Lean이 계산해서 양쪽이 같아지므로 `rfl`로 충분하다.
</details>

### 문제 4: `rfl`로 안 되는 이유 설명하기

다음 정리는 왜 `rfl`로 증명되지 않을까?

```lean
-- theorem p4 (n : Nat) : n + 0 = n := rfl  -- 오류!
```

<details>
<summary>정답 보기</summary>

`n`이 구체적인 숫자가 아니기 때문이다.

`n = 0`일 수도, `n = 100`일 수도 있다. Lean은 `n + 0`을 구체적인 값으로 계산할 수 없다.

단, Lean의 덧셈 정의에서 `n + 0 = n`은 정의 자체에 포함되어 있어서, 실제로는 `rfl`로 되기도 한다! (Lean 버전에 따라 다름)

</details>

---

## 다음 편 예고

**제2편: 기본 데이터 타입**에서는:
- `Nat` (자연수)
- `Bool` (참/거짓)
- `List` (리스트)
- 함수 타입 `→`

를 자세히 다룬다.
